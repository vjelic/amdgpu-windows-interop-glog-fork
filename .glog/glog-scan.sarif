{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "14e815ff-e7c8-33f9-9bfb-53bfbe8c4527",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It returns the number of characters in a string up to but not including the first null character. The vulnerability arises when the string does not have a null character, causing `strlen()` to continue reading until it finds a null character, potentially leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your string. Also, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter to specify the maximum number of characters to be read.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar str[] = \"Hello, World!\";\nint len = strlen(str);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar str[] = \"Hello, World!\";\nint len = strnlen(str, sizeof(str));\n```\n\nIn the fixed code, `strnlen()` is used instead of `strlen()`. The second parameter to `strnlen()` is the maximum number of characters that `strnlen()` will read. If `str` does not have a null character within this limit, `strnlen()` will stop reading and return the limit.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "04c068aa-4f2a-3aef-9486-8c422ad093a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It returns the number of characters in a string up to but not including the first null character. The vulnerability arises when the string does not have a null character, causing `strlen()` to read past the intended memory, leading to a buffer overflow. This can result in crashes, incorrect behavior, or allow for execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that are not guaranteed to be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(pStr)` with `strnlen(pStr, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of the string.\n\n```cpp\n#include <string.h>\n\n#define MAX_LENGTH 100\n\n// ...\n\nchar *pStr = /* ... */;\nsize_t len = strnlen(pStr, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strlen()` and `strnlen()` functions are part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "b8f3deeb-d402-3d76-b255-a552045fde3d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "d002c5a3-a1bb-3001-8c8f-2ac1f20b607d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `m_size * sizeof(T)` is larger than the size of `pData`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the provided code snippet:\n\n```cpp\nif (m_size * sizeof(T) <= sizeof(pData)) {\n    memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we check if `m_size * sizeof(T)` is larger than the size of `pData` before calling `memcpy`. If it is, we handle the error instead of causing a buffer overflow.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a later date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6c6d7c19-dc3c-3b89-a094-bee9ec7d7d19",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null byte.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null byte at the end, or by manually adding a null byte after the last character of the string.\n\n## Source Code Fix Recommendation\n\nIf `pString` is a character array, you can ensure it is null-terminated by initializing it with a null byte:\n\n```cpp\nchar pString[] = \"Hello, world!\";\n```\n\nIf `pString` is a pointer to a string, you can add a null byte at the end:\n\n```cpp\nchar* pString = new char[14];\nstrcpy(pString, \"Hello, world!\");\npString[13] = '\\0';\n```\n\nIn both cases, `strlen(pString)` will now correctly return 13.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "296e2250-782f-36e0-9975-0758d87a7518",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before the `memcpy` function is called. \n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nsize_t size = sizeof(T);\nif (oldSize + size > sizeof(m_pData)) {\n    // Handle error: buffer overflow\n} else {\n    memcpy(&m_pData[oldSize], pTs, size);\n}\n```\n\nIn this code, we first calculate the size of the data being copied. Then we check if adding this size to the old size of the buffer would exceed the total size of the buffer. If it would, we handle the error (for example, by throwing an exception or returning an error code). If it wouldn't, we proceed with the `memcpy` operation.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1664fdc3-5fa3-3532-8fab-29551e7dcd7d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null byte.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null byte at the end, or by manually adding a null byte after the last character of the string.\n\n## Source Code Fix Recommendation\n\nIf `pKey` is a string that may not be null-terminated, you can ensure it is null-terminated before passing it to `strlen()`:\n\n```cpp\nsize_t len;\nif (pKey) {\n    pKey[strlen(pKey)] = '\\0';\n    len = strlen(pKey);\n}\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "cf05425e-8e09-34ea-bf47-148d0be1b604",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will keep reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or even code execution if an attacker can control the overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings, and consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read beyond this length.\n\n## Source Code Fix Recommendation\n\nIf `m_data` is a char array, you should ensure it is null-terminated. If it is not guaranteed to be null-terminated, you should use `strnlen()` instead of `strlen()`. Here is an example:\n\n```cpp\n#include <cstring> // for strnlen\n\nconst size_t MAX_LENGTH = 100; // replace with your maximum length\nsize_t length = strnlen(m_data, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so you need to include `<cstring>` or `<string.h>`.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "bb18955c-fc95-3b0a-b89f-32abc469a2dd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "1c741ce1-17bd-3451-bc77-16e5f02a9030",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null, since there is no prior check ensuring it is valid. The destination is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence issue. The operation uses the size of the destination variable for the copy, but this does not mitigate the undefined behavior risk if the memory regions overlap. Developers should ensure that the source and destination do not overlap and that the source pointer is valid before performing the copy.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. If overlap is possible, use a function that safely handles overlapping regions, such as `memmove`. Also, check that the source pointer is not null before copying. For example:\n\n```c\nif (ptr != NULL && ((uintptr_t)&val + sizeof(val) <= (uintptr_t)ptr || (uintptr_t)ptr + sizeof(val) <= (uintptr_t)&val)) {\n    memcpy(&val, ptr, sizeof(val));\n} else if (ptr != NULL) {\n    memmove(&val, ptr, sizeof(val));\n} else {\n    // Handle null pointer error\n}\n```\n\nThis approach first checks for null pointers and then determines if the memory regions overlap. If overlap is detected, it uses `memmove` instead of `memcpy` to avoid undefined behavior. Always validate pointers before use to prevent null pointer dereference vulnerabilities.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "56adfc27-0e25-3105-857a-c6a2b1d5ce65",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or code execution vulnerabilities if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, consider using a method that does not involve environment variables to enable logging. If you must use environment variables, ensure that they are properly sanitized and validated before use.\n\n## Source Code Fix Recommendation\n\n```cpp\n// Instead of using getenv(), consider using a configuration file or command line argument to enable logging.\n// If you must use an environment variable, ensure it is properly sanitized and validated.\n\nconst char* env_var = getenv(\"LOADER_ENABLE_LOGGING\");\nif(env_var != NULL) {\n    std::string logging_env(env_var);\n    // Perform sanitization and validation on logging_env before use\n    enable_logging = logging_env;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::string`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "449099df-f234-3773-903f-01be403cde8c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard ensuring the source pointer is non-null, which increases the risk of a null pointer dereference. The destination is not a pointer-based member, so it is likely a local variable or field, reducing the risk of a null destination. The use of a memory copy function without explicit checks for overlap or null pointers can lead to unpredictable program behavior, memory corruption, or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use a function that safely handles overlapping regions, such as `memmove`, instead of `memcpy`. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```c\nif (ptr != NULL && &val != ptr) {\n    memcpy(&val, ptr, sizeof(val));\n} else if (ptr != NULL) {\n    // If overlap is possible, use memmove\n    memmove(&val, ptr, sizeof(val));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c6181961-5724-3585-97a6-5de2ef6c74ce",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard ensuring that the source pointer is non-null, which increases the risk of a null pointer dereference. The destination is not likely to be null, but the source may be. The use of a memory copy function with potentially overlapping regions can result in unpredictable behavior, data corruption, or crashes. These factors make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions, such as `memmove`. Additionally, ensure that the source pointer is not null before performing the copy to avoid null pointer dereference. For example:\n\n```c\nif (ptr != NULL) {\n    memmove(&val, ptr, sizeof(val));\n}\n```\n\nThis change ensures that the copy operation is safe even if the source and destination overlap, and it guards against null pointer dereference. \n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "96252727-9c04-3b1b-b5ac-57f6d2d4b6fd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or unauthorized code execution if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking and do not suffer from the same vulnerabilities. In the case of `getenv()`, consider using a method that does not expose sensitive information through environment variables.\n\n## Source Code Fix Recommendation\n\nThe code fix would depend on the specific requirements of your program. If you need to use an environment variable, ensure that it is not controlled by an attacker and that it does not contain sensitive information. If possible, consider using a configuration file or command line arguments instead of environment variables.\n\n```cpp\n// Instead of using getenv(), consider using a configuration file or command line arguments\nchar* options_append = read_config(\"LOADER_OPTIONS_APPEND\");\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library for the `getenv()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3cc99c5a-c964-38ab-ab8a-bb43ac2e0515",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a high risk: the destination buffer's capacity is unknown, and the number of bytes being copied is not proven to be within the bounds of the destination. The verdict for this call site is also marked as 'GENUINE', confirming the issue. The source being copied is a C++ string's internal buffer, and the number of bytes copied is determined by the string's size. However, there is no evidence that the destination buffer is large enough to hold this data, which could lead to a buffer overflow. There are no explicit checks or guards to ensure the destination is sufficiently sized, and there is no explicit null-termination after the copy. The destination is a generic pointer, making it impossible to verify its size statically. These factors all contribute to the high risk of a buffer overflow vulnerability.\n\n## In Context Remediation\nBefore copying data from the string to the destination buffer, ensure that the destination buffer is large enough to hold the data being copied. If the size of the destination buffer is not known, you must pass the buffer size as an additional argument and check it against the size of the data to be copied. For example:\n\n```cpp\n// Assume 'value' is a pointer to a buffer and 'value_capacity' is its size in bytes\nif (module_name.size() <= value_capacity) {\n    memcpy(value, module_name.c_str(), module_name.size());\n} else {\n    // Handle error: buffer too small\n}\n```\n\nIf possible, use safer alternatives such as `memcpy_s` (where available) or C++ string methods that manage memory automatically. Always ensure that the destination buffer is properly sized and, if copying string data, consider null-terminating the destination if it is to be used as a C string.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a3b5f04b-fe2e-305e-88f0-953ec3db0b49",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is not known or checked before copying data into it. The code copies the contents of a string into a destination buffer using the size of the string as the number of bytes to copy, but there is no evidence that the destination buffer is large enough to hold this data. The source is a C-style string, which is generally safe, and there is no risk of overlapping memory regions or null pointers at this call site. However, the absence of any guard or check on the destination buffer's size, and the lack of information about how much space is available in the destination, makes this a high-risk operation that could lead to a buffer overflow. This type of issue is a common cause of security vulnerabilities in C and C++ programs.\n\n## In Context Remediation\nBefore copying data, ensure that the destination buffer is large enough to hold the source data. If the size of the destination buffer is not known, you should pass the buffer size as an additional argument and check it against the size of the data to be copied. For example:\n\n```cpp\n// Assume 'value' is a pointer to a buffer and 'value_capacity' is its size in bytes\nif (symbol_name.size() <= value_capacity) {\n    memcpy(value, symbol_name.c_str(), symbol_name.size());\n} else {\n    // Handle error: source string is too large for destination buffer\n}\n```\n\nIf you cannot guarantee the size of the destination buffer, consider using safer alternatives or redesigning the function to avoid raw memory copying.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "18c57210-1a22-38b2-bd6a-3050e2728167",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. In this case, the function `alloca()` is used, which is considered unsafe. The `alloca()` function dynamically allocates memory on the stack, which can lead to buffer overflow vulnerabilities if not properly managed. This is because the allocated memory is not initialized and can contain sensitive information. Additionally, the function does not provide any mechanism for error handling if the stack overflows.\n\n## Mitigation Advice\n\nAvoid using the `alloca()` function. Instead, use safer alternatives such as `malloc()`, `calloc()`, or `new` for dynamic memory allocation. These functions allocate memory on the heap, not the stack, and provide error handling mechanisms. Always ensure to properly manage and free dynamically allocated memory to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with a safer alternative. Here's how you can do it with `new`:\n\n```cpp\ntry {\n    sdata = new unsigned char[section->size()];\n} catch (std::bad_alloc& ba) {\n    std::cerr << \"bad_alloc caught: \" << ba.what() << '\\n';\n}\n```\n\nRemember to free the allocated memory when you're done with it:\n\n```cpp\ndelete[] sdata;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<new>`: This is required for the `new` operator and `std::bad_alloc` exception.\n- `<iostream>`: This is required for `std::cerr`.\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "40f42ee7-08cc-3cf7-8f66-31d3a865769c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `snprintf`.\n\nAdditionally, consider using higher level abstractions provided by C++ such as `std::string` or `std::vector` that manage memory automatically and are less prone to such vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative like `strncpy`. Here's how you can do it:\n\n```cpp\nstrncpy(svalue, isa.c_str(), std::min(sizeof(svalue), isa.size()));\n```\n\nIn this case, `sizeof(svalue)` ensures that we do not exceed the size of the destination buffer.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` and `strncpy` functions.\n- `<algorithm>`: This library provides the `std::min` function.\n- `<string>`: This library provides the `std::string` class.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3fd59242-3d6a-377b-8276-da5d907a2874",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the code copies data from a string object's internal buffer to a destination pointer without verifying that the destination pointer is valid (not null). The classification indicates a risk of undefined behavior due to the possibility of the destination pointer being null, and there are no visible checks in the code to prevent this. The source is a string's internal buffer, which is generally safe, but the lack of a null check on the destination pointer is a critical issue. The verdict is marked as genuine, and the risk is further supported by the analysis indicating that the destination may be null at this point in the code.\n\n## In Context Remediation\nBefore copying data to the destination buffer, ensure that the destination pointer is not null. This prevents undefined behavior and potential crashes. For example:\n\n```cpp\nif (desc->producer_options != nullptr) {\n    memcpy(desc->producer_options, options.c_str(), options.length() + 1);\n} else {\n    // Handle error: destination buffer is null\n}\n```\n\nIf the destination buffer can be allocated dynamically, consider allocating it if it is null, or returning an error if allocation is not possible. Always validate pointers before performing memory operations.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "205eac20-3a2d-3ee2-9501-64b6f5f7ec48",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict is marked as genuine. The code copies data from a string's internal buffer to a destination buffer using a memory copy operation. There is no evidence of a check to ensure that the destination pointer is not null before the copy occurs. If the destination pointer is null, this will result in undefined behavior and potentially a crash or security issue. The source is a C++ string's internal buffer, which is generally safe, but the lack of a null check on the destination is a significant risk. No guard or length check is present, and the analysis specifically notes that the destination pointer may be null. This makes the issue actionable and not a false positive.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the destination is null. For example:\n\n```cpp\nif (desc && desc->producer_name) {\n    memcpy(desc->producer_name, producer.c_str(), producer.length() + 1);\n}\n```\nThis check ensures that both the structure and the destination buffer are valid before copying. If additional error handling is needed, consider logging or returning an error code if the destination is null.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "efc27dee-cd4a-3158-a8f9-4eaa327b9851",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before the `memcpy` function is called. \n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <cstring>\n#include <algorithm>\n#include <string>\n\nvoid safe_memcpy(char* svalue, const std::string& version, size_t max_size) {\n    size_t copy_size = std::min(version.size(), max_size - 1);\n    memcpy(svalue, version.c_str(), copy_size);\n    svalue[copy_size] = '\\0'; // Ensure null termination\n}\n```\n\nIn this code, `std::min` is used to ensure that the size of the data being copied does not exceed the size of the destination buffer. The `- 1` is to leave space for the null terminator.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<algorithm>`: This library provides the `std::min` function.\n- `<string>`: This library provides the `std::string` class.\n\n## OWASP and CWE Links\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a later date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a45758a0-6539-399b-bda8-a5c5015c42ca",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict is marked as genuine. The code copies data from a C-style string into a destination buffer using a memory copy operation, but there is no evidence of checks to ensure that the destination pointer is not null. The analysis also notes that the destination pointer may be null, which could lead to a crash or other undefined behavior if the function is called with an invalid pointer. The source is a C-style string, which is generally safe, but the lack of null checks on the destination is a significant risk. There are no guards or explicit null-termination after the copy, and the length is not derived from the destination's capacity, increasing the risk of misuse.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer is not null to prevent undefined behavior. Add an explicit check for the destination pointer and handle the error appropriately if it is null. For example:\n\n```cpp\nif (desc && desc->vendor_and_architecture_name) {\n    memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length() + 1);\n} else {\n    // Handle error: destination is null\n}\n```\n\nAdditionally, consider verifying that the destination buffer is large enough to hold the copied data to prevent buffer overflows.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c543cec1-6485-3b05-81f0-be93d15624af",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code copies data from a string object's internal buffer to a destination buffer using a memory copy function, but there is no evidence of checks to ensure that the destination pointer is not null. The source is a string object's internal buffer, which is generally safe, but the destination pointer could be null, as there are no visible guards or checks before the copy operation. This can lead to undefined behavior or a crash if the destination pointer is null. The risk is further highlighted by the classification indicating undefined behavior due to possible null pointers. The probability of this being a false positive is very low, as the absence of null checks for the destination pointer is a clear and common source of vulnerabilities.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior or crashes if the destination is null. For example:\n\n```cpp\nif (desc && desc->vendor_and_architecture_name) {\n    memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length() + 1);\n}\n```\nThis check ensures that the destination structure and its buffer are valid before copying data. If the destination can be null, handle the error appropriately (e.g., return an error code or throw an exception).\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0df495ce-6024-3dc4-8617-4c1e73275c73",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is not known or proven to be sufficient for the number of bytes being copied. The code copies the contents of a string (using its size) into a destination pointer without verifying that the destination is large enough to hold the data. There are no checks or guards in place to ensure the destination buffer is adequately sized, and the classification explicitly marks this as high risk. The source is a C++ string's internal buffer, which is safe in terms of null pointers and overlap, but the main risk is a potential buffer overflow if the destination is too small. This type of issue can lead to memory corruption and security vulnerabilities.\n\n## In Context Remediation\nBefore copying data from the string to the destination buffer, ensure that the destination buffer is large enough to hold the data. If the size of the destination buffer is not known, you must pass the buffer size as an additional argument or use a safer function that takes the buffer size into account. For example, if you know the size of the destination buffer (let's say `value_size`), you can add a check:\n\n```cpp\nif (ModuleName.size() <= value_size) {\n    memcpy(value, ModuleName.c_str(), ModuleName.size());\n} else {\n    // Handle error: destination buffer too small\n}\n```\n\nAlternatively, if you want to ensure null-termination and avoid overflows, use `strncpy` or `memcpy` with the minimum of the buffer size and the string size:\n\n```cpp\nsize_t copy_len = std::min(ModuleName.size(), value_size - 1);\nmemcpy(value, ModuleName.c_str(), copy_len);\n((char*)value)[copy_len] = '\\0'; // Ensure null-termination if value is a char buffer\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "51d100a6-51b6-3350-b187-6fa737449be6",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is unknown and there is no evidence that the number of bytes being copied is within the bounds of the destination. The code copies the contents of a string (using its size) into a destination pointer without verifying that the destination is large enough to hold the data. There are no explicit checks or guards to ensure the destination buffer is sufficiently sized, and the destination type is a generic pointer, which further increases the risk. The source is a C-style string, which slightly increases the chance of a false positive, but the lack of capacity checks and the high-risk classification make this a genuine issue.\n\n## In Context Remediation\nBefore copying data from the string to the destination buffer, ensure that the destination buffer is large enough to hold the data being copied. If the size of the destination buffer is not known, it should be passed as an additional parameter or otherwise validated. For example, if you know the size of the destination buffer (let's call it `value_capacity`), you can use:\n\n```cpp\nsize_t copy_size = std::min(SymbolName.size(), value_capacity);\nmemcpy(value, SymbolName.c_str(), copy_size);\n```\n\nThis ensures that you never copy more bytes than the destination can hold, preventing buffer overflows. If possible, also ensure the buffer is null-terminated if it is used as a string.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a96fa87d-e449-31f7-a0b8-c53f17748a81",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It returns the number of characters in a string up to but not including the first null character. The vulnerability arises when the string does not have a null character, causing `strlen()` to continue reading until it finds a null character, potentially leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your string. Also, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter to specify the maximum number of characters to be read.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar str[] = \"Hello, World!\";\nint len = strlen(str);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar str[] = \"Hello, World!\";\nint len = strnlen(str, sizeof(str));\n```\n\nIn the fixed code, `strnlen()` is used instead of `strlen()`. The second parameter to `strnlen()` is the maximum number of characters that `strnlen()` will read. If `str` does not have a null character within this limit, `strnlen()` will stop reading and return the limit.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "828ce508-8e52-3f91-b456-fc33bf1263a1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It returns the number of characters in a string up to but not including the first null character. The vulnerability arises when the string does not have a null character, causing `strlen()` to continue reading until it finds a null character, potentially leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your string. Also, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter to specify the maximum number of characters to be read.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar str[] = \"Hello, World!\";\nint len = strlen(str);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar str[] = \"Hello, World!\";\nint len = strnlen(str, sizeof(str));\n```\n\nIn the fixed code, `strnlen()` is used instead of `strlen()`. The second parameter to `strnlen()` is the maximum number of characters that `strnlen()` will read. If `str` does not have a null character within this limit, `strnlen()` will stop reading and return the limit.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "2a6c7c73-5a08-374a-911b-7f1edece79fb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It returns the number of characters in a string up to but not including the first null character. The vulnerability arises when the string does not have a null character, causing `strlen()` to read past the intended memory, leading to a buffer overflow. This can result in crashes, incorrect behavior, or allow for execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that are not guaranteed to be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(pStr)` with `strnlen(pStr, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of the string.\n\n```cpp\n#include <string.h>\n\n#define MAX_LENGTH 100\n\n// ...\n\nchar *pStr = /* ... */;\nsize_t len = strnlen(pStr, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strlen()` and `strnlen()` functions are part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "0af28950-e54e-3ae3-8bdc-5bb20bc51b5d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It returns the number of characters in a string up to but not including the first null character. The vulnerability arises when the string does not have a null character, causing `strlen()` to read past the intended memory, leading to a buffer overflow. This can result in crashes, incorrect behavior, or allow for execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that are not guaranteed to be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(pStr)` with `strnlen(pStr, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of the string.\n\n```cpp\n#include <string.h>\n\n#define MAX_LENGTH 100\n\n// ...\n\nchar *pStr = /* ... */;\nsize_t len = strnlen(pStr, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strlen()` and `strnlen()` functions are part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "0ba32af8-75d6-3dfe-b5eb-b30be84d7f2b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `m_size * sizeof(T)` is larger than the size of `pData`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the provided code snippet:\n\n```cpp\nif (m_size * sizeof(T) <= sizeof(pData)) {\n    memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we check if `m_size * sizeof(T)` is larger than the size of `pData` before calling `memcpy`. If it is, we handle the error instead of causing a buffer overflow.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a later date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c6a48e48-4ca7-3808-8dba-14fb5d55fe77",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `m_size * sizeof(T)` is larger than the size of `pData`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the provided code snippet:\n\n```cpp\nif (m_size * sizeof(T) <= sizeof(pData)) {\n    memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we check if `m_size * sizeof(T)` is larger than the size of `pData` before calling `memcpy`. If it is, we handle the error instead of causing a buffer overflow.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a later date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1cf5a7a4-adb0-3ea1-919e-e6d553c2cab9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before the `memcpy` function is called. \n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nsize_t size = sizeof(T);\nif (oldSize + size > sizeof(m_pData)) {\n    // Handle error: buffer overflow\n} else {\n    memcpy(&m_pData[oldSize], pTs, size);\n}\n```\n\nIn this code, we first calculate the size of the data being copied. Then we check if adding this size to the old size of the buffer would exceed the total size of the buffer. If it would, we handle the error (for example, by throwing an exception or returning an error code). If it wouldn't, we proceed with the `memcpy` operation.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "418461b2-e047-329f-b5f6-b0b04d1ca307",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before the `memcpy` function is called. \n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nsize_t size = sizeof(T);\nif (oldSize + size > sizeof(m_pData)) {\n    // Handle error: buffer overflow\n} else {\n    memcpy(&m_pData[oldSize], pTs, size);\n}\n```\n\nIn this code, we first calculate the size of the data being copied. Then we check if adding this size to the old size of the buffer would exceed the total size of the buffer. If it would, we handle the error (for example, by throwing an exception or returning an error code). If it wouldn't, we proceed with the `memcpy` operation.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1a65832e-c273-37eb-b2bd-29496d7b1319",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null byte.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null byte at the end, or by manually adding a null byte after the last character of the string.\n\n## Source Code Fix Recommendation\n\nIf `pString` is a character array, you can ensure it is null-terminated by initializing it with a null byte:\n\n```cpp\nchar pString[] = \"Hello, world!\";\n```\n\nIf `pString` is a pointer to a string, you can add a null byte at the end:\n\n```cpp\nchar* pString = new char[14];\nstrcpy(pString, \"Hello, world!\");\npString[13] = '\\0';\n```\n\nIn both cases, `strlen(pString)` will now correctly return 13.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "d3b1d17e-a6ed-3b44-94e9-93704904996a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null byte.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null byte at the end, or by manually adding a null byte after the last character of the string.\n\n## Source Code Fix Recommendation\n\nIf `pKey` is a string that may not be null-terminated, you can ensure it is null-terminated before passing it to `strlen()`:\n\n```cpp\nsize_t len;\nif (pKey) {\n    pKey[strlen(pKey)] = '\\0';\n    len = strlen(pKey);\n}\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "0ed4f90f-5c05-3493-b522-ffa726cc6432",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination memory regions may overlap. This is indicated by the analysis, which detected a data flow from the destination to the source, suggesting that the same memory area could be referenced by both. Using a standard memory copy function in such cases leads to undefined behavior, which can cause unpredictable program behavior or security vulnerabilities. There are no explicit checks or guards in the code to prevent this overlap, and the function verdict confirms the issue as genuine. The source and destination are both non-null at the call site, so the main risk is the potential for overlapping memory regions.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C/C++, use `memmove` instead of `memcpy` for such cases. `memmove` is designed to correctly handle overlapping memory areas.\n\n**Remediation Example:**\n\n```cpp\nmemmove((char *) dst + offset, src, size);\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "044ef33d-c15d-3959-8a32-dcd697ea1899",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will keep reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or even code execution if an attacker can control the overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings, and consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read beyond this length.\n\n## Source Code Fix Recommendation\n\nIf `m_data` is a char array, you should ensure it is null-terminated. If it is not guaranteed to be null-terminated, you should use `strnlen()` instead of `strlen()`. Here is an example:\n\n```cpp\n#include <cstring> // for strnlen\n\nconst size_t MAX_LENGTH = 100; // replace with your maximum length\nsize_t length = strnlen(m_data, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so you need to include `<cstring>` or `<string.h>`.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "3c199c27-0ee1-38f1-8fbe-93c048fec2c4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable program behavior, data corruption, or crashes. The verdict is supported by the classification and the explicit 'GENUINE' verdict. There are no guards ensuring non-overlap, and the types and expressions involved do not provide evidence of safety. Both the source and destination are confirmed to be non-null, but the overlap risk remains the primary concern.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely.\n\n```cpp\nmemmove(buf, buffer, bufferSize);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a8b62123-502e-32e3-8557-585aa866e46b",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable program behavior or data corruption. The verdict is supported by the classification and the high-confidence 'GENUINE' label. There are no explicit checks or guards to prevent this overlap, and neither the source nor the destination is null at the call site, which means the operation will proceed and may trigger undefined behavior if overlap occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(*buf, buffer, bufferSize);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination memory regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "acf2911c-0eb8-3ceb-96df-be78cb82d49c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, the source pointer may be null, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly defined, increasing the risk. Developers should address both the potential for overlapping memory regions and the possibility of null pointers to ensure safe and predictable behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy. For example:\n\n```cpp\nif (dest != nullptr && edata->d_buf != nullptr) {\n    memmove(dest, (const char*) edata->d_buf + offset - coffset, csize);\n}\n```\nThis change ensures that the copy operation is safe even if the memory regions overlap and avoids dereferencing null pointers.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "673c5931-33c5-3ff4-b6a9-94c2d3e542ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null byte.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null byte at the end, or by manually adding a null byte after the last character of the string.\n\n## Source Code Fix Recommendation\n\nIf `pString` is a character array, you can ensure it is null-terminated by initializing it with a null byte:\n\n```cpp\nchar pString[] = \"Hello, world!\";\n```\n\nIf `pString` is a pointer to a string, you can add a null byte at the end:\n\n```cpp\nchar* pString = new char[14];\nstrcpy(pString, \"Hello, world!\");\npString[13] = '\\0';\n```\n\nIn both cases, `strlen(pString)` will now correctly return 13.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "f02ecc06-d5b0-30ac-b862-b3b3f272cb81",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` or `strerror_s()`. Also, consider using exception handling for error reporting instead of directly writing error messages to the output.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nchar buf[1024];\nif(strerror_r(errno, buf, sizeof(buf)) == 0) {\n    out << \"Error: \" << msg << \": \" << buf << std::endl;\n} else {\n    out << \"Error: \" << msg << std::endl;\n}\n```\n\n## Library Dependencies\n\n- `<string.h>`: This header file contains declaration of various string handling functions including `strerror_r()`.\n- `<errno.h>`: This header file defines macros for reporting error conditions.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e1cc7dae-ac8b-397e-be05-7c8041eeda58",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to calculate the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue to read memory until it encounters a null character, which can lead to buffer over-read, causing undefined behavior, crashes, or potential information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, use safer string handling functions that include length checks, such as `strnlen`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` function:\n\n```cpp\nsize_t length = strnlen(MetroHash64::test_string, MAX_LENGTH);\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash64::test_string), length);\n```\n\nIn the above code, `MAX_LENGTH` should be the maximum length of `MetroHash64::test_string` that you expect. This will prevent `strnlen` from reading beyond the expected length of the string.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `MetroHash`: A library for non-cryptographic hash functions.\n- `cstring`: A standard C++ library for string handling functions.\n\n## References\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "8634c293-c881-305e-bae8-b0b20d9c8362",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination is a pointer to an 8-bit unsigned integer, and the source is the address of a hash variable. The analysis determined, through data flow, that the destination and source may overlap, which can cause undefined behavior with memcpy. Additionally, the source may be null at this call site, which further increases the risk. There are no explicit checks or guards to prevent these issues, and the function does not ensure that the source and destination are distinct or non-null. This combination of factors makes the finding a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For the code in question, replace the memory copy operation with `memmove`:\n\n```cpp\nmemmove(out, &hash, 8);\n```\n\nAdditionally, if there is a risk that the source pointer could be null, add a check before performing the copy:\n\n```cpp\nif (out != nullptr && &hash != nullptr) {\n    memmove(out, &hash, 8);\n}\n```\n\nThis ensures that the operation is safe and avoids undefined behavior due to overlapping memory or null pointers.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "315ff47c-2d51-3899-88f5-e37d899a072d",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source may overlap based on data flow, which can cause undefined behavior with memcpy. Additionally, the source pointer may be null, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not explicitly known. These factors all contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping regions safely. Replace the original call with:\n\n```cpp\nmemmove(out, &hash, 8);\n```\n\nAdditionally, ensure that both `out` and `&hash` are valid pointers and that the destination buffer is large enough to hold 8 bytes. If there is any chance that the source pointer could be null, add a check before the call:\n\n```cpp\nif (out != nullptr && &hash != nullptr) {\n    memmove(out, &hash, 8);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bc614cf3-a22b-368c-a46e-2ace8fae15ee",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to calculate the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue to read memory until it encounters a null character, which can lead to buffer over-read, causing undefined behavior, crashes, or potential information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, use safer string handling functions that include length checks, such as `strnlen`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` function:\n\n```cpp\nsize_t length = strnlen(MetroHash64::test_string, MAX_LENGTH);\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash64::test_string), length);\n```\n\nIn the above code, `MAX_LENGTH` should be the maximum length of `MetroHash64::test_string` that you expect. This will prevent `strnlen` from reading beyond the expected length of the string.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `MetroHash`: A library for non-cryptographic hash functions.\n- `cstring`: A standard C++ library for string handling functions.\n\n## References\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "a5cbdfa6-c2ee-3acf-aa92-d43863f3fe00",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `strlen` function is used on `MetroHash64::test_string`. To fix the vulnerability, you should ensure that `test_string` is null-terminated. Here is a possible fix:\n\n```cpp\nconst char* test_string = \"your_string_here\";\nsize_t length = strlen(test_string);\nif (test_string[length] != '\\0') {\n    test_string[length] = '\\0';\n}\nMetroHash64::Hash(key, strlen(MetroHash64::test_string), hash, 1);\n```\n\n## Library Dependencies\n\nThe code snippet provided seems to be using the MetroHash library. Therefore, the MetroHash library is a dependency for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "e95eec92-2183-305d-ac17-bbb7fa568a1d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. This is because `strlen` does not check for null termination and will continue reading memory until it encounters a null byte. If the string is not null-terminated, `strlen` can read past the end of the buffer, leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` such as `strnlen` which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the vulnerability can be fixed by ensuring that `MetroHash64::test_string` is null-terminated before passing it to `strlen`. If `MetroHash64::test_string` is a `std::string`, you can use its `length` or `size` member function instead of `strlen`.\n\n```cpp\nMetroHash64::Hash(key, MetroHash64::test_string.length(), hash, 0)\n```\n\n## Library Dependencies\n\nThe code snippet appears to depend on the MetroHash library. Ensure that this library is properly installed and included in your project.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "b3caeb58-51a2-3ad0-9415-1101e9abd166",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination is a pointer, and the source is an address of a variable, with dataflow analysis indicating that the destination may alias the source. Additionally, the analysis could not rule out the possibility that the source pointer is null, which further increases the risk. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue that could lead to unpredictable program behavior or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior caused by overlapping memory regions, ensure that the source and destination buffers do not overlap before calling the memory copy function. If there is any possibility of overlap, use a function that safely handles overlapping regions, such as `memmove`, instead of `memcpy`. For example, replace the original call with:\n\n```cpp\nmemmove(hash, &h, 8);\n```\n\nAdditionally, verify that the source pointer is not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (&h != nullptr) {\n    memmove(hash, &h, 8);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0ab9d556-cc0f-3191-8c2b-feddec41ca30",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the destination pointer could be null, as there is no clear guard ensuring it is valid before the operation. The source pointer is guarded and cannot be null, but the combination of possible overlap and a potentially null destination makes this a high-confidence, actionable issue. The operation uses a calculated size for the copy, but without explicit checks or guarantees about the relationship between the source and destination, undefined behavior is possible.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(input.b, ptr, static_cast<size_t>(end - ptr));\n```\n\nAdditionally, ensure that both the source (`ptr`) and destination (`input.b`) pointers are valid and not null before performing the operation. For example:\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    memmove(input.b, ptr, static_cast<size_t>(end - ptr));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d6b9c6ca-3a0e-3340-9bf8-207aad9a3c54",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is no evidence that the source pointer is guaranteed to be non-null, which further increases the risk of undefined behavior. The destination is a pointer type, and there is no information about its capacity or bounds checking. These factors together indicate a real risk of memory corruption or program instability if the overlap occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to safely handle overlapping memory regions.\n\n```cpp\nmemmove(hash, state.v, 8);\n```\n\nAdditionally, ensure that both `hash` and `state.v` are not null before performing the operation to avoid null pointer dereference:\n\n```cpp\nif (hash != nullptr && state.v != nullptr) {\n    memmove(hash, state.v, 8);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4dfdc83a-3253-34df-8890-f2c5221469ab",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination pointers are non-null, increasing the risk of null pointer dereference. The absence of explicit bounds checks or guards further increases the likelihood of a real issue. The verdict is supported by the classification indicating undefined behavior risk and the automated assessment marking this as a genuine finding.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation. For example:\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    // Use memmove if overlap is possible\n    memmove(input.b + (bytes % 32), ptr, static_cast<size_t>(fill));\n}\n```\n\nThis change ensures safe copying even if the memory regions overlap and prevents null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f1571809-9fbb-38f2-b96e-861e18fffc55",
              "help": {
                "text": "",
                "markdown": "## Description\n\nStoring sensitive information such as tokens, keys, or passwords in source code is a security vulnerability. This is because the source code can be easily accessed by unauthorized users, who can then use this sensitive information for malicious purposes. In C++ programming, this vulnerability can occur when developers hard-code sensitive information directly into their source code.\n\nIn the provided code snippet, a string is being stored directly in the source code. If this string was a sensitive token or key, it would be exposed to anyone who has access to the source code.\n\n## Mitigation Advice\n\nAvoid storing sensitive information directly in the source code. Instead, use secure methods to store and retrieve this information, such as environment variables, secure server, or encrypted database. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the string directly in the source code, you could store it in an environment variable and then retrieve it in your code. Here's how you could do it:\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* value = std::getenv(\"TEST_STRING\");\nif (value != nullptr) {\n    MetroHash64::test_string = value;\n}\n```\n\nIn this code, `std::getenv` is used to retrieve the value of an environment variable named `TEST_STRING`. This value is then assigned to `MetroHash64::test_string`.\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library to use the `std::getenv` function.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS173237"
                ]
              }
            },
            {
              "id": "af6fbe1e-3001-39b4-a16c-f6a9ee976893",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null byte.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null byte at the end, or by manually adding a null byte after the last character of the string.\n\n## Source Code Fix Recommendation\n\nIf `pKey` is a string that may not be null-terminated, you can ensure it is null-terminated before passing it to `strlen()`:\n\n```cpp\nsize_t len;\nif (pKey) {\n    pKey[strlen(pKey)] = '\\0';\n    len = strlen(pKey);\n}\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "3a5c9724-6122-325f-881c-9e98de8e1d78",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will keep reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or even code execution if an attacker can control the overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings, and consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read beyond this length.\n\n## Source Code Fix Recommendation\n\nIf `m_data` is a char array, you should ensure it is null-terminated. If it is not guaranteed to be null-terminated, you should use `strnlen()` instead of `strlen()`. Here is an example:\n\n```cpp\n#include <cstring> // for strnlen\n\nconst size_t MAX_LENGTH = 100; // replace with your maximum length\nsize_t length = strnlen(m_data, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so you need to include `<cstring>` or `<string.h>`.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "6561899d-4e18-3c17-b2a1-0d61d2edef2b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Storing Tokens or Keys in Source Code Vulnerability\" is a security flaw that occurs when sensitive data such as API keys, tokens, or passwords are hard-coded into the source code. This is a bad practice because if the source code is ever exposed, the sensitive data will also be exposed. This could lead to unauthorized access or other security breaches.\n\nIn the given code snippet, the key `test_key_63` is hard-coded into the source code, which is a security vulnerability.\n\n```cpp\ntest_key_63 = \"012345678901234567890123456789012345678901234567890123456789012\";\n```\n\n## Mitigation Advice\n\nAvoid hard-coding sensitive data into your source code. Instead, use secure methods to store and retrieve these data, such as environment variables, secure server, or encrypted database. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the key into the source code, you can store it in an environment variable and retrieve it when needed. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for getenv\n\nconst char* test_key_63 = std::getenv(\"TEST_KEY_63\");\nif (!test_key_63) {\n    // handle error: environment variable TEST_KEY_63 is not defined\n}\n```\n\nIn this code, `std::getenv` is a function from the `cstdlib` library that retrieves the value of the environment variable. If the environment variable is not defined, it returns a null pointer.\n\n## Library Dependencies\n\nThe `cstdlib` library is required by the code example to execute properly.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS117838"
                ]
              }
            },
            {
              "id": "0782a094-36ba-3a80-adeb-8c51826dd641",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions during the memory copy operation. The analysis detected that the source and destination may refer to overlapping memory areas, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, there is a risk that the source pointer may be null at this point, as there is no prior check ensuring it is valid. The destination pointer is less likely to be null, but the main concern is the potential for overlapping memory regions and undefined behavior. No explicit bounds or guards are present to mitigate these risks.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as memmove. Additionally, ensure that both the source and destination pointers are not null before performing the operation. For example:\n\n```cpp\nif (out != nullptr && v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\nThis change ensures that the copy is safe even if the memory regions overlap, and avoids dereferencing null pointers. \n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "607854de-c3bf-3114-a1b6-b68d6df458e5",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The destination is unlikely to be null, but the source may be, and there is no explicit check to prevent this. The use of a fixed length (16 bytes) does not mitigate the risk of overlap or null pointer dereference. This combination of factors makes the issue actionable and not a false positive.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the memory areas overlap.\n\n```cpp\nmemmove(out, v, 16);\n```\n\nAdditionally, consider adding explicit null pointer checks for the source pointer before performing the copy to avoid potential null dereference:\n\n```cpp\nif (v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8f681894-d137-3347-8da1-e460ff5050e4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, which can lead to buffer over-read, and in some cases, can cause a segmentation fault or other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, you can use safer string handling functions that include length parameters, such as `strnlen`, which takes an additional parameter specifying the maximum number of bytes to read.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you can replace `strlen` with `strnlen` and add a maximum length parameter. Here's how you can do it:\n\n```cpp\nconst size_t max_length = 128; // Define a maximum length according to your needs\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash128::test_string), strnlen(MetroHash128::test_string, max_length))\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the MetroHash library, which provides the `MetroHash128` class and the `Update` method. The `strlen` function is part of the standard C library, which is typically included with any C++ compiler.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "36d75394-86a7-39cb-b1ac-7a5b4d317783",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis indicates that they may refer to overlapping memory. Additionally, there is no evidence of a guard or check to prevent this overlap. The source pointer may also be null at this point, which further increases the risk of undefined behavior. These factors make this a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the source and destination overlap.\n\n```cpp\n// Replace memcpy with memmove to handle possible overlap safely\nmemmove(out, v, 16);\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the copy:\n\n```cpp\nif (out != nullptr && v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "554de136-ebc2-3a03-971c-3a11489ddf1f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The operation copies a fixed number of bytes (16), but without explicit checks or guarantees about the relationship between the source and destination, this can lead to unpredictable results or crashes. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination safely. Replace the original call with:\n\n```cpp\nmemmove(out, v, 16);\n```\n\nAdditionally, ensure that both `out` and `v` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (out != nullptr && v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "36120805-5a7e-30e0-941c-635ce6a4047b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, which can lead to buffer over-read, and in some cases, can cause a segmentation fault or other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, you can use safer string handling functions that include length parameters, such as `strnlen`, which takes an additional parameter specifying the maximum number of bytes to read.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you can replace `strlen` with `strnlen` and add a maximum length parameter. Here's how you can do it:\n\n```cpp\nconst size_t max_length = 128; // Define a maximum length according to your needs\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash128::test_string), strnlen(MetroHash128::test_string, max_length))\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the MetroHash library, which provides the `MetroHash128` class and the `Update` method. The `strlen` function is part of the standard C library, which is typically included with any C++ compiler.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "a86525c7-6792-3940-b465-1dadc3d9c487",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `strlen` function is used to determine the length of `MetroHash128::test_string`. To fix the vulnerability, you should ensure that `MetroHash128::test_string` is null-terminated. This can be done by adding a null character to the end of the string when it is initialized.\n\n```cpp\n// Ensure that MetroHash128::test_string is null-terminated\nchar MetroHash128::test_string[] = \"test string\\0\";\n\n// Now it's safe to use strlen\nMetroHash128::Hash(key, strlen(MetroHash128::test_string), hash, 1);\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to depend on the MetroHash library, which provides the `MetroHash128` class and its associated `Hash` function. The `strlen` function is part of the standard C library, which is included by default in most C++ environments.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the provided links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "54616ee2-74aa-3709-b44a-7eb11251f0a8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated, which can lead to buffer overflows, memory corruption, and other unexpected behavior. This is because `strlen` counts characters until it encounters a null character, and if there is no null character, it will continue reading memory beyond the intended boundary.\n\nIn the provided code snippet, the `strlen` function is used to determine the length of `MetroHash128::test_string`. If `MetroHash128::test_string` is not null-terminated, this could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\nAdditionally, consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read beyond this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t length = strlen(MetroHash128::test_string);\nif (length > MAX_LENGTH) {\n    length = MAX_LENGTH;\n}\nMetroHash128::Hash(key, length, hash, 0);\n```\n\nIn this fix, `strnlen` is used instead of `strlen`, and a maximum length (`MAX_LENGTH`) is specified to prevent buffer overflows.\n\n## Library Dependencies\n\nThe provided code snippet appears to be using the MetroHash library. Therefore, the MetroHash library would be a required dependency for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "1e3d181f-6bf0-3a4b-862e-8a52e7a5ad0b",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may refer to overlapping memory areas, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there is no evidence of a guard ensuring the source is non-null, increasing the risk of a null pointer dereference. The destination is not likely to be null, but the source may be. The use of a fixed count (16 bytes) does not mitigate the overlap risk. These factors together confirm the issue is real and actionable.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory regions safely. Replace the original call with:\n\n```cpp\nmemmove(hash, v, 16);\n```\n\nAdditionally, ensure that the source pointer `v` is not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (v != nullptr) {\n    memmove(hash, v, 16);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "de28de6a-f5c4-382a-9fc4-edc0b041f1b1",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence that the source pointer is guaranteed to be non-null, which further increases the risk of undefined behavior. The destination buffer is a pointer type, and there is no information about its capacity or any guard conditions that would mitigate the risk. The use of a fixed length (16 bytes) does not guarantee safety if the regions overlap. This combination of factors makes the issue actionable and not a false positive.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(hash, state.v, 16);\n```\n\nAdditionally, ensure that both `hash` and `state.v` are valid pointers and that the regions are at least 16 bytes in size to avoid buffer overflows or null pointer dereferences.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c7b55bf0-4571-3b9f-9a4c-5cc28ea61be0",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. This can lead to unpredictable program behavior, data corruption, or crashes. Additionally, there is no evidence of a guard to ensure the destination pointer is not null, which further increases the risk. The source pointer is confirmed to be non-null before the call, but the destination may be null, compounding the potential for undefined behavior. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(input.b, ptr, end - ptr);\n```\n\nAdditionally, ensure that both the source (`ptr`) and destination (`input.b`) pointers are valid and not null before performing the operation. You can add explicit checks before the call:\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    memmove(input.b, ptr, end - ptr);\n}\n```\n\nThis change eliminates the risk of undefined behavior due to overlapping memory and null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ae6d8892-2aa1-3014-83aa-8496525cdb83",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there are no explicit checks to ensure that the source and destination are non-null, which increases the risk of null pointer dereference. The absence of bounds checks or guards further increases the likelihood of a real issue. The classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation.\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    memmove(input.b + (bytes % 32), ptr, static_cast<size_t>(fill));\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds null pointer checks to prevent undefined behavior and potential crashes.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "775d7b6a-77db-323b-908d-f2fda678fda8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Avoid Storing Tokens or Keys in Source Code Vulnerability\" is a common security vulnerability in C++ programming language where sensitive data such as tokens, keys, or passwords are hard-coded directly into the source code. This is a bad practice as it exposes sensitive data to anyone who has access to the source code. If the source code is ever compromised, the attacker would have direct access to these sensitive data, which could lead to serious security breaches.\n\n## Mitigation Advice\n\nThe best way to mitigate this vulnerability is to avoid hard-coding sensitive data directly into the source code. Instead, these data should be stored in a secure location such as environment variables, secure server, or using secure APIs provided by the operating system. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the test string directly into the source code, you can store it in an environment variable and then access it from your code. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* test_string = std::getenv(\"TEST_STRING\");\nif (!test_string) {\n    // handle error\n}\nMetroHash128::test_string = test_string;\n```\n\nIn this code, `std::getenv` is used to get the value of the environment variable `TEST_STRING`. If the environment variable is not set, `std::getenv` returns a null pointer.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This is a standard library in C++ for general purpose functions, including environment variables handling.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS173237"
                ]
              }
            },
            {
              "id": "81677694-58e8-3e4b-87cf-b1bdcb899d6d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators to generate values that are intended to be unpredictable. This can lead to a variety of security issues, as attackers may be able to predict the generated values and exploit this predictability.\n\nWeak random number generators can lead to predictable patterns, which can be exploited by attackers. For example, if a weak random number generator is used to generate session IDs, an attacker might be able to predict future session IDs and hijack user sessions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using the `<random>` library, which provides a variety of random number generators that are suitable for generating unpredictable values.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in a secure manner:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    for (int n=0; n<10; ++n)\n        // Use distrib to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << distrib(gen) << ' ';\n    std::cout << '\\n';\n}\n```\n\nIn this example, `std::random_device` is used to generate a seed for the Mersenne Twister random number engine (`std::mt19937`). The `std::uniform_int_distribution` is then used to transform the random unsigned int generated by `gen` into an int in the range [1, 6].\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "efd34705-397d-3edb-a540-a263b04c6e50",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. The `qsort` function is one such function that can lead to this vulnerability. It is a standard library function in C that performs a quicksort on an array. However, it can be misused in a way that leads to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `qsort` function. In C++, the `std::sort` function from the `<algorithm>` library is a safer and more efficient alternative. It is type-safe and does not require a comparison function as a parameter, reducing the risk of misuse.\n\n## Source Code Fix Recommendation\n\nReplace the `qsort` function with the `std::sort` function. Here is an example of how to do this:\n\n```cpp\n#include <algorithm>\n#include <vector>\n\n// Old code using qsort\n// int compare(const void* a, const void* b);\n// qsort(array, size, sizeof(int), compare);\n\n// New code using std::sort\nstd::vector<int> vec = { /* your data */ };\nstd::sort(vec.begin(), vec.end());\n```\n\n## Library Dependencies\n\nThe `std::sort` function requires the `<algorithm>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3f28809a-59d9-3416-af4f-45d3bbc8c282",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "dcc69853-8cd0-3e6a-86b1-1a1d27eba18d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bd2497c8-124c-3e6a-8b8e-13f08d345f78",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `mbstowcs` function in C++ is used to convert a multibyte string to a wide character string. However, it can lead to vulnerabilities if not used properly. The function does not perform any bounds checking on the destination buffer, which can lead to buffer overflow if the source string is longer than the destination buffer. This can lead to arbitrary code execution or denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the converted string, including the null terminator. You should also consider using safer alternatives that perform bounds checking, such as `mbstowcs_s` or `mbsrtowcs`.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use `mbstowcs_s` to safely convert a multibyte string to a wide character string:\n\n```cpp\n#include <locale.h>\n#include <wchar.h>\n#include <stdlib.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.utf8\");\n    const char* mbstr = \"multibyte string\";\n    size_t len = mbstowcs(NULL, mbstr, 0) + 1;\n    wchar_t* wcstr = new wchar_t[len];\n    size_t converted;\n    mbstowcs_s(&converted, wcstr, len, mbstr, _TRUNCATE);\n    // use wcstr\n    delete[] wcstr;\n    return 0;\n}\n```\n\nIn this example, `mbstowcs` is first used to calculate the length of the converted string, then `mbstowcs_s` is used to perform the conversion. The `_TRUNCATE` option ensures that the conversion is safely truncated if the source string is too long.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- locale.h\n- wchar.h\n- stdlib.h\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0dc0d5d1-db82-34b6-85c7-94baee06983c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nIf `pStrValue` is a pointer to a string, ensure it is null-terminated before passing it to `strlen()`. If the length of the string is known at compile time, consider using `strnlen()` instead.\n\n```cpp\n// Ensure pStrValue is null-terminated\nif (pStrValue != nullptr) {\n    size_t len = strnlen(pStrValue, MAX_LENGTH);\n}\n```\n\nIn this example, `MAX_LENGTH` should be replaced with the maximum expected length of the string. If the string is longer than `MAX_LENGTH`, `strnlen()` will return `MAX_LENGTH`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "18b7a1ef-9e54-3560-8965-a7c274267012",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function in question is `atof`.\n\nThe `atof` function converts a string to a double. It does not check for overflow or underflow, and it does not report any errors. This can lead to unexpected behavior if the string cannot be represented as a double.\n\n## Mitigation Advice\n\nAvoid using the `atof` function. Instead, use safer alternatives such as `strtod` or `sscanf`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atof` function with `strtod` or `sscanf`. Here is an example of how to use `strtod`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char* str = \"123.45\";\nchar* endptr;\nerrno = 0; // To distinguish success/failure after call\ndouble val = strtod(str, &endptr);\n\n// Check for various possible errors\nif ((errno == ERANGE && (val == HUGE_VALF || val == HUGE_VALL)) || (errno != 0 && val == 0)) {\n    perror(\"strtod\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == str) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\n// If we got here, strtod() successfully parsed a number\nprintf(\"strtod() returned %f\\n\", val);\n\nif (*endptr != '\\0') // Not necessarily an error...\n    printf(\"Further characters after number: %s\\n\", endptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- cerrno\n- cstdio\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cfcb1335-dd49-35c3-84e0-94d60d82a839",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5cb85615-ab6a-31d9-8e2c-757b29c46957",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It returns the number of characters in a string up to but not including the first null character. The vulnerability arises when the string does not have a null character, causing `strlen()` to read beyond the intended memory, leading to a buffer overflow. This can result in crashes, incorrect behavior, or allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that are not guaranteed to be null-terminated. Instead, use safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(pDst)` with `strnlen(pDst, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of the string.\n\n```cpp\n#include <string.h>\n\n#define MAX_LENGTH 100\n\n// ...\n\nsize_t length = strnlen(pDst, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strnlen()` function is part of the `<string.h>` library in C++.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "46e2d68e-426a-3048-b85e-f01421e9076d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncat` function in C++ is considered unsafe because it can lead to buffer overflow vulnerabilities. This function appends the source string to the destination string up to n characters. If the size of the destination buffer is not properly managed, it can lead to buffer overflow, which can cause the program to crash or lead to code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that are available in C++. For example, you can use the `strlcat` function which is designed to be safer, or you can use the string class in C++ which automatically manages the memory.\n\n## Source Code Fix Recommendation\n\nReplace the `strncat` function with `strlcat` function or use C++ string class.\n\n```cpp\n// Using strlcat\nsize_t sizeDst = sizeof(pDst);\nsize_t dstLength = strnlen(pDst, sizeDst);\nif (dstLength == sizeDst) {\n    // Handle error: pDst was not null-terminated.\n} else if (strlcat(pDst, pSrc, sizeDst) >= sizeDst) {\n    // Handle error: pDst is not large enough.\n}\n\n// Using C++ string class\nstd::string dst(pDst);\nstd::string src(pSrc);\ndst += src;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstring` or `string.h` for `strncat` and `strlcat` functions.\n- `string` for C++ string class.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "d479c29b-2771-3785-86f1-1eafd827d1ed",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. One such function is `wcsncat`.\n\nThe `wcsncat` function is a wide-character string function that appends not more than `n` wide-characters from a source string to the end of a destination string. The vulnerability arises when the size of the destination buffer is not properly managed, leading to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `wcsncat` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that include bounds checking such as `wcsncat_s` (in the case of Microsoft's implementation of C++), or use C++ strings (`std::wstring`) which are safer and easier to use.\n\n## Source Code Fix Recommendation\n\nInstead of using `wcsncat`, use `std::wstring`:\n\n```cpp\n#include <string>\n\nint main() {\n    std::wstring str1 = L\"Hello, \";\n    std::wstring str2 = L\"World!\";\n    str1 += str2; // This is safe\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b3b94754-8355-30fa-ae1f-1cfdf721771d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4517ca83-ccfb-3f9d-9aa7-02b562597bfd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcsncpy` function is one of these prohibited functions. It is used to copy a certain number of characters from one wide string to another. However, if the source string length is less than the number of characters to be copied, `wcsncpy` does not null-terminate the destination string, which can lead to buffer overflows.\n\n## Mitigation Advice\n\nAvoid using `wcsncpy` and other prohibited C functions. Instead, use safer alternatives that do not have these vulnerabilities. For example, consider using `wcsncpy_s` or `wmemcpy_s` which are safer as they null-terminate the destination string.\n\n## Source Code Fix Recommendation\n\nReplace `wcsncpy` with `wcsncpy_s` or `wmemcpy_s`. Here is an example:\n\n```cpp\n// Old vulnerable code\nwchar_t dest[100];\nwcsncpy(dest, src, 100);\n\n// Fixed code using wcsncpy_s\nwchar_t dest[100];\nwcsncpy_s(dest, 100, src, _TRUNCATE);\n\n// Or using wmemcpy_s\nwchar_t dest[100];\nwmemcpy_s(dest, 100, src, wcsnlen(src, 100));\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <wchar.h>\n```\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7e61ac96-db2d-3e4d-aedd-fd3edffa3fcb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It takes a string as an argument and returns its length. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be read.\n\n## Source Code Fix Recommendation\n\nIf `pSrc` is the string being passed to `strlen()`, ensure it is null-terminated:\n\n```cpp\nchar pSrc[] = \"Hello, World!\";\nsize_t len = strlen(pSrc);\n```\n\nOr use `strnlen()` instead:\n\n```cpp\nchar pSrc[] = \"Hello, World!\";\nsize_t len = strnlen(pSrc, sizeof(pSrc));\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "a07e0391-1fc1-3da9-bbdb-bc6c30f91d8c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflows. This function copies a string from one location to another, but it does not automatically append a null character at the end of the string. If the source string is longer than the destination buffer, this can lead to buffer overflow, which can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source string and the null character. You should also consider using safer string handling functions that automatically handle null termination, such as `strlcpy` or `strncpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `strncpy_s`:\n\n```cpp\n// Using strlcpy\nstrlcpy(pDst, pSrc, dstSize);\n\n// Using strncpy_s\nstrncpy_s(pDst, dstSize, pSrc, _TRUNCATE);\n```\n\nNote: `strlcpy` and `strncpy_s` are not standard C++ functions and may not be available on all platforms. If they are not available, you can manually ensure null termination:\n\n```cpp\nstrncpy(pDst, pSrc, dstSize - 1);\npDst[dstSize - 1] = '\\0';\n```\n\n## Library Dependencies\n\nThe `strncpy`, `strlcpy`, and `strncpy_s` functions are part of the C standard library, so you need to include the `cstring` or `string.h` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "bd5d3a33-72bb-3290-b3ab-c7943d24f9ff",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. In this case, the function `alloca()` is used, which is considered unsafe. The `alloca()` function dynamically allocates memory on the stack, which can lead to buffer overflow vulnerabilities if not properly managed. This is because the allocated memory is not initialized and can contain sensitive information. Additionally, the function does not provide any mechanism for error handling if the stack overflows.\n\n## Mitigation Advice\n\nAvoid using the `alloca()` function. Instead, use safer alternatives such as `malloc()`, `calloc()`, or `new` for dynamic memory allocation. These functions allocate memory on the heap, not the stack, and provide error handling mechanisms. Always ensure to properly manage and free dynamically allocated memory to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with a safer alternative. Here's how you can do it with `new`:\n\n```cpp\ntry {\n    sdata = new unsigned char[section->size()];\n} catch (std::bad_alloc& ba) {\n    std::cerr << \"bad_alloc caught: \" << ba.what() << '\\n';\n}\n```\n\nRemember to free the allocated memory when you're done with it:\n\n```cpp\ndelete[] sdata;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<new>`: This is required for the `new` operator and `std::bad_alloc` exception.\n- `<iostream>`: This is required for `std::cerr`.\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3feca8a5-d11f-3fc2-822b-b243311c1ca8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `snprintf`.\n\nAdditionally, consider using higher level abstractions provided by C++ such as `std::string` or `std::vector` that manage memory automatically and are less prone to such vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative like `strncpy`. Here's how you can do it:\n\n```cpp\nstrncpy(svalue, isa.c_str(), std::min(sizeof(svalue), isa.size()));\n```\n\nIn this case, `sizeof(svalue)` ensures that we do not exceed the size of the destination buffer.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` and `strncpy` functions.\n- `<algorithm>`: This library provides the `std::min` function.\n- `<string>`: This library provides the `std::string` class.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bb2bf0fb-3cb1-3433-bebf-3237240042f6",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that either the source or destination pointer may be null. The code copies data from a string object's internal buffer to a destination pointer, but there is no evidence of a check to ensure that the destination pointer is valid (not null) before the copy occurs. The source is a string's internal buffer, which is generally safe, but the destination pointer could be null, leading to a crash or undefined behavior. The absence of a guard or validation for the destination pointer increases the risk. The probability of this being a false positive is very low, as the analysis specifically points out the lack of null checks for the destination pointer.\n\n## In Context Remediation\nBefore copying data to the destination buffer, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the pointer is invalid. For example:\n\n```cpp\nif (desc->producer_options != nullptr) {\n    memcpy(desc->producer_options, options.c_str(), options.length() + 1);\n} else {\n    // Handle error: destination buffer is null\n}\n```\nThis prevents undefined behavior by ensuring the destination pointer is valid before performing the memory copy. Always validate pointers before use to avoid crashes or security vulnerabilities.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f023fa97-adeb-35a3-a647-670a919f583c",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict is marked as genuine. The code copies data from a C++ string's internal buffer to a destination buffer using a memory copy operation. There is no evidence of a check to ensure that the destination pointer is not null before the copy occurs. The analysis also notes that the destination pointer may be null, which could lead to a crash or undefined behavior if the function is called with an uninitialized or invalid pointer. The source is a C++ string's c_str(), which is generally safe, but the lack of a null check on the destination is a significant risk. No guard or explicit null check is present, and the destination's capacity is not verified, increasing the risk of a security issue.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer is not null. Add a check to verify that the destination buffer is valid. If the pointer can be null, handle the error appropriately (e.g., return an error code, throw an exception, or log the issue).\n\n```cpp\nif (desc && desc->producer_name) {\n    memcpy(desc->producer_name, producer.c_str(), producer.length() + 1);\n} else {\n    // Handle error: destination is null\n}\n```\n\nAdditionally, consider verifying that the destination buffer is large enough to hold the source string plus the null terminator to prevent buffer overflows.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bd306526-e36b-3f8b-81d2-224c6f1b0ee8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before the `memcpy` function is called. \n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <cstring>\n#include <algorithm>\n#include <string>\n\nvoid safe_memcpy(char* svalue, const std::string& version, size_t max_size) {\n    size_t copy_size = std::min(version.size(), max_size - 1);\n    memcpy(svalue, version.c_str(), copy_size);\n    svalue[copy_size] = '\\0'; // Ensure null termination\n}\n```\n\nIn this code, `std::min` is used to ensure that the size of the data being copied does not exceed the size of the destination buffer. The `- 1` is to leave space for the null terminator.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<algorithm>`: This library provides the `std::min` function.\n- `<string>`: This library provides the `std::string` class.\n\n## OWASP and CWE Links\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a later date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bffdaaa1-76ab-3e95-8a13-940540c1e318",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict is marked as genuine. The code copies data from a C-style string into a destination buffer, but there is no evidence of checks to ensure that the destination pointer is not null. The analysis also notes that the destination pointer may be null, which could lead to a crash or other undefined behavior if the function is called with an invalid pointer. The source is a C-style string, which is generally safe, but the lack of null checks on the destination is a significant risk. There are no guards or capacity checks present, and the length is not derived from the buffer's capacity, increasing the risk of error. Developers should ensure that the destination pointer is valid before performing the copy operation.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer is not null. Add an explicit check to validate the destination buffer. If the pointer is null, handle the error appropriately (e.g., return an error code, throw an exception, or log the error).\n\n```cpp\nif (desc && desc->vendor_and_architecture_name) {\n    memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length() + 1);\n} else {\n    // Handle error: destination buffer is null\n}\n```\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e97a9f54-b3fd-3837-8d76-9c24aa2f005e",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that either the source or destination pointer may be null, and there are no obvious null pointer checks before the memory copy operation. The verdict for this call site is also marked as 'GENUINE', confirming the high confidence in the issue. The source is a C++ string's c_str(), which is generally safe, but the destination pointer may be null, as there is no evidence of a guard or check to ensure it is valid before use. This can lead to a crash or other undefined behavior if the destination is null. The probability of this being a false positive is very low, as the analysis found no mitigating factors such as pointer validation or bounds checks.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the destination is invalid. For example:\n\n```cpp\nif (desc && desc->vendor_and_architecture_name) {\n    memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length() + 1);\n} else {\n    // Handle error: destination is null\n}\n```\n\nThis check ensures that the destination pointer is valid before attempting to copy memory, preventing a potential crash or undefined behavior.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c276a637-1fea-3d59-bcc6-51fec0424bc3",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is not known or proven to be sufficient for the number of bytes being copied. The code copies the contents of a string (using its size) into a destination pointer, but there is no evidence that the destination buffer is large enough to hold the data. The risk is further increased because there is no explicit check or guard to ensure the destination is large enough, and the destination type is a generic pointer, which provides no size information. Although the source is a string and not null, and there is no overlap or null pointer risk, the lack of destination size validation makes this a high-confidence, actionable issue.\n\n## In Context Remediation\nBefore copying data from the string to the destination buffer, ensure that the destination buffer is large enough to hold the data. If the size of the destination buffer is not known, you must pass the buffer size as an additional argument or use a safer function that takes the buffer size into account. For example, if you know the size of the destination buffer (let's say `value_size`), you should check that `ModuleName.size()` does not exceed `value_size`:\n\n```cpp\nif (ModuleName.size() <= value_size) {\n    memcpy(value, ModuleName.c_str(), ModuleName.size());\n} else {\n    // Handle error: buffer too small\n}\n```\n\nAlternatively, if you want to ensure null-termination and avoid overflows, you can use `strncpy` or `memcpy` with the minimum of the buffer size and the string size, and then explicitly null-terminate if appropriate:\n\n```cpp\nsize_t copy_len = std::min(ModuleName.size(), value_size - 1);\nmemcpy(value, ModuleName.c_str(), copy_len);\n((char*)value)[copy_len] = '\\0';\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a0ab131c-9069-335d-b9ef-ad039e54e2a0",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is not known or checked before copying data into it. The code copies the contents of a string (using its size) into a destination pointer without verifying that the destination is large enough to hold the data. There is no evidence of a guard or check to ensure the destination buffer is sufficiently sized, and the classification explicitly marks this as high risk. The source is a C++ string's internal buffer, which is safe in terms of null-termination, but the lack of destination size validation means a buffer overflow is possible. The risk is further increased because the destination is a generic pointer (void*), making it impossible to infer its size or safety from the code context.\n\n## In Context Remediation\nBefore copying data, ensure that the destination buffer is large enough to hold the contents being copied. If the size of the destination buffer is not known, pass the buffer size as an additional argument and check it against the size of the data to be copied. For example:\n\n```cpp\n// Assume 'value' is a pointer to a buffer of size 'value_capacity'.\nif (SymbolName.size() <= value_capacity) {\n    memcpy(value, SymbolName.c_str(), SymbolName.size());\n} else {\n    // Handle error: buffer too small\n}\n```\n\nIf you cannot guarantee the size of the destination buffer, consider using safer alternatives or redesigning the function to avoid raw memory operations.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "cc08d729-4e18-30be-a720-be0fd51c8bd0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nProduction Code Debugging Vulnerability in C++ refers to the situation where debugging code or debugging commands are inadvertently left in the production code. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. Debugging code often contains sensitive information or functionality that should not be exposed in a production environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always remove debugging code or commands before deploying to production.\n2. Use preprocessor directives to ensure debugging code is not included in the production build.\n3. Regularly review and audit your code to ensure no debugging code has been left in.\n4. Use automated tools to check for common debugging commands or code snippets.\n\n## Source Code Fix Recommendation\n\nIf you have a piece of code like this:\n\n```cpp\n#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\nYou should remove or comment out the `#define DEBUG` line before deploying to production:\n\n```cpp\n//#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\n## Library Dependencies\n\nThe code example provided does not require any additional library dependencies.\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "70dfece4-c1c5-3ece-a237-5b2c783e0672",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, which can lead to arbitrary code execution, denial of service, or information disclosure. \n\nIn this case, the `ctime` function is considered insecure. The `ctime` function converts a time_t value into a string, but it does not check for buffer overflows. If an attacker can control the input to the `ctime` function, they can potentially cause a buffer overflow.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking. In the case of `ctime`, a safer alternative is `ctime_r`, which is a reentrant version that takes an additional argument for the result.\n\n## Source Code Fix Recommendation\n\nReplace the `ctime` function with `ctime_r`. Here is an example:\n\n```cpp\n#include <ctime>\n\nvoid print_time(time_t time) {\n    char buffer[26];\n    if (ctime_r(&time, buffer) == NULL) {\n        // Handle error\n    } else {\n        printf(\"%s\\n\", buffer);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<ctime>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "330ed6e0-61f4-3da3-b48e-8801f2040e76",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m_pData, vector.m_pData, sizeof(T))`, there is no check to ensure that the size of `vector.m_pData` is not larger than `m_pData`. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(vector.m_pData) <= sizeof(m_pData)) {\n    memcpy(m_pData, vector.m_pData, sizeof(T));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `vector.m_pData` is less than or equal to the size of `m_pData`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "cbe03168-05b7-3fe0-8b9d-7eda8bb02244",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, which can lead to arbitrary code execution, denial of service, or information disclosure. \n\nIn this case, the `ctime` function is considered insecure. The `ctime` function converts a time_t value into a string, but it does not check for buffer overflows. If an attacker can control the input to the `ctime` function, they can potentially cause a buffer overflow.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking. In the case of `ctime`, a safer alternative is `ctime_r`, which is a reentrant version that takes an additional argument for the result.\n\n## Source Code Fix Recommendation\n\nReplace the `ctime` function with `ctime_r`. Here is an example:\n\n```cpp\n#include <ctime>\n\nvoid print_time(time_t time) {\n    char buffer[26];\n    if (ctime_r(&time, buffer) == NULL) {\n        // Handle error\n    } else {\n        printf(\"%s\\n\", buffer);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<ctime>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "216f6fbd-5dce-3256-84f2-3f8f2f62559f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "64965a36-9aa3-3a47-8307-22726c8897f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null byte.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null byte at the end, or by manually adding a null byte after the last character of the string.\n\n## Source Code Fix Recommendation\n\nIf `pString` is a character array, you can ensure it is null-terminated by initializing it with a null byte:\n\n```cpp\nchar pString[] = \"Hello, world!\";\n```\n\nIf `pString` is a pointer to a string, you can add a null byte at the end:\n\n```cpp\nchar* pString = new char[14];\nstrcpy(pString, \"Hello, world!\");\npString[13] = '\\0';\n```\n\nIn both cases, `strlen(pString)` will now correctly return 13.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "039db223-e427-388a-9524-2bd71bc1d070",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination is a pointer to an 8-bit unsigned integer, and the source is the address of a hash variable. The analysis determined, through data flow, that the destination and source may overlap, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, the analysis could not rule out the possibility that the source pointer may be null, which would also cause undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function call is not protected by any length or capacity checks. Therefore, this is a high-confidence, actionable issue that should be addressed to ensure program correctness and security.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For the code in question, replace the memory copy operation with `memmove`:\n\n```cpp\nmemmove(out, &hash, 8);\n```\n\nAdditionally, if there is any chance that the source pointer could be null, add a check before the copy:\n\n```cpp\nif (out != nullptr && &hash != nullptr) {\n    memmove(out, &hash, 8);\n}\n```\n\nThis ensures that the operation is safe and avoids undefined behavior due to null pointers or overlapping memory regions.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a2a55aa4-63a3-3581-a057-3b37db7cc643",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to calculate the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue to read memory until it encounters a null character, which can lead to buffer over-read, causing undefined behavior, crashes, or potential information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, use safer string handling functions that include length checks, such as `strnlen`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` function:\n\n```cpp\nsize_t length = strnlen(MetroHash64::test_string, MAX_LENGTH);\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash64::test_string), length);\n```\n\nIn the above code, `MAX_LENGTH` should be the maximum length of `MetroHash64::test_string` that you expect. This will prevent `strnlen` from reading beyond the expected length of the string.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `MetroHash`: A library for non-cryptographic hash functions.\n- `cstring`: A standard C++ library for string handling functions.\n\n## References\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "0034256f-25c3-3bd3-a534-473323286eca",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination is a pointer, and the source is an address of a variable, with dataflow analysis indicating that the destination may alias the source. Additionally, the analysis could not rule out the possibility that the source pointer is null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. This type of problem can lead to unpredictable program behavior, crashes, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior caused by overlapping memory regions in the memory copy operation, ensure that the source and destination do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, validate that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (out != nullptr && out != reinterpret_cast<uint8_t*>(&hash)) {\n    memcpy(out, &hash, 8);\n} else if (out != nullptr) {\n    // If overlap is possible, use memmove instead\n    memmove(out, &hash, 8);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fcd8bbb9-1aec-3aa1-9a70-af78fe33e42b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to calculate the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue to read memory until it encounters a null character, which can lead to buffer over-read, causing undefined behavior, crashes, or potential information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, use safer string handling functions that include length checks, such as `strnlen`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` function:\n\n```cpp\nsize_t length = strnlen(MetroHash64::test_string, MAX_LENGTH);\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash64::test_string), length);\n```\n\nIn the above code, `MAX_LENGTH` should be the maximum length of `MetroHash64::test_string` that you expect. This will prevent `strnlen` from reading beyond the expected length of the string.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `MetroHash`: A library for non-cryptographic hash functions.\n- `cstring`: A standard C++ library for string handling functions.\n\n## References\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "cc53f7e7-6a0e-3fdf-a425-d3cf5cf2a638",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `strlen` function is used on `MetroHash64::test_string`. To fix the vulnerability, you should ensure that `test_string` is null-terminated. Here is a possible fix:\n\n```cpp\nconst char* test_string = \"your_string_here\";\nsize_t length = strlen(test_string);\nif (test_string[length] != '\\0') {\n    test_string[length] = '\\0';\n}\nMetroHash64::Hash(key, strlen(MetroHash64::test_string), hash, 1);\n```\n\n## Library Dependencies\n\nThe code snippet provided seems to be using the MetroHash library. Therefore, the MetroHash library is a dependency for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "fd02be80-d618-31f0-83d8-47275feb8d97",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. This is because `strlen` does not check for null termination and will continue reading memory until it encounters a null byte. If the string is not null-terminated, `strlen` can read past the end of the buffer, leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` such as `strnlen` which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the vulnerability can be fixed by ensuring that `MetroHash64::test_string` is null-terminated before passing it to `strlen`. If `MetroHash64::test_string` is a `std::string`, you can use its `length` or `size` member function instead of `strlen`.\n\n```cpp\nMetroHash64::Hash(key, MetroHash64::test_string.length(), hash, 0)\n```\n\n## Library Dependencies\n\nThe code snippet appears to depend on the MetroHash library. Ensure that this library is properly installed and included in your project.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "caebf481-db3b-30c5-b03c-427a63f73d9f",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source may overlap based on data flow, which can cause undefined behavior with functions like memcpy. Additionally, the source may be null at this call site, further increasing the risk. There are no explicit guards or checks to prevent these issues, and the destination is a pointer type with no known capacity, making it difficult to guarantee safety. These factors collectively indicate a real risk that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping regions safely. Replace the original call with:\n\n```cpp\nmemmove(hash, &h, 8);\n```\n\nThis change ensures that even if `hash` and `&h` overlap, the memory copy will be performed correctly without causing undefined behavior. Additionally, ensure that both `hash` and `&h` are valid pointers and that the destination buffer is large enough to hold 8 bytes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "83ca735c-4206-3b43-a2cc-60a87106d1d9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard ensuring that the source is non-null, which increases the risk of a null pointer dereference. The destination is a pointer type with no known capacity, and the copy length is a fixed value (8 bytes), but the main concern is the potential for overlapping memory regions, which can cause undefined behavior in standard memory copy functions. These factors make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use a memory move function that is safe for overlapping regions. Replace the memory copy operation with a function such as `memmove`, which is designed to handle overlapping memory safely. For example:\n\n```cpp\nmemmove(hash, state.v, 8);\n```\n\nThis change ensures that the operation is well-defined even if the source and destination overlap. Additionally, consider adding explicit checks to ensure that neither pointer is null before performing the operation, to avoid null pointer dereference vulnerabilities.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0722109d-2b1c-3d91-91af-574a7cca8c86",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence that the destination pointer is guaranteed to be non-null before the call, which increases the risk of a crash or further undefined behavior. The source pointer is guarded to be non-null, but the destination is not. The copy length is calculated dynamically and is not directly tied to the capacity of the destination buffer, which further increases the risk. These factors together indicate a high-confidence, actionable issue that should be remediated.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(input.b, ptr, static_cast<size_t>(end - ptr));\n```\n\nAdditionally, ensure that both the source (`ptr`) and destination (`input.b`) pointers are valid and non-null before performing the copy. If the destination pointer can be null, add a check before the call:\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    memmove(input.b, ptr, static_cast<size_t>(end - ptr));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "072c6b54-21eb-3927-a0a0-1c00be8036f2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination are non-null, increasing the risk of null pointer dereference. The absence of explicit bounds checks or guards further increases the likelihood of a real issue. The classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace `memcpy` with `memmove`, which is designed to handle overlapping memory safely. Additionally, ensure that both the source and destination pointers are not null before performing the operation. For example:\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    memmove(input.b + (bytes % 32), ptr, static_cast<size_t>(fill));\n}\n```\nThis change ensures that the copy operation is safe even if the source and destination regions overlap, and it guards against null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "228c1883-2d8c-3d81-bb95-b4b33fe39a13",
              "help": {
                "text": "",
                "markdown": "## Description\n\nStoring sensitive information such as tokens, keys, or passwords in source code is a security vulnerability. This is because the source code can be easily accessed by unauthorized users, who can then use this sensitive information for malicious purposes. In C++ programming, this vulnerability can occur when developers hard-code sensitive information directly into their source code.\n\nIn the provided code snippet, a string is being stored directly in the source code. If this string was a sensitive token or key, it would be exposed to anyone who has access to the source code.\n\n## Mitigation Advice\n\nAvoid storing sensitive information directly in the source code. Instead, use secure methods to store and retrieve this information, such as environment variables, secure server, or encrypted database. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the string directly in the source code, you could store it in an environment variable and then retrieve it in your code. Here's how you could do it:\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* value = std::getenv(\"TEST_STRING\");\nif (value != nullptr) {\n    MetroHash64::test_string = value;\n}\n```\n\nIn this code, `std::getenv` is used to retrieve the value of an environment variable named `TEST_STRING`. This value is then assigned to `MetroHash64::test_string`.\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library to use the `std::getenv` function.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS173237"
                ]
              }
            },
            {
              "id": "12f2c581-da9c-374d-94b7-c4f5373b4157",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Storing Tokens or Keys in Source Code Vulnerability\" is a security flaw that occurs when sensitive data such as API keys, tokens, or passwords are hard-coded into the source code. This is a bad practice because if the source code is ever exposed, the sensitive data will also be exposed. This could lead to unauthorized access or other security breaches.\n\nIn the given code snippet, the key `test_key_63` is hard-coded into the source code, which is a security vulnerability.\n\n```cpp\ntest_key_63 = \"012345678901234567890123456789012345678901234567890123456789012\";\n```\n\n## Mitigation Advice\n\nAvoid hard-coding sensitive data into your source code. Instead, use secure methods to store and retrieve these data, such as environment variables, secure server, or encrypted database. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the key into the source code, you can store it in an environment variable and retrieve it when needed. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for getenv\n\nconst char* test_key_63 = std::getenv(\"TEST_KEY_63\");\nif (!test_key_63) {\n    // handle error: environment variable TEST_KEY_63 is not defined\n}\n```\n\nIn this code, `std::getenv` is a function from the `cstdlib` library that retrieves the value of the environment variable. If the environment variable is not defined, it returns a null pointer.\n\n## Library Dependencies\n\nThe `cstdlib` library is required by the code example to execute properly.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS117838"
                ]
              }
            },
            {
              "id": "a1e76268-1ade-3948-be17-bb1520e4bf60",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard or check to prevent this overlap. The source pointer may also be null, which further increases the risk of undefined behavior. These factors indicate a real risk of memory corruption or program crashes if the overlap or null pointer dereference occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory regions safely. Replace the original call with:\n\n```cpp\nmemmove(out, v, 16);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0cfd4175-2f0f-39c6-bc06-c3896e02e982",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that the destination may alias the source, which can cause undefined behavior with functions like memcpy. Additionally, there is no evidence of a guard to prevent null pointers for the source, further increasing the risk. The destination is not likely to be null, but the source may be, and there is no explicit check for this. The copy size is a fixed value (16 bytes), but without guarantees about the relationship between the source and destination, this does not mitigate the risk. Therefore, this is a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(out, v, 16);\n```\n\nAdditionally, ensure that both `out` and `v` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (out != nullptr && v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bb760f13-5082-39e3-b482-c4a1f7f6e77d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. The `qsort` function is one such function that can lead to this vulnerability. It is a standard library function in C that performs a quicksort on an array. However, it can be misused in a way that leads to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `qsort` function. In C++, the `std::sort` function from the `<algorithm>` library is a safer and more efficient alternative. It is type-safe and does not require a comparison function as a parameter, reducing the risk of misuse.\n\n## Source Code Fix Recommendation\n\nReplace the `qsort` function with the `std::sort` function. Here is an example of how to do this:\n\n```cpp\n#include <algorithm>\n#include <vector>\n\n// Old code using qsort\n// int compare(const void* a, const void* b);\n// qsort(array, size, sizeof(int), compare);\n\n// New code using std::sort\nstd::vector<int> vec = { /* your data */ };\nstd::sort(vec.begin(), vec.end());\n```\n\n## Library Dependencies\n\nThe `std::sort` function requires the `<algorithm>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "14547da1-a929-32d9-94a5-57fdee039bc9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1c232ed6-4581-31d2-8376-b4c3daa5394f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nIf `pStrValue` is a pointer to a string, ensure it is null-terminated before passing it to `strlen()`. If the length of the string is known at compile time, consider using `strnlen()` instead.\n\n```cpp\n// Ensure pStrValue is null-terminated\nif (pStrValue != nullptr) {\n    size_t len = strnlen(pStrValue, MAX_LENGTH);\n}\n```\n\nIn this example, `MAX_LENGTH` should be replaced with the maximum expected length of the string. If the string is longer than `MAX_LENGTH`, `strnlen()` will return `MAX_LENGTH`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "66860efa-ae9c-3b89-b663-3509bc4b6663",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fcbdea81-f4dc-3c88-9ae3-a3aed4e82733",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `mbstowcs` function in C++ is used to convert a multibyte string to a wide character string. However, it can lead to vulnerabilities if not used properly. The function does not perform any bounds checking on the destination buffer, which can lead to buffer overflow if the source string is longer than the destination buffer. This can lead to arbitrary code execution or denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the converted string, including the null terminator. You should also consider using safer alternatives that perform bounds checking, such as `mbstowcs_s` or `mbsrtowcs`.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use `mbstowcs_s` to safely convert a multibyte string to a wide character string:\n\n```cpp\n#include <locale.h>\n#include <wchar.h>\n#include <stdlib.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.utf8\");\n    const char* mbstr = \"multibyte string\";\n    size_t len = mbstowcs(NULL, mbstr, 0) + 1;\n    wchar_t* wcstr = new wchar_t[len];\n    size_t converted;\n    mbstowcs_s(&converted, wcstr, len, mbstr, _TRUNCATE);\n    // use wcstr\n    delete[] wcstr;\n    return 0;\n}\n```\n\nIn this example, `mbstowcs` is first used to calculate the length of the converted string, then `mbstowcs_s` is used to perform the conversion. The `_TRUNCATE` option ensures that the conversion is safely truncated if the source string is too long.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- locale.h\n- wchar.h\n- stdlib.h\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bbd0a3bf-4e37-35b3-904c-27cc17e25837",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It returns the number of characters in a string up to but not including the first null character. The vulnerability arises when the string does not have a null character, causing `strlen()` to read beyond the intended memory, leading to a buffer overflow. This can result in crashes, incorrect behavior, or allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that are not guaranteed to be null-terminated. Instead, use safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(pDst)` with `strnlen(pDst, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of the string.\n\n```cpp\n#include <string.h>\n\n#define MAX_LENGTH 100\n\n// ...\n\nsize_t length = strnlen(pDst, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strnlen()` function is part of the `<string.h>` library in C++.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "f80cba1d-8748-30cc-bf6d-1d1a88aa3eb5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function in question is `atof`.\n\nThe `atof` function converts a string to a double. It does not check for overflow or underflow, and it does not report any errors. This can lead to unexpected behavior if the string cannot be represented as a double.\n\n## Mitigation Advice\n\nAvoid using the `atof` function. Instead, use safer alternatives such as `strtod` or `sscanf`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atof` function with `strtod` or `sscanf`. Here is an example of how to use `strtod`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char* str = \"123.45\";\nchar* endptr;\nerrno = 0; // To distinguish success/failure after call\ndouble val = strtod(str, &endptr);\n\n// Check for various possible errors\nif ((errno == ERANGE && (val == HUGE_VALF || val == HUGE_VALL)) || (errno != 0 && val == 0)) {\n    perror(\"strtod\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == str) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\n// If we got here, strtod() successfully parsed a number\nprintf(\"strtod() returned %f\\n\", val);\n\nif (*endptr != '\\0') // Not necessarily an error...\n    printf(\"Further characters after number: %s\\n\", endptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- cerrno\n- cstdio\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ae2a2a56-1acd-3e30-8625-ecaec16dad0b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2ef7e877-fdbb-39aa-9260-7f4516f216c6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncat` function in C++ is considered unsafe because it can lead to buffer overflow vulnerabilities. This function appends the source string to the destination string up to n characters. If the size of the destination buffer is not properly managed, it can lead to buffer overflow, which can cause the program to crash or lead to code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that are available in C++. For example, you can use the `strlcat` function which is designed to be safer, or you can use the string class in C++ which automatically manages the memory.\n\n## Source Code Fix Recommendation\n\nReplace the `strncat` function with `strlcat` function or use C++ string class.\n\n```cpp\n// Using strlcat\nsize_t sizeDst = sizeof(pDst);\nsize_t dstLength = strnlen(pDst, sizeDst);\nif (dstLength == sizeDst) {\n    // Handle error: pDst was not null-terminated.\n} else if (strlcat(pDst, pSrc, sizeDst) >= sizeDst) {\n    // Handle error: pDst is not large enough.\n}\n\n// Using C++ string class\nstd::string dst(pDst);\nstd::string src(pSrc);\ndst += src;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstring` or `string.h` for `strncat` and `strlcat` functions.\n- `string` for C++ string class.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "af38c419-aa2e-3bb7-b241-a4971a9ee83f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. One such function is `wcsncat`.\n\nThe `wcsncat` function is a wide-character string function that appends not more than `n` wide-characters from a source string to the end of a destination string. The vulnerability arises when the size of the destination buffer is not properly managed, leading to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `wcsncat` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that include bounds checking such as `wcsncat_s` (in the case of Microsoft's implementation of C++), or use C++ strings (`std::wstring`) which are safer and easier to use.\n\n## Source Code Fix Recommendation\n\nInstead of using `wcsncat`, use `std::wstring`:\n\n```cpp\n#include <string>\n\nint main() {\n    std::wstring str1 = L\"Hello, \";\n    std::wstring str2 = L\"World!\";\n    str1 += str2; // This is safe\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "16800e0e-e2ec-3bf0-9913-e16dab2cc7ee",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcsncpy` function is one of these prohibited functions. It is used to copy a certain number of characters from one wide string to another. However, if the source string length is less than the number of characters to be copied, `wcsncpy` does not null-terminate the destination string, which can lead to buffer overflows.\n\n## Mitigation Advice\n\nAvoid using `wcsncpy` and other prohibited C functions. Instead, use safer alternatives that do not have these vulnerabilities. For example, consider using `wcsncpy_s` or `wmemcpy_s` which are safer as they null-terminate the destination string.\n\n## Source Code Fix Recommendation\n\nReplace `wcsncpy` with `wcsncpy_s` or `wmemcpy_s`. Here is an example:\n\n```cpp\n// Old vulnerable code\nwchar_t dest[100];\nwcsncpy(dest, src, 100);\n\n// Fixed code using wcsncpy_s\nwchar_t dest[100];\nwcsncpy_s(dest, 100, src, _TRUNCATE);\n\n// Or using wmemcpy_s\nwchar_t dest[100];\nwmemcpy_s(dest, 100, src, wcsnlen(src, 100));\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <wchar.h>\n```\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e65a9b96-e9eb-3f01-a360-56edb3b52a6c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "839e3166-f684-3e4a-9a04-e7c8d5f073a4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It takes a string as an argument and returns its length. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be read.\n\n## Source Code Fix Recommendation\n\nIf `pSrc` is the string being passed to `strlen()`, ensure it is null-terminated:\n\n```cpp\nchar pSrc[] = \"Hello, World!\";\nsize_t len = strlen(pSrc);\n```\n\nOr use `strnlen()` instead:\n\n```cpp\nchar pSrc[] = \"Hello, World!\";\nsize_t len = strnlen(pSrc, sizeof(pSrc));\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "faad9572-9715-3ab5-aee8-aef01a41a77a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflows. This function copies a string from one location to another, but it does not automatically append a null character at the end of the string. If the source string is longer than the destination buffer, this can lead to buffer overflow, which can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source string and the null character. You should also consider using safer string handling functions that automatically handle null termination, such as `strlcpy` or `strncpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `strncpy_s`:\n\n```cpp\n// Using strlcpy\nstrlcpy(pDst, pSrc, dstSize);\n\n// Using strncpy_s\nstrncpy_s(pDst, dstSize, pSrc, _TRUNCATE);\n```\n\nNote: `strlcpy` and `strncpy_s` are not standard C++ functions and may not be available on all platforms. If they are not available, you can manually ensure null termination:\n\n```cpp\nstrncpy(pDst, pSrc, dstSize - 1);\npDst[dstSize - 1] = '\\0';\n```\n\n## Library Dependencies\n\nThe `strncpy`, `strlcpy`, and `strncpy_s` functions are part of the C standard library, so you need to include the `cstring` or `string.h` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "eb1f2896-6ed5-3dc2-b53c-83adcb8e4291",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The destination is not likely to be null, but the source may be. The use of a fixed length (16 bytes) does not mitigate the risk of undefined behavior if the regions overlap. This type of issue can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the regions overlap.\n\n```cpp\nmemmove(out, v, 16);\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly and consider adding an assertion to enforce it at runtime:\n\n```cpp\nassert(out + 16 <= v || v + 16 <= out); // Ensure no overlap\nmemcpy(out, v, 16);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy:\n\n```cpp\nif (v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "19d646e3-6924-3361-a829-df4f1ae6e1ef",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, which can lead to buffer over-read, and in some cases, can cause a segmentation fault or other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, you can use safer string handling functions that include length parameters, such as `strnlen`, which takes an additional parameter specifying the maximum number of bytes to read.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you can replace `strlen` with `strnlen` and add a maximum length parameter. Here's how you can do it:\n\n```cpp\nconst size_t max_length = 128; // Define a maximum length according to your needs\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash128::test_string), strnlen(MetroHash128::test_string, max_length))\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the MetroHash library, which provides the `MetroHash128` class and the `Update` method. The `strlen` function is part of the standard C library, which is typically included with any C++ compiler.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "5070b677-6126-3010-b227-c6acdfa7fe9e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The destination is unlikely to be null, but the source may be. The use of a fixed length (16 bytes) does not mitigate the risk of undefined behavior if the regions overlap. This type of issue can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(out, v, 16);\n```\n\nAdditionally, ensure that both `out` and `v` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (out != nullptr && v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2a4db397-3252-3431-86a7-cf0ca0a33135",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, which can lead to buffer over-read, and in some cases, can cause a segmentation fault or other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, you can use safer string handling functions that include length parameters, such as `strnlen`, which takes an additional parameter specifying the maximum number of bytes to read.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you can replace `strlen` with `strnlen` and add a maximum length parameter. Here's how you can do it:\n\n```cpp\nconst size_t max_length = 128; // Define a maximum length according to your needs\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash128::test_string), strnlen(MetroHash128::test_string, max_length))\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the MetroHash library, which provides the `MetroHash128` class and the `Update` method. The `strlen` function is part of the standard C library, which is typically included with any C++ compiler.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "9339ec3a-a3fd-34da-9f8a-0bfe2e110b7d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `strlen` function is used to determine the length of `MetroHash128::test_string`. To fix the vulnerability, you should ensure that `MetroHash128::test_string` is null-terminated. This can be done by adding a null character to the end of the string when it is initialized.\n\n```cpp\n// Ensure that MetroHash128::test_string is null-terminated\nchar MetroHash128::test_string[] = \"test string\\0\";\n\n// Now it's safe to use strlen\nMetroHash128::Hash(key, strlen(MetroHash128::test_string), hash, 1);\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to depend on the MetroHash library, which provides the `MetroHash128` class and its associated `Hash` function. The `strlen` function is part of the standard C library, which is included by default in most C++ environments.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the provided links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "9ce34748-88fe-3a48-9455-77615bb79aaa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated, which can lead to buffer overflows, memory corruption, and other unexpected behavior. This is because `strlen` counts characters until it encounters a null character, and if there is no null character, it will continue reading memory beyond the intended boundary.\n\nIn the provided code snippet, the `strlen` function is used to determine the length of `MetroHash128::test_string`. If `MetroHash128::test_string` is not null-terminated, this could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\nAdditionally, consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read beyond this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t length = strlen(MetroHash128::test_string);\nif (length > MAX_LENGTH) {\n    length = MAX_LENGTH;\n}\nMetroHash128::Hash(key, length, hash, 0);\n```\n\nIn this fix, `strnlen` is used instead of `strlen`, and a maximum length (`MAX_LENGTH`) is specified to prevent buffer overflows.\n\n## Library Dependencies\n\nThe provided code snippet appears to be using the MetroHash library. Therefore, the MetroHash library would be a required dependency for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "c863d8cd-64be-347f-9535-7e3621370ac4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The destination is not likely to be null, but the source may be. The use of a fixed length (16 bytes) does not mitigate the risk of undefined behavior if the regions overlap. This type of issue can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that is safe for overlapping memory, such as `memmove` instead of `memcpy`. Replace the original call with `memmove(hash, state.v, 16);`. This ensures correct behavior even if the source and destination regions overlap.\n\n```cpp\nmemmove(hash, state.v, 16);\n```\n\nAdditionally, ensure that both `hash` and `state.v` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (hash != nullptr && state.v != nullptr) {\n    memmove(hash, state.v, 16);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c2a322c8-4e19-3173-831d-c30636dc795a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The classification specifically highlights undefined behavior due to overlapping memory, which is a well-known issue with functions like memcpy. The verdict is marked as genuine, and the risk is further supported by the absence of capacity checks or explicit null-termination. Developers should address this to prevent unpredictable program behavior or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(hash, v, 16);\n```\n\nAdditionally, ensure that both `hash` and `v` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (hash != nullptr && v != nullptr) {\n    memmove(hash, v, 16);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fa72f9ea-f717-3472-8064-62799638fdb0",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence that the destination pointer is always valid, which increases the risk of a null pointer dereference. The source pointer is guarded to be non-null, but the destination is not. The use of a variable length (end - ptr) without explicit bounds checking further increases the risk. These factors together indicate a real risk of undefined behavior and potential security issues.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, validate that the destination pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (input.b != nullptr && ptr != nullptr && input.b != ptr) {\n    memmove(input.b, ptr, end - ptr);\n}\n```\n\nIf you know that overlap is not possible by design, document this assumption clearly and add assertions to enforce it at runtime:\n\n```cpp\nassert(input.b != ptr); // Ensure no overlap\nmemcpy(input.b, ptr, end - ptr);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1cf146d3-7717-3971-9812-fd377714fc37",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that either the source or destination pointers are non-null, increasing the risk of null pointer dereference. The absence of explicit bounds checks or guards further increases the likelihood of a real issue. The verdict is supported by the classification indicating undefined behavior risk and the automated assessment marking this as a genuine finding.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation. For example:\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    memmove(input.b + (bytes % 32), ptr, static_cast<size_t>(fill));\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds null pointer checks to prevent undefined behavior and potential crashes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9453c534-c64a-3f10-8e02-2109ddde6d76",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Avoid Storing Tokens or Keys in Source Code Vulnerability\" is a common security vulnerability in C++ programming language where sensitive data such as tokens, keys, or passwords are hard-coded directly into the source code. This is a bad practice as it exposes sensitive data to anyone who has access to the source code. If the source code is ever compromised, the attacker would have direct access to these sensitive data, which could lead to serious security breaches.\n\n## Mitigation Advice\n\nThe best way to mitigate this vulnerability is to avoid hard-coding sensitive data directly into the source code. Instead, these data should be stored in a secure location such as environment variables, secure server, or using secure APIs provided by the operating system. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the test string directly into the source code, you can store it in an environment variable and then access it from your code. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* test_string = std::getenv(\"TEST_STRING\");\nif (!test_string) {\n    // handle error\n}\nMetroHash128::test_string = test_string;\n```\n\nIn this code, `std::getenv` is used to get the value of the environment variable `TEST_STRING`. If the environment variable is not set, `std::getenv` returns a null pointer.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This is a standard library in C++ for general purpose functions, including environment variables handling.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS173237"
                ]
              }
            },
            {
              "id": "95a20299-6136-3301-afbf-28939d492ea1",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null, as there is no prior check ensuring it is non-null. The destination is not at risk of being null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue. The use of a memory copy function without explicit overlap handling or null checks can lead to unpredictable program behavior, crashes, or security vulnerabilities.\n\n## In Context Remediation\nTo remediate the risk of undefined behavior from overlapping memory regions, replace the memory copy function with one that safely handles overlap, such as `memmove`. Additionally, ensure that the source pointer is checked for null before performing the copy to prevent null pointer dereference. For example:\n\n```c\nif (ptr != NULL) {\n    memmove(&val, ptr, sizeof(val));\n} else {\n    // Handle error: source pointer is null\n}\n```\n\nThis approach ensures that the copy is safe even if the source and destination overlap, and prevents undefined behavior if the source pointer is null.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6f856f3e-c9a2-3467-a1d6-90a985afcce5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nProduction Code Debugging Vulnerability in C++ refers to the situation where debugging code or debugging commands are inadvertently left in the production code. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. Debugging code often contains sensitive information or functionality that should not be exposed in a production environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always remove debugging code or commands before deploying to production.\n2. Use preprocessor directives to ensure debugging code is not included in the production build.\n3. Regularly review and audit your code to ensure no debugging code has been left in.\n4. Use automated tools to check for common debugging commands or code snippets.\n\n## Source Code Fix Recommendation\n\nIf you have a piece of code like this:\n\n```cpp\n#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\nYou should remove or comment out the `#define DEBUG` line before deploying to production:\n\n```cpp\n//#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\n## Library Dependencies\n\nThe code example provided does not require any additional library dependencies.\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "dbc1b88f-07a2-36b0-b778-9e4a51cea174",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null, since there is no prior check ensuring it is valid. These factors make the issue actionable and not a false positive. The classification and verdict both indicate a high-confidence, real problem that could lead to unpredictable program behavior or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use a function that safely handles overlapping regions, such as `memmove` instead of `memcpy`. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```c\nif (ptr != NULL && &val != ptr) {\n    memcpy(&val, ptr, sizeof(val));\n}\n```\n\nIf overlap cannot be ruled out, replace `memcpy` with `memmove`:\n\n```c\nif (ptr != NULL) {\n    memmove(&val, ptr, sizeof(val));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dc6466cb-e6c6-3968-86f5-d2225573b658",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard ensuring the source pointer is non-null, which increases the risk of a null pointer dereference. The destination is not likely to be null, but the source may be. The use of a memory copy function without explicit checks for overlap or null pointers can result in unpredictable program behavior, data corruption, or crashes. These factors make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n**Remediation Example:**\n\n```c\nif (ptr != NULL && &val != ptr) {\n    memcpy(&val, ptr, sizeof(val));\n} else if (ptr != NULL) {\n    // If overlap is possible, use memmove\n    memmove(&val, ptr, sizeof(val));\n}\n```\n\nThis approach first checks for null pointers and then uses `memmove` if there is a possibility of overlap. Always ensure that the size argument does not exceed the actual size of the source and destination objects.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "46e4b884-19a6-3b2e-b3cc-7675d0df9310",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e3e3f85a-d40a-30ab-b258-c58df38ee735",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or code execution vulnerabilities if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, consider using a method that does not involve environment variables to enable logging. If you must use environment variables, ensure that they are properly sanitized and validated before use.\n\n## Source Code Fix Recommendation\n\n```cpp\n// Instead of using getenv(), consider using a configuration file or command line argument to enable logging.\n// If you must use an environment variable, ensure it is properly sanitized and validated.\n\nconst char* env_var = getenv(\"LOADER_ENABLE_LOGGING\");\nif(env_var != NULL) {\n    std::string logging_env(env_var);\n    // Perform sanitization and validation on logging_env before use\n    enable_logging = logging_env;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::string`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2207fdc7-d63f-3e87-bfef-b5c6d5005117",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or unauthorized code execution if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking and do not suffer from the same vulnerabilities. In the case of `getenv()`, consider using a method that does not expose sensitive information through environment variables.\n\n## Source Code Fix Recommendation\n\nThe code fix would depend on the specific requirements of your program. If you need to use an environment variable, ensure that it is not controlled by an attacker and that it does not contain sensitive information. If possible, consider using a configuration file or command line arguments instead of environment variables.\n\n```cpp\n// Instead of using getenv(), consider using a configuration file or command line arguments\nchar* options_append = read_config(\"LOADER_OPTIONS_APPEND\");\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library for the `getenv()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6944fd4f-ae9f-314c-8238-22b151255a1c",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is not known or checked before copying data into it. The code copies the contents of a string into a destination buffer using the size of the string as the number of bytes to copy, but there is no evidence that the destination buffer is large enough to hold this data. The destination is a generic pointer, and there are no checks or guards to ensure it is sufficiently sized. The source is a C-style string, which does not reduce the risk. There is no explicit null-termination after the copy, and no overlap or null pointer issues are detected. The lack of capacity checks and the use of a potentially unsafe copy operation make this a high-risk buffer overflow scenario.\n\n## In Context Remediation\nBefore copying data, always ensure that the destination buffer is large enough to hold the source data. If the size of the destination buffer is not known, pass the buffer size as an additional argument and use it to limit the number of bytes copied. For example, if you know the size of the destination buffer (let's call it `value_capacity`), you can use:\n\n```cpp\nsize_t copy_len = std::min(module_name.size(), value_capacity);\nmemcpy(value, module_name.c_str(), copy_len);\n```\n\nThis ensures that you never write more data than the destination can hold, preventing buffer overflows. If possible, also ensure the buffer is null-terminated if it is used as a string.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a6988277-a364-38ff-8910-1afcbd631356",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a high risk: the destination buffer's capacity is unknown, and the number of bytes being copied is not proven to be within the bounds of the destination. The code copies the contents of a string (using its size) into a destination pointer without verifying that the destination is large enough to hold the data. There are no checks or guards present to ensure the destination buffer is sufficiently sized, and there is no evidence that the length argument is derived from the destination's capacity. The source is a C-style string, which is generally safe, but this does not mitigate the risk of overflowing the destination buffer. The destination pointer type and lack of explicit capacity information further increase the risk of a buffer overflow.\n\n## In Context Remediation\nBefore copying data from the string to the destination buffer, ensure that the destination buffer is large enough to hold the data. If the size of the destination buffer is not known, you must either pass the buffer size as an additional argument or use a safer alternative. For example, if you know the size of the destination buffer (let's say `value_size`), you can add a check and limit the number of bytes copied:\n\n```cpp\nsize_t copy_len = std::min(symbol_name.size(), value_size);\nmemcpy(value, symbol_name.c_str(), copy_len);\n```\n\nIf you do not know the size of the destination buffer, refactor the code to ensure this information is available at the call site. Never copy more bytes than the destination can hold.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "49f26f4a-0d12-386d-9fc2-675fd23f8c36",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "86cac946-bb45-354c-a07e-557143427fb8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other security problems. The `getenv` function is one such function. It returns a pointer to a string that is associated with the matched environment variable name. This can lead to security vulnerabilities if the returned string is modified, or if the program does not handle the possibility that `getenv` could return a null pointer if the specified environment variable does not exist.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `getenv` function. Instead, consider using safer alternatives that are less prone to security issues. Always validate and sanitize input, and handle the possibility of null pointers. \n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, you can use a safer alternative like `getenv_s`. Here is an example of how to use it:\n\n```cpp\n#include <stdlib.h>\n\nchar* value;\nsize_t requiredSize;\n\ngetenv_s(&requiredSize, NULL, 0, \"ENV_VAR\");\nif (requiredSize == 0)\n{\n    printf(\"The environment variable does not exist.\\n\");\n}\nelse\n{\n    value = (char*) malloc(requiredSize * sizeof(char));\n    if (value != NULL)\n    {\n        getenv_s(&requiredSize, value, requiredSize, \"ENV_VAR\");\n        printf(\"The value of the environment variable is: %s\\n\", value);\n    }\n    free(value);\n}\n```\n\nIn this code, `getenv_s` is used to safely get the value of an environment variable. It checks if the environment variable exists and handles the possibility of a null pointer.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "58296b49-2492-3735-8757-4286175d3286",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d9f554c6-0437-3455-b523-f10b6f36622f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null byte.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null byte at the end, or by manually adding a null byte after the last character of the string.\n\n## Source Code Fix Recommendation\n\nIf `pString` is a character array, you can ensure it is null-terminated by initializing it with a null byte:\n\n```cpp\nchar pString[] = \"Hello, world!\";\n```\n\nIf `pString` is a pointer to a string, you can add a null byte at the end:\n\n```cpp\nchar* pString = new char[14];\nstrcpy(pString, \"Hello, world!\");\npString[13] = '\\0';\n```\n\nIn both cases, `strlen(pString)` will now correctly return 13.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "ffb4ac61-f8cd-3e05-94b1-7a197a03546a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the pointer `pNextGroup` is being copied into `ppNextGroup`, which could potentially lead to a buffer overflow if the size of `ppNextGroup` is less than the size of `pNextGroup`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(ppNextGroup) >= sizeof(pNextGroup)) {\n    memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "91d1816c-047e-393f-8773-388004e6a000",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the pointer `pNextGroup` is being used as the size of the destination buffer, which may not be the correct size.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you should replace `sizeof(pNextGroup)` with the actual size of the destination buffer. If `pNextGroup` is a pointer to a buffer of a certain type, you can use `sizeof(*pNextGroup)` to get the size of the buffer. Here is a corrected version of the code:\n\n```cpp\nmemcpy(&pNextGroup, ppNextGroup, sizeof(*pNextGroup));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `cstring` header file in your code:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dbfc6967-431e-39b0-adf5-e5493a76a8de",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying the value of `numEntries` into `pNumEntries`. If the size of `numEntries` is larger than the size of `pNumEntries`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(pNumEntries) >= sizeof(numEntries)) {\n    memcpy(pNumEntries, &numEntries, sizeof(numEntries));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `pNumEntries` is larger or equal to the size of `numEntries`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "27c88cea-8164-32dd-bd14-5ba4a266bd59",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `pNumEntries` is larger than the size of `numEntries`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(*pNumEntries) <= sizeof(numEntries)) {\n    memcpy(&numEntries, pNumEntries, sizeof(numEntries));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed version, we first check if the size of the data pointed to by `pNumEntries` is less than or equal to the size of `numEntries`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in some way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "93b00377-4f43-3238-86fc-eb501c193fe7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the first null character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum number of characters to read.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(key);\n```\n\nConsider using:\n\n```cpp\nstrnlen(key, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string. This will prevent `strnlen()` from reading beyond the end of the string if it is not null-terminated.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "a6f69862-5bd7-3d61-b217-f8f747ff207a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "826a85ab-88b9-3ca8-a1a1-3b506d9f7a9a",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior when using memory copy operations like memcpy. There are no explicit checks or guards in the code to prevent this overlap, and the function does not ensure that the source and destination are distinct. The source and destination are both identified as variables, and the offset calculation on the destination further increases the risk. The source and destination are also confirmed to be non-null, so the main concern is the overlap, not null pointer dereference.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove((char *) dst + offset, src, size);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d0dfcb69-bb5f-3f0e-aa1d-8c419ed98ee1",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "884ba402-6db6-33ab-a253-b6568f737546",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other security problems. The `getenv` function is one such function. It returns a pointer to a string that is associated with the matched environment variable name. This can lead to security vulnerabilities if the returned string is modified, or if the program does not handle the possibility that `getenv` could return a null pointer if the specified environment variable does not exist.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `getenv` function. Instead, consider using safer alternatives that are less prone to security issues. Always validate and sanitize input, and handle the possibility of null pointers. \n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, you can use a safer alternative like `getenv_s`. Here is an example of how to use it:\n\n```cpp\n#include <stdlib.h>\n\nchar* value;\nsize_t requiredSize;\n\ngetenv_s(&requiredSize, NULL, 0, \"ENV_VAR\");\nif (requiredSize == 0)\n{\n    printf(\"The environment variable does not exist.\\n\");\n}\nelse\n{\n    value = (char*) malloc(requiredSize * sizeof(char));\n    if (value != NULL)\n    {\n        getenv_s(&requiredSize, value, requiredSize, \"ENV_VAR\");\n        printf(\"The value of the environment variable is: %s\\n\", value);\n    }\n    free(value);\n}\n```\n\nIn this code, `getenv_s` is used to safely get the value of an environment variable. It checks if the environment variable exists and handles the possibility of a null pointer.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f61a2dd6-75cd-3fc7-97e9-072c0ba77509",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable program behavior, data corruption, or crashes. The verdict is supported by the high-confidence classification and the explicit marking of the call as genuine. There are no indications that the source or destination pointers are null at this point, and no explicit bounds or overlap guards are present. The use of a generic pointer type for the destination and the absence of capacity or length checks further increase the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping memory safely.\n\n```cpp\nmemmove(buf, buffer, bufferSize);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a264f514-f15e-34cd-874f-1ec03962384e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable program behavior, data corruption, or crashes. There are no explicit checks or guards in the code to prevent this overlap, and the function used (`memcpy`) does not handle overlapping memory safely. The source and destination are both confirmed to be non-null, but the overlap risk remains unmitigated. This type of issue is a well-known source of subtle and dangerous bugs in C/C++ code.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(*buf, buffer, bufferSize);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination memory regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "95fddd09-d749-38bd-a5a9-f2469bd4955a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the size of the destination buffer is not known or enforced. The use of a generic pointer type for the destination further increases the risk, as it is not possible to verify buffer boundaries. These factors make this a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the `memcpy` call with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation will not corrupt data if the regions overlap.\n\n```cpp\nmemmove(dest, (const char*) edata->d_buf + offset - coffset, csize);\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly and consider adding runtime assertions to enforce it:\n\n```cpp\nassert((char*)dest + csize <= (const char*)edata->d_buf + offset - coffset ||\n       (const char*)edata->d_buf + offset - coffset + csize <= (char*)dest);\nmemcpy(dest, (const char*) edata->d_buf + offset - coffset, csize);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7f0f1355-009b-37e5-aabb-cf87bcee6439",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` or `strerror_s()`. Also, consider using exception handling for error reporting instead of directly writing error messages to the output.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nchar buf[1024];\nif(strerror_r(errno, buf, sizeof(buf)) == 0) {\n    out << \"Error: \" << msg << \": \" << buf << std::endl;\n} else {\n    out << \"Error: \" << msg << std::endl;\n}\n```\n\n## Library Dependencies\n\n- `<string.h>`: This header file contains declaration of various string handling functions including `strerror_r()`.\n- `<errno.h>`: This header file defines macros for reporting error conditions.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f4b8502d-4b3d-39dd-b64c-7599a6856f56",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the pointer `pNextGroup` is being copied into `ppNextGroup`, which could potentially lead to a buffer overflow if the size of `ppNextGroup` is less than the size of `pNextGroup`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(ppNextGroup) >= sizeof(pNextGroup)) {\n    memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ce9b1b13-1620-3c2d-bb51-3978bc80a13c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the pointer `pNextGroup` is being used as the size of the destination buffer, which may not be the correct size.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you should replace `sizeof(pNextGroup)` with the actual size of the destination buffer. If `pNextGroup` is a pointer to a buffer of a certain type, you can use `sizeof(*pNextGroup)` to get the size of the buffer. Here is a corrected version of the code:\n\n```cpp\nmemcpy(&pNextGroup, ppNextGroup, sizeof(*pNextGroup));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `cstring` header file in your code:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "804f55c7-32ec-34af-86b7-9a390dce73c1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying the value of `numEntries` into `pNumEntries`. If the size of `numEntries` is larger than the size of `pNumEntries`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(pNumEntries) >= sizeof(numEntries)) {\n    memcpy(pNumEntries, &numEntries, sizeof(numEntries));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `pNumEntries` is larger or equal to the size of `numEntries`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3a3a8c6f-2e56-34a0-91f1-0e4c3672055e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the first null character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum number of characters to read.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(key);\n```\n\nConsider using:\n\n```cpp\nstrnlen(key, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string. This will prevent `strnlen()` from reading beyond the end of the string if it is not null-terminated.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "2abcbf71-c924-349b-866e-3b8d7e5488f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `pNumEntries` is larger than the size of `numEntries`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(*pNumEntries) <= sizeof(numEntries)) {\n    memcpy(&numEntries, pNumEntries, sizeof(numEntries));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed version, we first check if the size of the data pointed to by `pNumEntries` is less than or equal to the size of `numEntries`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in some way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4de44d95-f69f-3726-91da-5363aa281948",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. In this case, the function `alloca()` is used, which is considered unsafe. The `alloca()` function dynamically allocates memory on the stack, which can lead to buffer overflow vulnerabilities if not properly managed. This is because the allocated memory is not initialized and can contain sensitive information. Additionally, the function does not provide any mechanism for error handling if the stack overflows.\n\n## Mitigation Advice\n\nAvoid using the `alloca()` function. Instead, use safer alternatives such as `malloc()`, `calloc()`, or `new` for dynamic memory allocation. These functions allocate memory on the heap, not the stack, and provide error handling mechanisms. Always ensure to properly manage and free dynamically allocated memory to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with a safer alternative. Here's how you can do it with `new`:\n\n```cpp\ntry {\n    sdata = new unsigned char[section->size()];\n} catch (std::bad_alloc& ba) {\n    std::cerr << \"bad_alloc caught: \" << ba.what() << '\\n';\n}\n```\n\nRemember to free the allocated memory when you're done with it:\n\n```cpp\ndelete[] sdata;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<new>`: This is required for the `new` operator and `std::bad_alloc` exception.\n- `<iostream>`: This is required for `std::cerr`.\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "98711838-b742-3cb5-b15b-8cf8f4837a03",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `snprintf`.\n\nAdditionally, consider using higher level abstractions provided by C++ such as `std::string` or `std::vector` that manage memory automatically and are less prone to such vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative like `strncpy`. Here's how you can do it:\n\n```cpp\nstrncpy(svalue, isa.c_str(), std::min(sizeof(svalue), isa.size()));\n```\n\nIn this case, `sizeof(svalue)` ensures that we do not exceed the size of the destination buffer.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` and `strncpy` functions.\n- `<algorithm>`: This library provides the `std::min` function.\n- `<string>`: This library provides the `std::string` class.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3c8fd508-6560-3ad9-a74f-61fb110e8346",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before the `memcpy` function is called. \n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <cstring>\n#include <algorithm>\n#include <string>\n\nvoid safe_memcpy(char* svalue, const std::string& version, size_t max_size) {\n    size_t copy_size = std::min(version.size(), max_size - 1);\n    memcpy(svalue, version.c_str(), copy_size);\n    svalue[copy_size] = '\\0'; // Ensure null termination\n}\n```\n\nIn this code, `std::min` is used to ensure that the size of the data being copied does not exceed the size of the destination buffer. The `- 1` is to leave space for the null terminator.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<algorithm>`: This library provides the `std::min` function.\n- `<string>`: This library provides the `std::string` class.\n\n## OWASP and CWE Links\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a later date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "669110e0-0b4e-308c-bc38-bd56a128d845",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the automated verdict confirms this. The code copies data from a string object's internal buffer to a destination pointer, but there is no evidence of a check to ensure the destination pointer is not null. The source is a C++ string's c_str(), which is generally safe, but the destination pointer could be null, leading to a crash or undefined behavior. The absence of a guard or capacity check for the destination increases the risk. The probability of this being a false positive is very low, as the analysis did not detect any safeguards or capacity validation for the destination pointer.\n\n## In Context Remediation\nBefore copying data to the destination buffer, ensure that the destination pointer is not null and that it has enough capacity to hold the source data plus the null terminator. Add explicit checks for the destination pointer and, if possible, validate the buffer size to prevent buffer overflows and undefined behavior. For example:\n\n```cpp\nif (desc->producer_options != nullptr && options.length() + 1 <= PRODUCER_OPTIONS_CAPACITY) {\n    memcpy(desc->producer_options, options.c_str(), options.length() + 1);\n} else {\n    // Handle error: null pointer or insufficient buffer size\n}\n```\n\nReplace `PRODUCER_OPTIONS_CAPACITY` with the actual size of the destination buffer. Always check for null pointers and ensure the buffer is large enough before performing memory operations.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "cf27b0bd-9eb2-3064-a233-372e7a4ad5df",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict is marked as genuine. The code copies data from a C++ string's internal buffer to a destination buffer using a memory copy function, but there is no evidence of a check to ensure that the destination pointer is not null. The source is a C++ string's internal buffer, which is generally safe, but the destination pointer may be null, as there is no guard or validation present. This could lead to a crash or other undefined behavior if the destination pointer is ever null at runtime. The probability of this being a false positive is very low, as the analysis specifically notes the lack of null checks for the destination pointer.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that the destination pointer is not null. This can be done by adding a check before the call:\n\n```cpp\nif (desc && desc->producer_name) {\n    memcpy(desc->producer_name, producer.c_str(), producer.length() + 1);\n}\n// Optionally, handle the error case if desc or desc->producer_name is null\n```\nThis prevents undefined behavior by ensuring that the destination buffer is valid before copying data. If the destination pointer can be null due to logic elsewhere, consider logging an error or returning early to avoid a crash.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0c641e70-a4bf-39bb-8dec-8f01b17da127",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the automated verdict also marks it as genuine. The code copies data from a C-style string into a buffer, but there is no evidence of checks to ensure that the destination pointer is not null before the operation. The source is a C-style string, which is generally safe, but the destination pointer may be null, as there are no visible guards or checks in the code. This could lead to a crash or other undefined behavior if the destination pointer is ever null at runtime. The probability of this being a false positive is very low, as the absence of null checks for the destination pointer is a clear risk.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer is not null. Add a check to verify that `desc` and `desc->vendor_and_architecture_name` are valid pointers before using them. This prevents undefined behavior due to null pointer dereference.\n\n```cpp\nif (desc && desc->vendor_and_architecture_name) {\n    memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length() + 1);\n}\n```\n\nAlternatively, handle the error case explicitly if the pointer is null:\n\n```cpp\nif (!desc || !desc->vendor_and_architecture_name) {\n    // Handle error: invalid destination pointer\n    return ERROR_INVALID_POINTER;\n}\nmemcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length() + 1);\n```\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e3fd4ef2-315e-3d0d-9a71-1331a181b35b",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that either the source or destination pointer may be null. The code copies data from a string object's internal buffer to a destination buffer using a memory copy operation, but there are no visible checks to ensure that the destination pointer is valid (not null) before the operation. If the destination pointer is null, this will result in a crash or undefined behavior. The source pointer is less likely to be null since it is derived from a string object, but the destination pointer is a structure member and may not be initialized. The absence of a guard or check for the destination pointer's validity increases the risk. The probability of this being a false positive is very low, as the analysis shows a real risk of dereferencing a null pointer.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that the destination pointer is not null. Add an explicit check to verify that the destination structure and its buffer member are valid. For example:\n\n```cpp\nif (desc && desc->vendor_and_architecture_name) {\n    memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length() + 1);\n} else {\n    // Handle error: destination is null\n}\n```\nThis prevents undefined behavior by ensuring the destination is valid before copying. If the destination can never be null by design, document this assumption clearly in the code and consider using assertions to enforce it during development.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "513e94e1-98a1-31ef-a20f-d8f6e0d5d190",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a high risk due to the destination buffer's capacity being unknown and the copy length not being proven safe. The destination buffer is a generic pointer, and there is no evidence that its size is sufficient to hold the data being copied. The source is a C++ string's internal character array, and the length argument is the string's size, but there is no check to ensure the destination is large enough. There are no explicit guards or null-termination after the copy, and the analysis did not detect any overlap or null pointer risks. However, the lack of capacity information for the destination and the absence of safety checks make this a likely buffer overflow risk.\n\n## In Context Remediation\nBefore copying data from the string to the destination buffer, ensure that the destination buffer is large enough to hold the data. If the size of the destination buffer is not known, pass the buffer size as an additional argument and use it to limit the number of bytes copied. For example:\n\n```cpp\n// Assume 'value' is a pointer to a buffer and 'value_capacity' is its size in bytes\nsize_t copy_len = ModuleName.size();\nif (copy_len > value_capacity) {\n    // Handle error: buffer too small\n    // e.g., truncate, allocate larger buffer, or return error\n    copy_len = value_capacity;\n}\nmemcpy(value, ModuleName.c_str(), copy_len);\n```\n\nAlways validate that the destination buffer is large enough to avoid buffer overflows. If possible, use safer alternatives such as `std::copy` with iterators or `strncpy` (with care for null-termination) when working with character data.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7f68a7ab-d6b9-3cd8-ad24-83a26e0db8af",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is not known or proven to be sufficient for the number of bytes being copied. The operation copies the contents of a string (using its size) into a destination pointer, but there is no evidence that the destination buffer is large enough to hold the data. The risk is further increased because there is no explicit guard or check to ensure the destination buffer is large enough, and the destination type is a generic pointer, which provides no size information. Although the source is a string and not null, and there is no risk of overlapping memory regions, the lack of bounds checking or capacity validation makes this a high-risk buffer overflow scenario.\n\n## In Context Remediation\nBefore copying data from the string to the destination buffer, ensure that the destination buffer is large enough to hold the data. If the size of the destination buffer is not known, you must pass the buffer size as an additional argument or use a safer function that limits the number of bytes copied to the buffer's capacity. For example, if you know the size of the destination buffer (let's say `value_size`), you can use:\n\n```cpp\nsize_t copy_size = std::min(value_size, SymbolName.size());\nmemcpy(value, SymbolName.c_str(), copy_size);\n```\n\nIf the destination buffer is not large enough, consider allocating a buffer of the required size or returning an error. Always validate buffer sizes before performing memory copy operations to prevent buffer overflows.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3ebb1d43-b829-373d-ad9b-1154a1c3ce71",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination is a pointer to an unsigned 8-bit integer, and the source is the address of a hash variable. Dataflow analysis suggests that the destination and source may overlap, which is not allowed for the standard memory copy function and can result in unpredictable program behavior. Additionally, the analysis could not rule out the possibility that the source pointer may be null, which would also cause undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use a memory-safe function that handles overlapping regions. Replace the memory copy operation with a function designed for overlapping memory, such as `memmove`, which is safe for overlapping regions:\n\n```cpp\nmemmove(out, &hash, 8);\n```\n\nThis change ensures that the copy will work correctly even if the source and destination memory regions overlap. Always verify that both pointers are valid and not null before performing the operation.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b0f9b080-fc35-3f1d-8c0b-1e8e727d24ce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to calculate the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue to read memory until it encounters a null character, which can lead to buffer over-read, causing undefined behavior, crashes, or potential information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, use safer string handling functions that include length checks, such as `strnlen`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` function:\n\n```cpp\nsize_t length = strnlen(MetroHash64::test_string, MAX_LENGTH);\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash64::test_string), length);\n```\n\nIn the above code, `MAX_LENGTH` should be the maximum length of `MetroHash64::test_string` that you expect. This will prevent `strnlen` from reading beyond the expected length of the string.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `MetroHash`: A library for non-cryptographic hash functions.\n- `cstring`: A standard C++ library for string handling functions.\n\n## References\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "f038e4c1-7d21-361f-a76c-c69f181d2880",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to calculate the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue to read memory until it encounters a null character, which can lead to buffer over-read, causing undefined behavior, crashes, or potential information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, use safer string handling functions that include length checks, such as `strnlen`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` function:\n\n```cpp\nsize_t length = strnlen(MetroHash64::test_string, MAX_LENGTH);\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash64::test_string), length);\n```\n\nIn the above code, `MAX_LENGTH` should be the maximum length of `MetroHash64::test_string` that you expect. This will prevent `strnlen` from reading beyond the expected length of the string.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `MetroHash`: A library for non-cryptographic hash functions.\n- `cstring`: A standard C++ library for string handling functions.\n\n## References\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "9d9f91b6-4d33-382a-bdb6-a340c8b510b4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination is a pointer to an 8-bit unsigned integer, and the source is the address of a hash variable. The analysis determined, through data flow, that the destination and source may overlap, which can cause undefined behavior with memcpy. Additionally, the source may be null at this call site, which further increases the risk. There are no explicit checks or guards to prevent these issues, and the function does not ensure that the source and destination are distinct or non-null. This combination of factors makes the finding a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (out != nullptr && &hash != nullptr && out != reinterpret_cast<uint8_t*>(&hash)) {\n    memcpy(out, &hash, 8);\n} else if (out != nullptr && &hash != nullptr) {\n    // If overlap is possible, use memmove instead\n    memmove(out, &hash, 8);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2777fd82-fca7-34d2-8480-9d2a10a97620",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `strlen` function is used on `MetroHash64::test_string`. To fix the vulnerability, you should ensure that `test_string` is null-terminated. Here is a possible fix:\n\n```cpp\nconst char* test_string = \"your_string_here\";\nsize_t length = strlen(test_string);\nif (test_string[length] != '\\0') {\n    test_string[length] = '\\0';\n}\nMetroHash64::Hash(key, strlen(MetroHash64::test_string), hash, 1);\n```\n\n## Library Dependencies\n\nThe code snippet provided seems to be using the MetroHash library. Therefore, the MetroHash library is a dependency for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "503ba429-8467-3475-a2b7-cfa91147e110",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. This is because `strlen` does not check for null termination and will continue reading memory until it encounters a null byte. If the string is not null-terminated, `strlen` can read past the end of the buffer, leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` such as `strnlen` which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the vulnerability can be fixed by ensuring that `MetroHash64::test_string` is null-terminated before passing it to `strlen`. If `MetroHash64::test_string` is a `std::string`, you can use its `length` or `size` member function instead of `strlen`.\n\n```cpp\nMetroHash64::Hash(key, MetroHash64::test_string.length(), hash, 0)\n```\n\n## Library Dependencies\n\nThe code snippet appears to depend on the MetroHash library. Ensure that this library is properly installed and included in your project.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "fad61585-0698-3d0d-aade-5ae1a860a21a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent potential memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(hash, state.v, 8);\n```\n\nAdditionally, ensure that the source pointer (`state.v`) is not null before performing the copy to avoid potential crashes:\n\n```cpp\nif (state.v != nullptr) {\n    memmove(hash, state.v, 8);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "87c38d25-f23a-3d52-bc6b-dcfb80c9c8d8",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source may overlap based on data flow, which can cause undefined behavior with functions like memcpy. Additionally, the source pointer may be null at this call site, which further increases the risk. There are no explicit guards or checks to prevent these issues, and the destination buffer's capacity is not clearly defined. These factors together make this a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(hash, &h, 8);\n```\n\nAdditionally, ensure that both `hash` and `&h` are valid pointers and that the destination buffer is large enough to hold 8 bytes. If there is any uncertainty about the validity of the pointers, add explicit checks before performing the copy operation.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "283fc9bc-aef5-3cc4-85d3-546da3acf792",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is a risk that the destination pointer could be null at the time of the call, as there is no clear guard ensuring it is valid. The source pointer is guarded as non-null, but the lack of a guard for the destination increases the risk. The use of a generic count expression without clear bounds checking further increases the likelihood of a real issue. These factors together indicate a high-confidence, actionable problem that could lead to unpredictable program behavior or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(input.b, ptr, static_cast<size_t>(end - ptr));\n```\n\nAdditionally, ensure that both the source (`ptr`) and destination (`input.b`) pointers are valid and not null before performing the operation. For example:\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    memmove(input.b, ptr, static_cast<size_t>(end - ptr));\n}\n```\n\nThis change eliminates the risk of undefined behavior due to overlapping memory and null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6c1b6aa6-7234-3e86-9b5e-5fea38ad585a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination pointers are non-null, increasing the risk of null pointer dereference. The absence of explicit bounds checks or guards further increases the likelihood of a real issue. The classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Additionally, ensure that both the source and destination pointers are not null before performing the operation, and validate that the copy size does not exceed the bounds of either buffer.\n\n```cpp\nif (input.b != nullptr && ptr != nullptr && fill > 0) {\n    memmove(input.b + (bytes % 32), ptr, static_cast<size_t>(fill));\n}\n```\n\nThis change ensures that the memory copy is safe even if the source and destination regions overlap, and it guards against null pointer dereference. Always validate buffer sizes to prevent buffer overflows.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "82ad7559-d279-38ad-bb01-f764cedcd500",
              "help": {
                "text": "",
                "markdown": "## Description\n\nStoring sensitive information such as tokens, keys, or passwords in source code is a security vulnerability. This is because the source code can be easily accessed by unauthorized users, who can then use this sensitive information for malicious purposes. In C++ programming, this vulnerability can occur when developers hard-code sensitive information directly into their source code.\n\nIn the provided code snippet, a string is being stored directly in the source code. If this string was a sensitive token or key, it would be exposed to anyone who has access to the source code.\n\n## Mitigation Advice\n\nAvoid storing sensitive information directly in the source code. Instead, use secure methods to store and retrieve this information, such as environment variables, secure server, or encrypted database. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the string directly in the source code, you could store it in an environment variable and then retrieve it in your code. Here's how you could do it:\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* value = std::getenv(\"TEST_STRING\");\nif (value != nullptr) {\n    MetroHash64::test_string = value;\n}\n```\n\nIn this code, `std::getenv` is used to retrieve the value of an environment variable named `TEST_STRING`. This value is then assigned to `MetroHash64::test_string`.\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library to use the `std::getenv` function.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS173237"
                ]
              }
            },
            {
              "id": "638bcb1d-dd1c-3c9a-aa32-d992f50d9f4c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Storing Tokens or Keys in Source Code Vulnerability\" is a security flaw that occurs when sensitive data such as API keys, tokens, or passwords are hard-coded into the source code. This is a bad practice because if the source code is ever exposed, the sensitive data will also be exposed. This could lead to unauthorized access or other security breaches.\n\nIn the given code snippet, the key `test_key_63` is hard-coded into the source code, which is a security vulnerability.\n\n```cpp\ntest_key_63 = \"012345678901234567890123456789012345678901234567890123456789012\";\n```\n\n## Mitigation Advice\n\nAvoid hard-coding sensitive data into your source code. Instead, use secure methods to store and retrieve these data, such as environment variables, secure server, or encrypted database. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the key into the source code, you can store it in an environment variable and retrieve it when needed. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for getenv\n\nconst char* test_key_63 = std::getenv(\"TEST_KEY_63\");\nif (!test_key_63) {\n    // handle error: environment variable TEST_KEY_63 is not defined\n}\n```\n\nIn this code, `std::getenv` is a function from the `cstdlib` library that retrieves the value of the environment variable. If the environment variable is not defined, it returns a null pointer.\n\n## Library Dependencies\n\nThe `cstdlib` library is required by the code example to execute properly.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS117838"
                ]
              }
            },
            {
              "id": "7cfc9662-ee41-3bd7-a480-f46d73ae4816",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no evidence of a guard or check to ensure that the source and destination do not overlap, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The destination pointer is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy operation.\n\nExample remediation:\n\n```cpp\nif (out != nullptr && v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\nThis change ensures that the copy is safe even if the memory regions overlap and avoids dereferencing a null pointer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4c14e51b-cf48-3365-9860-832e94fd51c9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The destination pointer is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue. The use of a fixed length (16 bytes) does not mitigate the risk of overlap or null dereference.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid a potential crash.\n\n```cpp\nif (v != nullptr && out != v) {\n    memmove(out, v, 16);\n}\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly and consider adding assertions to enforce it during development:\n\n```cpp\nassert(out != v); // Ensure no overlap\nif (v != nullptr) {\n    memcpy(out, v, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "77f04431-3fa9-3e4b-91e8-8c371a321148",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard or check to ensure that the source and destination do not overlap, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The use of a fixed length (16 bytes) does not mitigate the risk of overlap or null pointer dereference. These factors indicate a real risk of undefined behavior, which can lead to security vulnerabilities or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (out != nullptr && v != nullptr) {\n    // Use memmove to safely handle possible overlap\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f722c8cc-6c22-3b4e-a14b-585e6e2fb16b",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The destination is not likely to be null, but the source may be. The use of a fixed length (16 bytes) does not mitigate the risk of undefined behavior if the regions overlap. This type of issue can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(out, v, 16);\n```\n\nAdditionally, ensure that both `out` and `v` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (out != nullptr && v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8acefd5f-c564-3cd6-922a-12f43216833a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, which can lead to buffer over-read, and in some cases, can cause a segmentation fault or other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, you can use safer string handling functions that include length parameters, such as `strnlen`, which takes an additional parameter specifying the maximum number of bytes to read.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you can replace `strlen` with `strnlen` and add a maximum length parameter. Here's how you can do it:\n\n```cpp\nconst size_t max_length = 128; // Define a maximum length according to your needs\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash128::test_string), strnlen(MetroHash128::test_string, max_length))\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the MetroHash library, which provides the `MetroHash128` class and the `Update` method. The `strlen` function is part of the standard C library, which is typically included with any C++ compiler.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "61659345-4e63-300d-937a-c34f3f911042",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, which can lead to buffer over-read, and in some cases, can cause a segmentation fault or other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, you can use safer string handling functions that include length parameters, such as `strnlen`, which takes an additional parameter specifying the maximum number of bytes to read.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you can replace `strlen` with `strnlen` and add a maximum length parameter. Here's how you can do it:\n\n```cpp\nconst size_t max_length = 128; // Define a maximum length according to your needs\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash128::test_string), strnlen(MetroHash128::test_string, max_length))\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the MetroHash library, which provides the `MetroHash128` class and the `Update` method. The `strlen` function is part of the standard C library, which is typically included with any C++ compiler.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "6de51c45-00dc-319e-b25f-e2e59cc31394",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `strlen` function is used to determine the length of `MetroHash128::test_string`. To fix the vulnerability, you should ensure that `MetroHash128::test_string` is null-terminated. This can be done by adding a null character to the end of the string when it is initialized.\n\n```cpp\n// Ensure that MetroHash128::test_string is null-terminated\nchar MetroHash128::test_string[] = \"test string\\0\";\n\n// Now it's safe to use strlen\nMetroHash128::Hash(key, strlen(MetroHash128::test_string), hash, 1);\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to depend on the MetroHash library, which provides the `MetroHash128` class and its associated `Hash` function. The `strlen` function is part of the standard C library, which is included by default in most C++ environments.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the provided links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "983b0a42-863d-3d86-a8eb-c2c917a817ad",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated, which can lead to buffer overflows, memory corruption, and other unexpected behavior. This is because `strlen` counts characters until it encounters a null character, and if there is no null character, it will continue reading memory beyond the intended boundary.\n\nIn the provided code snippet, the `strlen` function is used to determine the length of `MetroHash128::test_string`. If `MetroHash128::test_string` is not null-terminated, this could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\nAdditionally, consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read beyond this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t length = strlen(MetroHash128::test_string);\nif (length > MAX_LENGTH) {\n    length = MAX_LENGTH;\n}\nMetroHash128::Hash(key, length, hash, 0);\n```\n\nIn this fix, `strnlen` is used instead of `strlen`, and a maximum length (`MAX_LENGTH`) is specified to prevent buffer overflows.\n\n## Library Dependencies\n\nThe provided code snippet appears to be using the MetroHash library. Therefore, the MetroHash library would be a required dependency for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "b600169a-a669-3929-a470-900f4b757237",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may refer to overlapping memory areas, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, there is a risk that the source pointer may be null, as there is no prior check ensuring it is valid. The destination is less likely to be null, but the main concern is the potential for overlapping memory regions. No explicit bounds or null-termination handling is present, and the function is not protected by any guard conditions. These factors all contribute to the high confidence in this being a real issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. The `memmove` function is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(hash, v, 16);\n```\n\nAdditionally, ensure that both `hash` and `v` are valid pointers and that the destination buffer is large enough to hold 16 bytes. If there is any possibility that the source pointer could be null, add a check before the copy:\n\n```cpp\nif (v != nullptr) {\n    memmove(hash, v, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0c6722e8-62b0-3e03-b2e3-e78f21669d53",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence that the source pointer is guaranteed to be non-null, which increases the risk of a null pointer dereference. The destination buffer is a pointer type, and there is no information about its capacity or any guard conditions that would prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(hash, state.v, 16);\n```\n\nAdditionally, ensure that both `hash` and `state.v` are valid, non-null pointers before performing the copy. You can add checks like:\n\n```cpp\nif (hash != nullptr && state.v != nullptr) {\n    memmove(hash, state.v, 16);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "39449e05-0d13-3ee1-b562-ced492de80e8",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable results or program crashes. Additionally, there is no evidence that the destination pointer is always valid, which increases the risk of a null pointer dereference. The source pointer is guarded to be non-null, but the destination is not. The operation does not use a count based on the destination's capacity, and there are no explicit guards or null-termination after the copy. All these factors contribute to a high confidence that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(input.b, ptr, end - ptr);\n```\n\nAdditionally, ensure that both `input.b` and `ptr` are valid pointers and that `input.b` has enough capacity to hold `end - ptr` bytes. If there is any chance that `input.b` could be null, add a check before the call:\n\n```cpp\nif (input.b != nullptr && ptr != nullptr && (end - ptr) > 0) {\n    memmove(input.b, ptr, end - ptr);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d9fa0226-dcaa-31ac-baa2-5b2dc2aca1c2",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the destination and source may overlap based on data flow, which can cause undefined behavior with functions like memcpy. Additionally, there are no checks ensuring that the source and destination pointers are non-null, increasing the risk of null pointer dereference. There are no explicit bounds or capacity checks, and the count argument is not derived from the destination's capacity. All these factors contribute to the high confidence in this being a real issue that could lead to memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap when using memcpy. If overlap is possible, use memmove instead, which is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation.\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    // Use memmove instead of memcpy if overlap is possible\n    memmove(input.b + (bytes % 32), ptr, static_cast<size_t>(fill));\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0e4f3c94-14a7-3b9f-8ad7-8d39a3e295a2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Avoid Storing Tokens or Keys in Source Code Vulnerability\" is a common security vulnerability in C++ programming language where sensitive data such as tokens, keys, or passwords are hard-coded directly into the source code. This is a bad practice as it exposes sensitive data to anyone who has access to the source code. If the source code is ever compromised, the attacker would have direct access to these sensitive data, which could lead to serious security breaches.\n\n## Mitigation Advice\n\nThe best way to mitigate this vulnerability is to avoid hard-coding sensitive data directly into the source code. Instead, these data should be stored in a secure location such as environment variables, secure server, or using secure APIs provided by the operating system. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the test string directly into the source code, you can store it in an environment variable and then access it from your code. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* test_string = std::getenv(\"TEST_STRING\");\nif (!test_string) {\n    // handle error\n}\nMetroHash128::test_string = test_string;\n```\n\nIn this code, `std::getenv` is used to get the value of the environment variable `TEST_STRING`. If the environment variable is not set, `std::getenv` returns a null pointer.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This is a standard library in C++ for general purpose functions, including environment variables handling.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS173237"
                ]
              }
            },
            {
              "id": "d0bf2c16-54a3-3e75-b909-a735897a3f4f",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior when using memory copy functions like memcpy. Additionally, there is a risk that the source pointer may be null, as there is no prior check ensuring it is non-null. The destination is not at risk of being null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue. No mitigating factors such as explicit bounds checks, null checks, or overlap guards are present.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. If overlap is possible, use a function that safely handles overlapping regions, such as `memmove`. Additionally, check that the source pointer is not null before copying:\n\n```c\nif (ptr != NULL && ((uintptr_t)&val + sizeof(val) <= (uintptr_t)ptr || (uintptr_t)ptr + sizeof(val) <= (uintptr_t)&val)) {\n    memcpy(&val, ptr, sizeof(val));\n} else if (ptr != NULL) {\n    memmove(&val, ptr, sizeof(val));\n} else {\n    // Handle null pointer error\n}\n```\n\nThis approach ensures that undefined behavior is avoided by using `memmove` when overlap is detected and by checking for null pointers before copying.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b69a0813-329b-3df7-981a-a6e8a48b4f22",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null at runtime, since there is no prior check ensuring it is non-null. The destination is not likely to be null, but the combination of possible overlap and null source pointer makes this a high-confidence issue. The use of a memory copy function without explicit overlap handling can lead to unpredictable results or crashes if the regions overlap.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use a function that is safe for overlapping regions, such as `memmove`, instead of `memcpy`. Additionally, ensure that the source pointer is not null before performing the copy operation. For example:\n\n```c\nif (ptr != NULL) {\n    memmove(&val, ptr, sizeof(val));\n}\n```\nThis change ensures that the copy is performed safely even if the memory regions overlap, and avoids dereferencing a null pointer.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9a8c7a48-ffe5-3758-92ca-e4f8271f9624",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null at runtime, since there is no prior check ensuring it is non-null. The destination is not likely to be null, but the combination of possible overlap and null source pointer makes this a high-confidence, actionable issue. The use of a memory copy function without explicit overlap handling or null pointer checks can lead to unpredictable program behavior, crashes, or security vulnerabilities.\n\n## In Context Remediation\nTo remediate the undefined behavior risk, ensure that the source and destination memory regions do not overlap before performing the memory copy. If overlap is possible, use a function that safely handles overlapping regions, such as `memmove`. Additionally, add a check to ensure the source pointer is not null before copying:\n\n```c\nif (ptr != NULL) {\n    memmove(&val, ptr, sizeof(val));\n} else {\n    // Handle error: source pointer is null\n}\n```\n\nThis approach prevents undefined behavior from both overlapping memory and null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "89770452-c1b3-36f5-95de-ee96ad8a8118",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. The `qsort` function is one such function that can lead to this vulnerability. It is a standard library function in C that performs a quicksort on an array. However, it can be misused in a way that leads to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `qsort` function. In C++, the `std::sort` function from the `<algorithm>` library is a safer and more efficient alternative. It is type-safe and does not require a comparison function as a parameter, reducing the risk of misuse.\n\n## Source Code Fix Recommendation\n\nReplace the `qsort` function with the `std::sort` function. Here is an example of how to do this:\n\n```cpp\n#include <algorithm>\n#include <vector>\n\n// Old code using qsort\n// int compare(const void* a, const void* b);\n// qsort(array, size, sizeof(int), compare);\n\n// New code using std::sort\nstd::vector<int> vec = { /* your data */ };\nstd::sort(vec.begin(), vec.end());\n```\n\n## Library Dependencies\n\nThe `std::sort` function requires the `<algorithm>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d071ede6-a615-3e28-8eec-47dde83636f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nIf `pStrValue` is a pointer to a string, ensure it is null-terminated before passing it to `strlen()`. If the length of the string is known at compile time, consider using `strnlen()` instead.\n\n```cpp\n// Ensure pStrValue is null-terminated\nif (pStrValue != nullptr) {\n    size_t len = strnlen(pStrValue, MAX_LENGTH);\n}\n```\n\nIn this example, `MAX_LENGTH` should be replaced with the maximum expected length of the string. If the string is longer than `MAX_LENGTH`, `strnlen()` will return `MAX_LENGTH`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "07b663dd-4998-3dab-9d16-b5e910aaf96f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "dbde598b-bbac-3c3a-b319-a64a2cd1359f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d811a70a-c533-33e1-bb0c-09c461bfbf18",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `mbstowcs` function in C++ is used to convert a multibyte string to a wide character string. However, it can lead to vulnerabilities if not used properly. The function does not perform any bounds checking on the destination buffer, which can lead to buffer overflow if the source string is longer than the destination buffer. This can lead to arbitrary code execution or denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the converted string, including the null terminator. You should also consider using safer alternatives that perform bounds checking, such as `mbstowcs_s` or `mbsrtowcs`.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use `mbstowcs_s` to safely convert a multibyte string to a wide character string:\n\n```cpp\n#include <locale.h>\n#include <wchar.h>\n#include <stdlib.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.utf8\");\n    const char* mbstr = \"multibyte string\";\n    size_t len = mbstowcs(NULL, mbstr, 0) + 1;\n    wchar_t* wcstr = new wchar_t[len];\n    size_t converted;\n    mbstowcs_s(&converted, wcstr, len, mbstr, _TRUNCATE);\n    // use wcstr\n    delete[] wcstr;\n    return 0;\n}\n```\n\nIn this example, `mbstowcs` is first used to calculate the length of the converted string, then `mbstowcs_s` is used to perform the conversion. The `_TRUNCATE` option ensures that the conversion is safely truncated if the source string is too long.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- locale.h\n- wchar.h\n- stdlib.h\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a2f61dc6-a5e8-30c0-976b-d42f3789f71d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function in question is `atof`.\n\nThe `atof` function converts a string to a double. It does not check for overflow or underflow, and it does not report any errors. This can lead to unexpected behavior if the string cannot be represented as a double.\n\n## Mitigation Advice\n\nAvoid using the `atof` function. Instead, use safer alternatives such as `strtod` or `sscanf`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atof` function with `strtod` or `sscanf`. Here is an example of how to use `strtod`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char* str = \"123.45\";\nchar* endptr;\nerrno = 0; // To distinguish success/failure after call\ndouble val = strtod(str, &endptr);\n\n// Check for various possible errors\nif ((errno == ERANGE && (val == HUGE_VALF || val == HUGE_VALL)) || (errno != 0 && val == 0)) {\n    perror(\"strtod\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == str) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\n// If we got here, strtod() successfully parsed a number\nprintf(\"strtod() returned %f\\n\", val);\n\nif (*endptr != '\\0') // Not necessarily an error...\n    printf(\"Further characters after number: %s\\n\", endptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- cerrno\n- cstdio\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "57a7d2e3-f57d-383a-b7c1-0491cdf0613d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It returns the number of characters in a string up to but not including the first null character. The vulnerability arises when the string does not have a null character, causing `strlen()` to read beyond the intended memory, leading to a buffer overflow. This can result in crashes, incorrect behavior, or allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that are not guaranteed to be null-terminated. Instead, use safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(pDst)` with `strnlen(pDst, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of the string.\n\n```cpp\n#include <string.h>\n\n#define MAX_LENGTH 100\n\n// ...\n\nsize_t length = strnlen(pDst, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strnlen()` function is part of the `<string.h>` library in C++.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "8d5b0678-de8b-3679-b19a-0e801ef17dc4",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "78578e6c-08f6-306e-87f5-e42d103ae268",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncat` function in C++ is considered unsafe because it can lead to buffer overflow vulnerabilities. This function appends the source string to the destination string up to n characters. If the size of the destination buffer is not properly managed, it can lead to buffer overflow, which can cause the program to crash or lead to code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that are available in C++. For example, you can use the `strlcat` function which is designed to be safer, or you can use the string class in C++ which automatically manages the memory.\n\n## Source Code Fix Recommendation\n\nReplace the `strncat` function with `strlcat` function or use C++ string class.\n\n```cpp\n// Using strlcat\nsize_t sizeDst = sizeof(pDst);\nsize_t dstLength = strnlen(pDst, sizeDst);\nif (dstLength == sizeDst) {\n    // Handle error: pDst was not null-terminated.\n} else if (strlcat(pDst, pSrc, sizeDst) >= sizeDst) {\n    // Handle error: pDst is not large enough.\n}\n\n// Using C++ string class\nstd::string dst(pDst);\nstd::string src(pSrc);\ndst += src;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstring` or `string.h` for `strncat` and `strlcat` functions.\n- `string` for C++ string class.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "d1e70db2-6a82-3f7c-a50a-7c2f37bb1ce0",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. One such function is `wcsncat`.\n\nThe `wcsncat` function is a wide-character string function that appends not more than `n` wide-characters from a source string to the end of a destination string. The vulnerability arises when the size of the destination buffer is not properly managed, leading to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `wcsncat` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that include bounds checking such as `wcsncat_s` (in the case of Microsoft's implementation of C++), or use C++ strings (`std::wstring`) which are safer and easier to use.\n\n## Source Code Fix Recommendation\n\nInstead of using `wcsncat`, use `std::wstring`:\n\n```cpp\n#include <string>\n\nint main() {\n    std::wstring str1 = L\"Hello, \";\n    std::wstring str2 = L\"World!\";\n    str1 += str2; // This is safe\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "36f3ad24-c10b-3bb0-9fbd-50310b5cf432",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcsncpy` function is one of these prohibited functions. It is used to copy a certain number of characters from one wide string to another. However, if the source string length is less than the number of characters to be copied, `wcsncpy` does not null-terminate the destination string, which can lead to buffer overflows.\n\n## Mitigation Advice\n\nAvoid using `wcsncpy` and other prohibited C functions. Instead, use safer alternatives that do not have these vulnerabilities. For example, consider using `wcsncpy_s` or `wmemcpy_s` which are safer as they null-terminate the destination string.\n\n## Source Code Fix Recommendation\n\nReplace `wcsncpy` with `wcsncpy_s` or `wmemcpy_s`. Here is an example:\n\n```cpp\n// Old vulnerable code\nwchar_t dest[100];\nwcsncpy(dest, src, 100);\n\n// Fixed code using wcsncpy_s\nwchar_t dest[100];\nwcsncpy_s(dest, 100, src, _TRUNCATE);\n\n// Or using wmemcpy_s\nwchar_t dest[100];\nwmemcpy_s(dest, 100, src, wcsnlen(src, 100));\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <wchar.h>\n```\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4bc2e267-6316-3f5b-9f51-f35e3eda3864",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It takes a string as an argument and returns its length. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be read.\n\n## Source Code Fix Recommendation\n\nIf `pSrc` is the string being passed to `strlen()`, ensure it is null-terminated:\n\n```cpp\nchar pSrc[] = \"Hello, World!\";\nsize_t len = strlen(pSrc);\n```\n\nOr use `strnlen()` instead:\n\n```cpp\nchar pSrc[] = \"Hello, World!\";\nsize_t len = strnlen(pSrc, sizeof(pSrc));\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "e5ba16e9-a75c-31ec-afa8-b03f70aa91c1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflows. This function copies a string from one location to another, but it does not automatically append a null character at the end of the string. If the source string is longer than the destination buffer, this can lead to buffer overflow, which can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source string and the null character. You should also consider using safer string handling functions that automatically handle null termination, such as `strlcpy` or `strncpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `strncpy_s`:\n\n```cpp\n// Using strlcpy\nstrlcpy(pDst, pSrc, dstSize);\n\n// Using strncpy_s\nstrncpy_s(pDst, dstSize, pSrc, _TRUNCATE);\n```\n\nNote: `strlcpy` and `strncpy_s` are not standard C++ functions and may not be available on all platforms. If they are not available, you can manually ensure null termination:\n\n```cpp\nstrncpy(pDst, pSrc, dstSize - 1);\npDst[dstSize - 1] = '\\0';\n```\n\n## Library Dependencies\n\nThe `strncpy`, `strlcpy`, and `strncpy_s` functions are part of the C standard library, so you need to include the `cstring` or `string.h` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "6205dddd-9c29-3789-b9d2-eb64d456ac07",
              "help": {
                "text": "",
                "markdown": "## Description\n\nProduction Code Debugging Vulnerability in C++ refers to the situation where debugging code or debugging commands are inadvertently left in the production code. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. Debugging code often contains sensitive information or functionality that should not be exposed in a production environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always remove debugging code or commands before deploying to production.\n2. Use preprocessor directives to ensure debugging code is not included in the production build.\n3. Regularly review and audit your code to ensure no debugging code has been left in.\n4. Use automated tools to check for common debugging commands or code snippets.\n\n## Source Code Fix Recommendation\n\nIf you have a piece of code like this:\n\n```cpp\n#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\nYou should remove or comment out the `#define DEBUG` line before deploying to production:\n\n```cpp\n//#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\n## Library Dependencies\n\nThe code example provided does not require any additional library dependencies.\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "5e2b503b-b13d-3914-9311-bd5279b3bb85",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(s)` function in C++ is used to calculate the length of a string. The vulnerability arises when the string `s` is not null-terminated, which can lead to buffer overflows, memory corruption, and other unexpected behavior. This is because `strlen(s)` counts characters until it reaches a null character, and if there is no null character, it will continue reading memory beyond the intended boundary.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your string after it has been modified.\n\nAdditionally, consider using safer alternatives to `strlen(s)`, such as `strnlen(s, max_len)`, which takes a maximum length parameter and will not read beyond this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar s[] = \"Hello, World!\";\nint len = strlen(s);\n```\n\nUse:\n\n```cpp\nchar s[] = \"Hello, World!\";\nint max_len = sizeof(s) / sizeof(s[0]);\nint len = strnlen(s, max_len);\n```\n\n## Library Dependencies\n\nThe `strlen(s)` function is part of the C Standard Library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "3720f95f-2b47-336c-abef-04477ffca7b9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m_pData, vector.m_pData, sizeof(T))`, there is no check to ensure that the size of `vector.m_pData` is not larger than `m_pData`. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(vector.m_pData) <= sizeof(m_pData)) {\n    memcpy(m_pData, vector.m_pData, sizeof(T));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `vector.m_pData` is less than or equal to the size of `m_pData`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5417efdf-8173-335c-95df-5bb02e36899d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, which can lead to arbitrary code execution, denial of service, or information disclosure. \n\nIn this case, the `ctime` function is considered insecure. The `ctime` function converts a time_t value into a string, but it does not check for buffer overflows. If an attacker can control the input to the `ctime` function, they can potentially cause a buffer overflow.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking. In the case of `ctime`, a safer alternative is `ctime_r`, which is a reentrant version that takes an additional argument for the result.\n\n## Source Code Fix Recommendation\n\nReplace the `ctime` function with `ctime_r`. Here is an example:\n\n```cpp\n#include <ctime>\n\nvoid print_time(time_t time) {\n    char buffer[26];\n    if (ctime_r(&time, buffer) == NULL) {\n        // Handle error\n    } else {\n        printf(\"%s\\n\", buffer);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<ctime>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9a2abc51-233d-37c6-9a2b-5d5d6a592637",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or code execution vulnerabilities if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, consider using a method that does not involve environment variables to enable logging. If you must use environment variables, ensure that they are properly sanitized and validated before use.\n\n## Source Code Fix Recommendation\n\n```cpp\n// Instead of using getenv(), consider using a configuration file or command line argument to enable logging.\n// If you must use an environment variable, ensure it is properly sanitized and validated.\n\nconst char* env_var = getenv(\"LOADER_ENABLE_LOGGING\");\nif(env_var != NULL) {\n    std::string logging_env(env_var);\n    // Perform sanitization and validation on logging_env before use\n    enable_logging = logging_env;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::string`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "53a5b40b-77b2-330d-beb4-77756f64962d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3b834eca-8160-384f-bb80-08884872c739",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or unauthorized code execution if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking and do not suffer from the same vulnerabilities. In the case of `getenv()`, consider using a method that does not expose sensitive information through environment variables.\n\n## Source Code Fix Recommendation\n\nThe code fix would depend on the specific requirements of your program. If you need to use an environment variable, ensure that it is not controlled by an attacker and that it does not contain sensitive information. If possible, consider using a configuration file or command line arguments instead of environment variables.\n\n```cpp\n// Instead of using getenv(), consider using a configuration file or command line arguments\nchar* options_append = read_config(\"LOADER_OPTIONS_APPEND\");\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library for the `getenv()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "415e3e21-eb4f-3ed5-987a-b9cb4c286d51",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is not known or checked before copying data into it. The code copies the contents of a string (using its size) into a destination pointer without verifying that the destination is large enough to hold the data. There are no explicit checks or guards to ensure the destination buffer is sufficiently sized, and the destination type is a generic pointer, which increases the risk of buffer overflow. The source is a C++ string's internal buffer, which is safe in itself, but the lack of destination size validation is a critical issue. The classification indicates high risk, and the tool's verdict confirms this is a genuine problem.\n\n## In Context Remediation\nBefore copying data, ensure that the destination buffer is large enough to hold the contents being copied. If the size of the destination buffer is not known, you must pass the buffer size as an additional argument and check it against the size of the data to be copied. For example:\n\n```cpp\n// Assume 'value' is a pointer to a buffer and 'value_capacity' is its size in bytes\nif (module_name.size() <= value_capacity) {\n    memcpy(value, module_name.c_str(), module_name.size());\n} else {\n    // Handle error: buffer too small\n}\n```\n\nIf you cannot guarantee the size of the destination buffer, consider using safer alternatives or redesigning the API to always provide the buffer size. Never copy data into a buffer without verifying its capacity.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8a626a34-3fc8-3844-8a21-257cc94f9a8e",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is not known or proven to be sufficient for the number of bytes being copied. The code copies the contents of a string (using its size) into a destination pointer without verifying that the destination is large enough to hold the data. There are no checks or guards in place to ensure that the destination buffer is adequately sized, and the destination type is a generic pointer, which further increases the risk. The source is a C-style string, which is generally safe, but the lack of destination size validation makes this a high-risk operation. There is no evidence of overlap or null pointer dereference, but the main concern is the potential for a buffer overflow due to the unknown size of the destination.\n\n## In Context Remediation\nBefore copying data from the string to the destination buffer, ensure that the destination buffer is large enough to hold the data. If the size of the destination buffer is not known, you must pass the buffer size as an additional argument and check it before performing the copy. For example:\n\n```cpp\n// Assume 'value' is a pointer to a buffer and 'value_capacity' is its size in bytes\nif (symbol_name.size() <= value_capacity) {\n    memcpy(value, symbol_name.c_str(), symbol_name.size());\n} else {\n    // Handle error: buffer too small\n}\n```\n\nIf you cannot guarantee the size of the destination buffer, consider using safer alternatives or redesigning the API to always require the buffer size. Never copy more data than the destination can hold.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "98540b50-ddeb-3234-8601-8a049571dad4",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "78de8fc0-482e-3019-a083-3cf155e027d4",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other security problems. The `getenv` function is one such function. It returns a pointer to a string that is associated with the matched environment variable name. This can lead to security vulnerabilities if the returned string is modified, or if the program does not handle the possibility that `getenv` could return a null pointer if the specified environment variable does not exist.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `getenv` function. Instead, consider using safer alternatives that are less prone to security issues. Always validate and sanitize input, and handle the possibility of null pointers. \n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, you can use a safer alternative like `getenv_s`. Here is an example of how to use it:\n\n```cpp\n#include <stdlib.h>\n\nchar* value;\nsize_t requiredSize;\n\ngetenv_s(&requiredSize, NULL, 0, \"ENV_VAR\");\nif (requiredSize == 0)\n{\n    printf(\"The environment variable does not exist.\\n\");\n}\nelse\n{\n    value = (char*) malloc(requiredSize * sizeof(char));\n    if (value != NULL)\n    {\n        getenv_s(&requiredSize, value, requiredSize, \"ENV_VAR\");\n        printf(\"The value of the environment variable is: %s\\n\", value);\n    }\n    free(value);\n}\n```\n\nIn this code, `getenv_s` is used to safely get the value of an environment variable. It checks if the environment variable exists and handles the possibility of a null pointer.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0827c851-92e2-3585-be90-ba1d0815b2f9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the pointer `pNextGroup` is being copied into `ppNextGroup`, which could potentially lead to a buffer overflow if the size of `ppNextGroup` is less than the size of `pNextGroup`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(ppNextGroup) >= sizeof(pNextGroup)) {\n    memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d4c2e4ec-a343-37ac-b5be-38caa9691c14",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the pointer `pNextGroup` is being used as the size of the destination buffer, which may not be the correct size.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you should replace `sizeof(pNextGroup)` with the actual size of the destination buffer. If `pNextGroup` is a pointer to a buffer of a certain type, you can use `sizeof(*pNextGroup)` to get the size of the buffer. Here is a corrected version of the code:\n\n```cpp\nmemcpy(&pNextGroup, ppNextGroup, sizeof(*pNextGroup));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `cstring` header file in your code:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d777d5c2-2b54-36f5-8125-65921fec5294",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the first null character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum number of characters to read.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(key);\n```\n\nConsider using:\n\n```cpp\nstrnlen(key, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string. This will prevent `strnlen()` from reading beyond the end of the string if it is not null-terminated.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "457717a0-d8f0-300f-941d-0990630f6342",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying the value of `numEntries` into `pNumEntries`. If the size of `numEntries` is larger than the size of `pNumEntries`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(pNumEntries) >= sizeof(numEntries)) {\n    memcpy(pNumEntries, &numEntries, sizeof(numEntries));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `pNumEntries` is larger or equal to the size of `numEntries`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3fbb662f-bb26-39a1-af2a-00dbaf583edd",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible overlap between the source and destination memory regions in a memory copy operation. The destination and source may refer to overlapping memory areas, which can result in undefined behavior when using functions like memcpy. The risk is confirmed by dataflow analysis indicating that the destination and source may share the same underlying memory. There are no explicit checks or guards in the code to prevent this overlap, and the function verdict is marked as genuine. Additionally, there are no null pointer risks for either the source or destination, but the main concern is the potential for undefined behavior due to overlapping memory regions.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove((char *) dst + offset, src, size);\n```\n\n`memmove` ensures that the copy operation works correctly even if the source and destination regions overlap, avoiding undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f9a8d0c3-0e78-3a1c-80a2-6299d04e1a50",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `pNumEntries` is larger than the size of `numEntries`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(*pNumEntries) <= sizeof(numEntries)) {\n    memcpy(&numEntries, pNumEntries, sizeof(numEntries));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed version, we first check if the size of the data pointed to by `pNumEntries` is less than or equal to the size of `numEntries`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in some way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "60bd9445-4d35-34f9-983f-0650fdc68395",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior with functions like memcpy. There are no explicit checks or guards in the code to prevent this overlap, and neither the source nor the destination is null at the call site, so the risk is not mitigated. The destination buffer type is a generic pointer, and the size argument is not derived from a known safe capacity, further increasing the risk. This type of issue can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(buf, buffer, bufferSize);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination memory regions overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bad00dd9-8165-349f-a2ba-9c60ae765844",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m_pData, vector.m_pData, sizeof(T))`, there is no check to ensure that the size of `vector.m_pData` is not larger than `m_pData`. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(vector.m_pData) <= sizeof(m_pData)) {\n    memcpy(m_pData, vector.m_pData, sizeof(T));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `vector.m_pData` is less than or equal to the size of `m_pData`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9d912c9a-bc96-3f86-bfef-409b9d4d4c5e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable program behavior, data corruption, or crashes. There are no explicit checks or guards in the code to prevent this overlap, and the function used (`memcpy`) does not handle overlapping memory safely. Both the source and destination are considered non-null, so null pointer dereference is not a concern here. The risk is specifically due to the potential for overlapping memory regions, which is not handled by the current implementation.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to safely handle overlapping memory. This change ensures that the copy operation will not result in data corruption or crashes, even if the regions overlap.\n\n```cpp\nmemmove(*buf, buffer, bufferSize);\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "cb5c51d4-2a8a-3001-b676-bc94d8b5bcc4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly defined. The use of a generic pointer type for the destination further increases the risk, as it is not possible to verify buffer boundaries. These factors together indicate a high likelihood of a real issue that could result in memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(dest, (const char*) edata->d_buf + offset - coffset, csize);\n```\n\nAdditionally, validate that both the source and destination pointers are not null before performing the copy, and ensure that the size parameter does not exceed the bounds of either buffer. This helps prevent crashes and memory corruption.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7b67ec79-58aa-393f-9b1d-9004735862fb",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` or `strerror_s()`. Also, consider using exception handling for error reporting instead of directly writing error messages to the output.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nchar buf[1024];\nif(strerror_r(errno, buf, sizeof(buf)) == 0) {\n    out << \"Error: \" << msg << \": \" << buf << std::endl;\n} else {\n    out << \"Error: \" << msg << std::endl;\n}\n```\n\n## Library Dependencies\n\n- `<string.h>`: This header file contains declaration of various string handling functions including `strerror_r()`.\n- `<errno.h>`: This header file defines macros for reporting error conditions.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "22f480ac-e07f-3381-af0c-929a9f303569",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, which can lead to arbitrary code execution, denial of service, or information disclosure. \n\nIn this case, the `ctime` function is considered insecure. The `ctime` function converts a time_t value into a string, but it does not check for buffer overflows. If an attacker can control the input to the `ctime` function, they can potentially cause a buffer overflow.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking. In the case of `ctime`, a safer alternative is `ctime_r`, which is a reentrant version that takes an additional argument for the result.\n\n## Source Code Fix Recommendation\n\nReplace the `ctime` function with `ctime_r`. Here is an example:\n\n```cpp\n#include <ctime>\n\nvoid print_time(time_t time) {\n    char buffer[26];\n    if (ctime_r(&time, buffer) == NULL) {\n        // Handle error\n    } else {\n        printf(\"%s\\n\", buffer);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<ctime>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b6266cdf-388a-32b1-a24e-cede5da62cb2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, which can lead to arbitrary code execution, denial of service, or information disclosure. \n\nIn this case, the `ctime` function is considered insecure. The `ctime` function converts a time_t value into a string, but it does not check for buffer overflows. If an attacker can control the input to the `ctime` function, they can potentially cause a buffer overflow.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking. In the case of `ctime`, a safer alternative is `ctime_r`, which is a reentrant version that takes an additional argument for the result.\n\n## Source Code Fix Recommendation\n\nReplace the `ctime` function with `ctime_r`. Here is an example:\n\n```cpp\n#include <ctime>\n\nvoid print_time(time_t time) {\n    char buffer[26];\n    if (ctime_r(&time, buffer) == NULL) {\n        // Handle error\n    } else {\n        printf(\"%s\\n\", buffer);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<ctime>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "14e815ff-e7c8-33f9-9bfb-53bfbe8c4527",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 602,
                  "startColumn": 27,
                  "endLine": 602,
                  "endColumn": 38,
                  "charOffset": 19995,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(str)",
                    "rendered": {
                      "text": "strlen(str)",
                      "markdown": "`strlen(str)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19995,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19995,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "04c068aa-4f2a-3aef-9486-8c422ad093a7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 595,
                  "startColumn": 28,
                  "endLine": 595,
                  "endColumn": 40,
                  "charOffset": 19837,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pStr)",
                    "rendered": {
                      "text": "strlen(pStr)",
                      "markdown": "`strlen(pStr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19837,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pStr, <size of pStr>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19837,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pStr, <size of pStr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b8f3deeb-d402-3d76-b255-a552045fde3d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/devdriver/shared/legacy/core/inc/ddcPlatform.h"
                },
                "region": {
                  "startLine": 504,
                  "startColumn": 4,
                  "endLine": 504,
                  "endColumn": 11,
                  "charOffset": 17092,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "d002c5a3-a1bb-3001-8c8f-2ac1f20b607d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 365,
                  "startColumn": 25,
                  "endLine": 365,
                  "endColumn": 91,
                  "charOffset": 12962,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T)",
                      "markdown": "`memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12962,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(reinterpret_cast<void*>(pData), <size of reinterpret_cast<void*>(pData)>,  m_pData,  m_size * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6c6d7c19-dc3c-3b89-a094-bee9ec7d7d19",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/ddMetroHash.h"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 64,
                  "endLine": 82,
                  "endColumn": 79,
                  "charOffset": 2872,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(pString)",
                    "rendered": {
                      "text": "strlen(pString)",
                      "markdown": "`strlen(pString)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/ddMetroHash.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2872,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/ddMetroHash.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2872,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "296e2250-782f-36e0-9975-0758d87a7518",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 16,
                  "endLine": 145,
                  "endColumn": 57,
                  "charOffset": 5315,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(&m_pData[oldSize], pTs, (sizeof(T)",
                    "rendered": {
                      "text": "memcpy(&m_pData[oldSize], pTs, (sizeof(T)",
                      "markdown": "`memcpy(&m_pData[oldSize], pTs, (sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5315,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&m_pData[oldSize], <size of &m_pData[oldSize]>,  pTs,  (sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1664fdc3-5fa3-3532-8fab-29551e7dcd7d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/hashFunc.h"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 80,
                  "endLine": 57,
                  "endColumn": 92,
                  "charOffset": 2424,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pKey)",
                    "rendered": {
                      "text": "strlen(pKey)",
                      "markdown": "`strlen(pKey)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/hashFunc.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2424,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pKey, <size of pKey>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/hashFunc.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2424,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pKey, <size of pKey>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cf05425e-8e09-34ea-bf47-148d0be1b604",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/string.h"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 33,
                  "endLine": 86,
                  "endColumn": 47,
                  "charOffset": 3250,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(m_data)",
                    "rendered": {
                      "text": "strlen(m_data)",
                      "markdown": "`strlen(m_data)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/string.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3250,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(m_data, <size of m_data>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/util/string.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3250,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(m_data, <size of m_data>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bb18955c-fc95-3b0a-b89f-32abc469a2dd",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/devdriver/shared/legacy/core/inc/ddcPlatform.h"
                },
                "region": {
                  "startLine": 504,
                  "startColumn": 4,
                  "endLine": 504,
                  "endColumn": 11,
                  "charOffset": 17092,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "1c741ce1-17bd-3451-bc77-16e5f02a9030",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 4,
                  "endLine": 51,
                  "endColumn": 33,
                  "charOffset": 1340,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1340,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "56adfc27-0e25-3105-857a-c6a2b1d5ce65",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/loader/executable.hpp"
                },
                "region": {
                  "startLine": 320,
                  "startColumn": 33,
                  "endLine": 320,
                  "endColumn": 39,
                  "charOffset": 10965,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "449099df-f234-3773-903f-01be403cde8c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 4,
                  "endLine": 44,
                  "endColumn": 33,
                  "charOffset": 1186,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1186,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c6181961-5724-3585-97a6-5de2ef6c74ce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 4,
                  "endLine": 37,
                  "endColumn": 33,
                  "charOffset": 1055,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1055,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "96252727-9c04-3b1b-b5ac-57f6d2d4b6fd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 1212,
                  "startColumn": 31,
                  "endLine": 1212,
                  "endColumn": 37,
                  "charOffset": 37450,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3cc99c5a-c964-38ab-ab8a-bb43ac2e0515",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 476,
                  "startColumn": 6,
                  "endLine": 476,
                  "endColumn": 59,
                  "charOffset": 15235,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(value, module_name.c_str(), module_name.size()",
                    "rendered": {
                      "text": "memcpy(value, module_name.c_str(), module_name.size()",
                      "markdown": "`memcpy(value, module_name.c_str(), module_name.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/loader/executable.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15235,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  module_name.c_str(),  module_name.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a3b5f04b-fe2e-305e-88f0-953ec3db0b49",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 467,
                  "startColumn": 6,
                  "endLine": 467,
                  "endColumn": 59,
                  "charOffset": 14944,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(value, symbol_name.c_str(), symbol_name.size()",
                    "rendered": {
                      "text": "memcpy(value, symbol_name.c_str(), symbol_name.size()",
                      "markdown": "`memcpy(value, symbol_name.c_str(), symbol_name.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/loader/executable.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14944,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  symbol_name.c_str(),  symbol_name.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "18c57210-1a22-38b2-bd6a-3050e2728167",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 1442,
                  "startColumn": 45,
                  "endLine": 1442,
                  "endColumn": 51,
                  "charOffset": 56567,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "40f42ee7-08cc-3cf7-8f66-31d3a865769c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 927,
                  "startColumn": 8,
                  "endLine": 927,
                  "endColumn": 46,
                  "charOffset": 37284,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(svalue, isa.c_str(), (std::min)",
                    "rendered": {
                      "text": "memcpy(svalue, isa.c_str(), (std::min)",
                      "markdown": "`memcpy(svalue, isa.c_str(), (std::min)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37284,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svalue, <size of svalue>,  isa.c_str(),  (std::min)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3fd59242-3d6a-377b-8276-da5d907a2874",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 882,
                  "startColumn": 6,
                  "endLine": 882,
                  "endColumn": 70,
                  "charOffset": 35550,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(desc->producer_options, options.c_str(), options.length()",
                    "rendered": {
                      "text": "memcpy(desc->producer_options, options.c_str(), options.length()",
                      "markdown": "`memcpy(desc->producer_options, options.c_str(), options.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35550,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->producer_options, <size of desc->producer_options>,  options.c_str(),  options.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "205eac20-3a2d-3ee2-9501-64b6f5f7ec48",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 863,
                  "startColumn": 6,
                  "endLine": 863,
                  "endColumn": 69,
                  "charOffset": 34685,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy(desc->producer_name, producer.c_str(), producer.length()",
                    "rendered": {
                      "text": "memcpy(desc->producer_name, producer.c_str(), producer.length()",
                      "markdown": "`memcpy(desc->producer_name, producer.c_str(), producer.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34685,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->producer_name, <size of desc->producer_name>,  producer.c_str(),  producer.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "efc27dee-cd4a-3158-a8f9-4eaa327b9851",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 917,
                  "startColumn": 8,
                  "endLine": 917,
                  "endColumn": 50,
                  "charOffset": 36853,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(svalue, version.c_str(), (std::min)",
                    "rendered": {
                      "text": "memcpy(svalue, version.c_str(), (std::min)",
                      "markdown": "`memcpy(svalue, version.c_str(), (std::min)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36853,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svalue, <size of svalue>,  version.c_str(),  (std::min)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a45758a0-6539-399b-bda8-a5c5015c42ca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 541,
                  "startColumn": 6,
                  "endLine": 541,
                  "endColumn": 127,
                  "charOffset": 17819,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()",
                    "rendered": {
                      "text": "memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()",
                      "markdown": "`memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17819,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->vendor_and_architecture_name + desc->vendor_name_size, <size of desc->vendor_and_architecture_name + desc->vendor_name_size>,  architecture_name.c_str(),  architecture_name.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c543cec1-6485-3b05-81f0-be93d15624af",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 540,
                  "startColumn": 6,
                  "endLine": 540,
                  "endColumn": 90,
                  "charOffset": 17722,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()",
                    "rendered": {
                      "text": "memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()",
                      "markdown": "`memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17722,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->vendor_and_architecture_name, <size of desc->vendor_and_architecture_name>,  vendor_name.c_str(),  vendor_name.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0df495ce-6024-3dc4-8617-4c1e73275c73",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 10,
                  "endLine": 148,
                  "endColumn": 61,
                  "charOffset": 4717,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(value, ModuleName.c_str(), ModuleName.size()",
                    "rendered": {
                      "text": "memcpy(value, ModuleName.c_str(), ModuleName.size()",
                      "markdown": "`memcpy(value, ModuleName.c_str(), ModuleName.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4717,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  ModuleName.c_str(),  ModuleName.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "51d100a6-51b6-3350-b187-6fa737449be6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 10,
                  "endLine": 138,
                  "endColumn": 61,
                  "charOffset": 4337,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(value, SymbolName.c_str(), SymbolName.size()",
                    "rendered": {
                      "text": "memcpy(value, SymbolName.c_str(), SymbolName.size()",
                      "markdown": "`memcpy(value, SymbolName.c_str(), SymbolName.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4337,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  SymbolName.c_str(),  SymbolName.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a96fa87d-e449-31f7-a0b8-c53f17748a81",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 602,
                  "startColumn": 27,
                  "endLine": 602,
                  "endColumn": 38,
                  "charOffset": 19995,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(str)",
                    "rendered": {
                      "text": "strlen(str)",
                      "markdown": "`strlen(str)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19995,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19995,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "828ce508-8e52-3f91-b456-fc33bf1263a1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 592,
                  "startColumn": 27,
                  "endLine": 592,
                  "endColumn": 38,
                  "charOffset": 19778,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(str)",
                    "rendered": {
                      "text": "strlen(str)",
                      "markdown": "`strlen(str)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19778,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19778,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2a6c7c73-5a08-374a-911b-7f1edece79fb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 595,
                  "startColumn": 28,
                  "endLine": 595,
                  "endColumn": 40,
                  "charOffset": 19837,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pStr)",
                    "rendered": {
                      "text": "strlen(pStr)",
                      "markdown": "`strlen(pStr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19837,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pStr, <size of pStr>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19837,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pStr, <size of pStr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0af28950-e54e-3ae3-8bdc-5bb20bc51b5d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 585,
                  "startColumn": 28,
                  "endLine": 585,
                  "endColumn": 40,
                  "charOffset": 19620,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pStr)",
                    "rendered": {
                      "text": "strlen(pStr)",
                      "markdown": "`strlen(pStr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19620,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pStr, <size of pStr>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19620,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pStr, <size of pStr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0ba32af8-75d6-3dfe-b5eb-b30be84d7f2b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 365,
                  "startColumn": 25,
                  "endLine": 365,
                  "endColumn": 91,
                  "charOffset": 12962,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T)",
                      "markdown": "`memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12962,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(reinterpret_cast<void*>(pData), <size of reinterpret_cast<void*>(pData)>,  m_pData,  m_size * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c6a48e48-4ca7-3808-8dba-14fb5d55fe77",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 363,
                  "startColumn": 25,
                  "endLine": 363,
                  "endColumn": 91,
                  "charOffset": 12927,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T)",
                      "markdown": "`memcpy(reinterpret_cast<void*>(pData), m_pData, m_size * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12927,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(reinterpret_cast<void*>(pData), <size of reinterpret_cast<void*>(pData)>,  m_pData,  m_size * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1cf5a7a4-adb0-3ea1-919e-e6d553c2cab9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 16,
                  "endLine": 143,
                  "endColumn": 57,
                  "charOffset": 5280,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(&m_pData[oldSize], pTs, (sizeof(T)",
                    "rendered": {
                      "text": "memcpy(&m_pData[oldSize], pTs, (sizeof(T)",
                      "markdown": "`memcpy(&m_pData[oldSize], pTs, (sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5280,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&m_pData[oldSize], <size of &m_pData[oldSize]>,  pTs,  (sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "418461b2-e047-329f-b5f6-b0b04d1ca307",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 16,
                  "endLine": 145,
                  "endColumn": 57,
                  "charOffset": 5315,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(&m_pData[oldSize], pTs, (sizeof(T)",
                    "rendered": {
                      "text": "memcpy(&m_pData[oldSize], pTs, (sizeof(T)",
                      "markdown": "`memcpy(&m_pData[oldSize], pTs, (sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/vector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5315,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&m_pData[oldSize], <size of &m_pData[oldSize]>,  pTs,  (sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1a65832e-c273-37eb-b2bd-29496d7b1319",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/ddMetroHash.h"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 64,
                  "endLine": 82,
                  "endColumn": 79,
                  "charOffset": 2872,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(pString)",
                    "rendered": {
                      "text": "strlen(pString)",
                      "markdown": "`strlen(pString)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/ddMetroHash.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2872,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/ddMetroHash.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2872,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d3b1d17e-a6ed-3b44-94e9-93704904996a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/hashFunc.h"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 80,
                  "endLine": 57,
                  "endColumn": 92,
                  "charOffset": 2424,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pKey)",
                    "rendered": {
                      "text": "strlen(pKey)",
                      "markdown": "`strlen(pKey)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/hashFunc.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2424,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pKey, <size of pKey>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/hashFunc.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2424,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pKey, <size of pKey>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0ed4f90f-5c05-3493-b522-ffa726cc6432",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/loader/loaders.cpp"
                },
                "region": {
                  "startLine": 213,
                  "startColumn": 4,
                  "endLine": 213,
                  "endColumn": 44,
                  "charOffset": 6729,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy((char *) dst + offset, src, size)",
                    "rendered": {
                      "text": "memcpy((char *) dst + offset, src, size)",
                      "markdown": "`memcpy((char *) dst + offset, src, size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/loader/loaders.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6729,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s((char *) dst + offset, <size of (char *) dst + offset>,  src,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "044ef33d-c15d-3959-8a32-dcd697ea1899",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/string.h"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 33,
                  "endLine": 86,
                  "endColumn": 47,
                  "charOffset": 3250,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(m_data)",
                    "rendered": {
                      "text": "strlen(m_data)",
                      "markdown": "`strlen(m_data)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/string.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3250,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(m_data, <size of m_data>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/util/string.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3250,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(m_data, <size of m_data>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3c199c27-0ee1-38f1-8fbe-93c048fec2c4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 1548,
                  "startColumn": 8,
                  "endLine": 1548,
                  "endColumn": 39,
                  "charOffset": 55012,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(buf, buffer, bufferSize)",
                    "rendered": {
                      "text": "memcpy(buf, buffer, bufferSize)",
                      "markdown": "`memcpy(buf, buffer, bufferSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55012,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf, <size of buf>,  buffer,  bufferSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a8b62123-502e-32e3-8557-585aa866e46b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 1536,
                  "startColumn": 8,
                  "endLine": 1536,
                  "endColumn": 40,
                  "charOffset": 54707,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(*buf, buffer, bufferSize)",
                    "rendered": {
                      "text": "memcpy(*buf, buffer, bufferSize)",
                      "markdown": "`memcpy(*buf, buffer, bufferSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 54707,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(*buf, <size of *buf>,  buffer,  bufferSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "acf2911c-0eb8-3ceb-96df-be78cb82d49c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 998,
                  "startColumn": 10,
                  "endLine": 998,
                  "endColumn": 76,
                  "charOffset": 37537,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)",
                    "rendered": {
                      "text": "memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)",
                      "markdown": "`memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37537,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  (const char*) edata->d_buf + offset - coffset,  csize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "673c5931-33c5-3ff4-b6a9-94c2d3e542ec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/ddMetroHash.h"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 64,
                  "endLine": 82,
                  "endColumn": 79,
                  "charOffset": 2872,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(pString)",
                    "rendered": {
                      "text": "strlen(pString)",
                      "markdown": "`strlen(pString)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/ddMetroHash.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2872,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/ddMetroHash.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2872,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f02ecc06-d5b0-30ac-b862-b3b3f272cb81",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 41,
                  "endLine": 150,
                  "endColumn": 49,
                  "charOffset": 4364,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e1cc7dae-ac8b-397e-be05-7c8041eeda58",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 78,
                  "endLine": 253,
                  "endColumn": 110,
                  "charOffset": 8126,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8126,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8126,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8634c293-c881-305e-bae8-b0b20d9c8362",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 412,
                  "startColumn": 4,
                  "endLine": 412,
                  "endColumn": 25,
                  "charOffset": 12773,
                  "charLength": 21,
                  "snippet": {
                    "text": "memcpy(out, &hash, 8)",
                    "rendered": {
                      "text": "memcpy(out, &hash, 8)",
                      "markdown": "`memcpy(out, &hash, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12773,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &hash,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "315ff47c-2d51-3899-88f5-e37d899a072d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 4,
                  "endLine": 335,
                  "endColumn": 25,
                  "charOffset": 10513,
                  "charLength": 21,
                  "snippet": {
                    "text": "memcpy(out, &hash, 8)",
                    "rendered": {
                      "text": "memcpy(out, &hash, 8)",
                      "markdown": "`memcpy(out, &hash, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10513,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &hash,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bc614cf3-a22b-368c-a46e-2ace8fae15ee",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 248,
                  "startColumn": 78,
                  "endLine": 248,
                  "endColumn": 110,
                  "charOffset": 7891,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7891,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7891,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a5cbdfa6-c2ee-3acf-aa92-d43863f3fe00",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 27,
                  "endLine": 241,
                  "endColumn": 59,
                  "charOffset": 7608,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7608,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7608,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e95eec92-2183-305d-ac17-bbb7fa568a1d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 27,
                  "endLine": 238,
                  "endColumn": 59,
                  "charOffset": 7466,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7466,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7466,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b3caeb58-51a2-3ad0-9415-1101e9abd166",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 4,
                  "endLine": 228,
                  "endColumn": 23,
                  "charOffset": 7222,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(hash, &h, 8)",
                    "rendered": {
                      "text": "memcpy(hash, &h, 8)",
                      "markdown": "`memcpy(hash, &h, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7222,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  &h,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0ab9d556-cc0f-3191-8c2b-feddec41ca30",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 8,
                  "endLine": 94,
                  "endColumn": 59,
                  "charOffset": 3199,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(input.b, ptr, static_cast<size_t>(end - ptr)",
                    "rendered": {
                      "text": "memcpy(input.b, ptr, static_cast<size_t>(end - ptr)",
                      "markdown": "`memcpy(input.b, ptr, static_cast<size_t>(end - ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3199,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b, <size of input.b>,  ptr,  static_cast<size_t>(end - ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d6b9c6ca-3a0e-3340-9bf8-207aad9a3c54",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 156,
                  "startColumn": 4,
                  "endLine": 156,
                  "endColumn": 28,
                  "charOffset": 5180,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(hash, state.v, 8)",
                    "rendered": {
                      "text": "memcpy(hash, state.v, 8)",
                      "markdown": "`memcpy(hash, state.v, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5180,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  state.v,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4dfdc83a-3253-34df-8890-f2c5221469ab",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 8,
                  "endLine": 67,
                  "endColumn": 69,
                  "charOffset": 1849,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                    "rendered": {
                      "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                      "markdown": "`memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1849,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b + (bytes % 32), <size of input.b + (bytes % 32)>,  ptr,  static_cast<size_t>(fill)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f1571809-9fbb-38f2-b96e-861e18fffc55",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 40,
                  "endLine": 27,
                  "endColumn": 105,
                  "charOffset": 833,
                  "charLength": 65,
                  "snippet": {
                    "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                    "rendered": {
                      "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                      "markdown": "`\"012345678901234567890123456789012345678901234567890123456789012\"`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "af6fbe1e-3001-39b4-a16c-f6a9ee976893",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/hashFunc.h"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 80,
                  "endLine": 57,
                  "endColumn": 92,
                  "charOffset": 2424,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pKey)",
                    "rendered": {
                      "text": "strlen(pKey)",
                      "markdown": "`strlen(pKey)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/hashFunc.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2424,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pKey, <size of pKey>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/hashFunc.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2424,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pKey, <size of pKey>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3a5c9724-6122-325f-881c-9e98de8e1d78",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/string.h"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 33,
                  "endLine": 86,
                  "endColumn": 47,
                  "charOffset": 3250,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(m_data)",
                    "rendered": {
                      "text": "strlen(m_data)",
                      "markdown": "`strlen(m_data)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/string.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3250,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(m_data, <size of m_data>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/util/string.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3250,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(m_data, <size of m_data>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6561899d-4e18-3c17-b2a1-0d61d2edef2b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/testvector.h"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 25,
                  "endLine": 38,
                  "endColumn": 98,
                  "charOffset": 1148,
                  "charLength": 73,
                  "snippet": {
                    "text": "key_63 = \"012345678901234567890123456789012345678901234567890123456789012",
                    "rendered": {
                      "text": "key_63 = \"012345678901234567890123456789012345678901234567890123456789012",
                      "markdown": "`key_63 = \"012345678901234567890123456789012345678901234567890123456789012`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "0782a094-36ba-3a80-adeb-8c51826dd641",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 4,
                  "endLine": 175,
                  "endColumn": 22,
                  "charOffset": 5745,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5745,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "607854de-c3bf-3114-a1b6-b68d6df458e5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 4,
                  "endLine": 99,
                  "endColumn": 22,
                  "charOffset": 3269,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3269,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8f681894-d137-3347-8da1-e460ff5050e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 79,
                  "endLine": 256,
                  "endColumn": 112,
                  "charOffset": 9344,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9344,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9344,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "36d75394-86a7-39cb-b1ac-7a5b4d317783",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 416,
                  "startColumn": 4,
                  "endLine": 416,
                  "endColumn": 22,
                  "charOffset": 14782,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14782,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "554de136-ebc2-3a03-971c-3a11489ddf1f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 338,
                  "startColumn": 4,
                  "endLine": 338,
                  "endColumn": 22,
                  "charOffset": 12127,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12127,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "36120805-5a7e-30e0-941c-635ce6a4047b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 251,
                  "startColumn": 79,
                  "endLine": 251,
                  "endColumn": 112,
                  "charOffset": 9105,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9105,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9105,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a86525c7-6792-3940-b465-1dadc3d9c487",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 244,
                  "startColumn": 28,
                  "endLine": 244,
                  "endColumn": 61,
                  "charOffset": 8817,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8817,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8817,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "54616ee2-74aa-3709-b44a-7eb11251f0a8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 28,
                  "endLine": 241,
                  "endColumn": 61,
                  "charOffset": 8671,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8671,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8671,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1e3d181f-6bf0-3a4b-862e-8a52e7a5ad0b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 231,
                  "startColumn": 4,
                  "endLine": 231,
                  "endColumn": 23,
                  "charOffset": 8423,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(hash, v, 16)",
                    "rendered": {
                      "text": "memcpy(hash, v, 16)",
                      "markdown": "`memcpy(hash, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8423,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "de28de6a-f5c4-382a-9fc4-edc0b041f1b1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 4,
                  "endLine": 158,
                  "endColumn": 29,
                  "charOffset": 5932,
                  "charLength": 25,
                  "snippet": {
                    "text": "memcpy(hash, state.v, 16)",
                    "rendered": {
                      "text": "memcpy(hash, state.v, 16)",
                      "markdown": "`memcpy(hash, state.v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5932,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  state.v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c7b55bf0-4571-3b9f-9a4c-5cc28ea61be0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 8,
                  "endLine": 98,
                  "endColumn": 39,
                  "charOffset": 3656,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(input.b, ptr, end - ptr)",
                    "rendered": {
                      "text": "memcpy(input.b, ptr, end - ptr)",
                      "markdown": "`memcpy(input.b, ptr, end - ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3656,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b, <size of input.b>,  ptr,  end - ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ae6d8892-2aa1-3014-83aa-8496525cdb83",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 8,
                  "endLine": 71,
                  "endColumn": 69,
                  "charOffset": 2327,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                    "rendered": {
                      "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                      "markdown": "`memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2327,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b + (bytes % 32), <size of input.b + (bytes % 32)>,  ptr,  static_cast<size_t>(fill)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "775d7b6a-77db-323b-908d-f2fda678fda8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 41,
                  "endLine": 26,
                  "endColumn": 106,
                  "charOffset": 836,
                  "charLength": 65,
                  "snippet": {
                    "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                    "rendered": {
                      "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                      "markdown": "`\"012345678901234567890123456789012345678901234567890123456789012\"`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "81677694-58e8-3e4b-87cf-b1bdcb899d6d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/devdriver/shared/legacy/core/inc/ddcPlatform.h"
                },
                "region": {
                  "startLine": 517,
                  "startColumn": 4,
                  "endLine": 517,
                  "endColumn": 11,
                  "charOffset": 17349,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "efd34705-397d-3edb-a540-a263b04c6e50",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1562,
                  "startColumn": 4,
                  "endLine": 1562,
                  "endColumn": 9,
                  "charOffset": 51265,
                  "charLength": 5,
                  "snippet": {
                    "text": "qsort",
                    "rendered": {
                      "text": "qsort",
                      "markdown": "`qsort`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3f28809a-59d9-3416-af4f-45d3bbc8c282",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1523,
                  "startColumn": 11,
                  "endLine": 1523,
                  "endColumn": 17,
                  "charOffset": 49870,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "dcc69853-8cd0-3e6a-86b1-1a1d27eba18d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1389,
                  "startColumn": 8,
                  "endLine": 1389,
                  "endColumn": 14,
                  "charOffset": 46065,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bd2497c8-124c-3e6a-8b8e-13f08d345f78",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1337,
                  "startColumn": 21,
                  "endLine": 1337,
                  "endColumn": 29,
                  "charOffset": 44512,
                  "charLength": 8,
                  "snippet": {
                    "text": "mbstowcs",
                    "rendered": {
                      "text": "mbstowcs",
                      "markdown": "`mbstowcs`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0dc0d5d1-db82-34b6-85c7-94baee06983c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1072,
                  "startColumn": 23,
                  "endLine": 1072,
                  "endColumn": 40,
                  "charOffset": 35538,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(pStrValue)",
                    "rendered": {
                      "text": "strlen(pStrValue)",
                      "markdown": "`strlen(pStrValue)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35538,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(pStrValue, <size of pStrValue>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35538,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(pStrValue, <size of pStrValue>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "18b7a1ef-9e54-3560-8965-a7c274267012",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1043,
                  "startColumn": 60,
                  "endLine": 1043,
                  "endColumn": 64,
                  "charOffset": 34371,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cfcb1335-dd49-35c3-84e0-94d60d82a839",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1016,
                  "startColumn": 42,
                  "endLine": 1016,
                  "endColumn": 46,
                  "charOffset": 33145,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5cb85615-ab6a-31d9-8e2c-757b29c46957",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 967,
                  "startColumn": 29,
                  "endLine": 967,
                  "endColumn": 41,
                  "charOffset": 31562,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pDst)",
                    "rendered": {
                      "text": "strlen(pDst)",
                      "markdown": "`strlen(pDst)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31562,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pDst, <size of pDst>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31562,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pDst, <size of pDst>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "46e2d68e-426a-3048-b85e-f01421e9076d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncat)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 968,
                  "startColumn": 4,
                  "endLine": 968,
                  "endColumn": 50,
                  "charOffset": 31580,
                  "charLength": 46,
                  "snippet": {
                    "text": "strncat(pDst, pSrc, (sizeDst - dstLength - 1))",
                    "rendered": {
                      "text": "strncat(pDst, pSrc, (sizeDst - dstLength - 1))",
                      "markdown": "`strncat(pDst, pSrc, (sizeDst - dstLength - 1))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31580,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strcat_s(pDst,  (sizeDst - dstLength - 1,  pSrc)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31580,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strlcat(pDst,  pSrc,  (sizeDst - dstLength - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d479c29b-2771-3785-86f1-1eafd827d1ed",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 948,
                  "startColumn": 4,
                  "endLine": 948,
                  "endColumn": 11,
                  "charOffset": 30750,
                  "charLength": 7,
                  "snippet": {
                    "text": "wcsncat",
                    "rendered": {
                      "text": "wcsncat",
                      "markdown": "`wcsncat`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b3b94754-8355-30fa-ae1f-1cfdf721771d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 947,
                  "startColumn": 31,
                  "endLine": 947,
                  "endColumn": 37,
                  "charOffset": 30732,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4517ca83-ccfb-3f9d-9aa7-02b562597bfd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 933,
                  "startColumn": 4,
                  "endLine": 933,
                  "endColumn": 11,
                  "charOffset": 30377,
                  "charLength": 7,
                  "snippet": {
                    "text": "wcsncpy",
                    "rendered": {
                      "text": "wcsncpy",
                      "markdown": "`wcsncpy`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7e61ac96-db2d-3e4d-aedd-fd3edffa3fcb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 910,
                  "startColumn": 14,
                  "endLine": 910,
                  "endColumn": 26,
                  "charOffset": 29664,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pSrc)",
                    "rendered": {
                      "text": "strlen(pSrc)",
                      "markdown": "`strlen(pSrc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29664,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pSrc, <size of pSrc>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29664,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pSrc, <size of pSrc>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a07e0391-1fc1-3da9-bbdb-bc6c30f91d8c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 918,
                  "startColumn": 8,
                  "endLine": 918,
                  "endColumn": 42,
                  "charOffset": 29902,
                  "charLength": 34,
                  "snippet": {
                    "text": "strncpy(pDst, pSrc, (dstSize - 1))",
                    "rendered": {
                      "text": "strncpy(pDst, pSrc, (dstSize - 1))",
                      "markdown": "`strncpy(pDst, pSrc, (dstSize - 1))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29902,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strcpy_s(pDst,  (dstSize - 1,  pSrc)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29902,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strlcpy(pDst,  pSrc,  (dstSize - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bd5d3a33-72bb-3290-b3ab-c7943d24f9ff",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 1442,
                  "startColumn": 45,
                  "endLine": 1442,
                  "endColumn": 51,
                  "charOffset": 56567,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3feca8a5-d11f-3fc2-822b-b243311c1ca8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 927,
                  "startColumn": 8,
                  "endLine": 927,
                  "endColumn": 46,
                  "charOffset": 37284,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(svalue, isa.c_str(), (std::min)",
                    "rendered": {
                      "text": "memcpy(svalue, isa.c_str(), (std::min)",
                      "markdown": "`memcpy(svalue, isa.c_str(), (std::min)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37284,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svalue, <size of svalue>,  isa.c_str(),  (std::min)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bb2bf0fb-3cb1-3433-bebf-3237240042f6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 882,
                  "startColumn": 6,
                  "endLine": 882,
                  "endColumn": 70,
                  "charOffset": 35550,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(desc->producer_options, options.c_str(), options.length()",
                    "rendered": {
                      "text": "memcpy(desc->producer_options, options.c_str(), options.length()",
                      "markdown": "`memcpy(desc->producer_options, options.c_str(), options.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35550,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->producer_options, <size of desc->producer_options>,  options.c_str(),  options.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f023fa97-adeb-35a3-a647-670a919f583c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 863,
                  "startColumn": 6,
                  "endLine": 863,
                  "endColumn": 69,
                  "charOffset": 34685,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy(desc->producer_name, producer.c_str(), producer.length()",
                    "rendered": {
                      "text": "memcpy(desc->producer_name, producer.c_str(), producer.length()",
                      "markdown": "`memcpy(desc->producer_name, producer.c_str(), producer.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34685,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->producer_name, <size of desc->producer_name>,  producer.c_str(),  producer.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bd306526-e36b-3f8b-81d2-224c6f1b0ee8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 917,
                  "startColumn": 8,
                  "endLine": 917,
                  "endColumn": 50,
                  "charOffset": 36853,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(svalue, version.c_str(), (std::min)",
                    "rendered": {
                      "text": "memcpy(svalue, version.c_str(), (std::min)",
                      "markdown": "`memcpy(svalue, version.c_str(), (std::min)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36853,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svalue, <size of svalue>,  version.c_str(),  (std::min)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bffdaaa1-76ab-3e95-8a13-940540c1e318",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 541,
                  "startColumn": 6,
                  "endLine": 541,
                  "endColumn": 127,
                  "charOffset": 17819,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()",
                    "rendered": {
                      "text": "memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()",
                      "markdown": "`memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17819,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->vendor_and_architecture_name + desc->vendor_name_size, <size of desc->vendor_and_architecture_name + desc->vendor_name_size>,  architecture_name.c_str(),  architecture_name.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e97a9f54-b3fd-3837-8d76-9c24aa2f005e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 540,
                  "startColumn": 6,
                  "endLine": 540,
                  "endColumn": 90,
                  "charOffset": 17722,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()",
                    "rendered": {
                      "text": "memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()",
                      "markdown": "`memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17722,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->vendor_and_architecture_name, <size of desc->vendor_and_architecture_name>,  vendor_name.c_str(),  vendor_name.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c276a637-1fea-3d59-bcc6-51fec0424bc3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 10,
                  "endLine": 148,
                  "endColumn": 61,
                  "charOffset": 4717,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(value, ModuleName.c_str(), ModuleName.size()",
                    "rendered": {
                      "text": "memcpy(value, ModuleName.c_str(), ModuleName.size()",
                      "markdown": "`memcpy(value, ModuleName.c_str(), ModuleName.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4717,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  ModuleName.c_str(),  ModuleName.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a0ab131c-9069-335d-b9ef-ad039e54e2a0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 10,
                  "endLine": 138,
                  "endColumn": 61,
                  "charOffset": 4337,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(value, SymbolName.c_str(), SymbolName.size()",
                    "rendered": {
                      "text": "memcpy(value, SymbolName.c_str(), SymbolName.size()",
                      "markdown": "`memcpy(value, SymbolName.c_str(), SymbolName.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4337,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  SymbolName.c_str(),  SymbolName.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cc08d729-4e18-30be-a720-be0fd51c8bd0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Code Debugging Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/shared/devdriver/shared/legacy/inc/gpuopen.h"
                },
                "region": {
                  "startLine": 458,
                  "startColumn": 9,
                  "endLine": 458,
                  "endColumn": 18,
                  "charOffset": 27919,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "70dfece4-c1c5-3ece-a237-5b2c783e0672",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palFile.h"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 46,
                  "endLine": 101,
                  "endColumn": 51,
                  "charOffset": 4300,
                  "charLength": 5,
                  "snippet": {
                    "text": "ctime",
                    "rendered": {
                      "text": "ctime",
                      "markdown": "`ctime`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "330ed6e0-61f4-3da3-b48e-8801f2040e76",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palVector.h"
                },
                "region": {
                  "startLine": 432,
                  "startColumn": 17,
                  "endLine": 432,
                  "endColumn": 58,
                  "charOffset": 18721,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(m_pData, vector.m_pData, sizeof(T)",
                    "rendered": {
                      "text": "memcpy(m_pData, vector.m_pData, sizeof(T)",
                      "markdown": "`memcpy(m_pData, vector.m_pData, sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palVector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18721,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_pData, <size of m_pData>,  vector.m_pData,  sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cbe03168-05b7-3fe0-8b9d-7eda8bb02244",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palFile.h"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 46,
                  "endLine": 97,
                  "endColumn": 51,
                  "charOffset": 3986,
                  "charLength": 5,
                  "snippet": {
                    "text": "ctime",
                    "rendered": {
                      "text": "ctime",
                      "markdown": "`ctime`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "216f6fbd-5dce-3256-84f2-3f8f2f62559f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palStringUtil.h"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 27,
                  "endLine": 184,
                  "endColumn": 33,
                  "charOffset": 7010,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "64965a36-9aa3-3a47-8307-22726c8897f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palStringUtil.h"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 27,
                  "endLine": 158,
                  "endColumn": 42,
                  "charOffset": 6353,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(pString)",
                    "rendered": {
                      "text": "strlen(pString)",
                      "markdown": "`strlen(pString)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palStringUtil.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6353,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palStringUtil.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6353,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "039db223-e427-388a-9524-2bd71bc1d070",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 412,
                  "startColumn": 4,
                  "endLine": 412,
                  "endColumn": 25,
                  "charOffset": 12773,
                  "charLength": 21,
                  "snippet": {
                    "text": "memcpy(out, &hash, 8)",
                    "rendered": {
                      "text": "memcpy(out, &hash, 8)",
                      "markdown": "`memcpy(out, &hash, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12773,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &hash,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a2a55aa4-63a3-3581-a057-3b37db7cc643",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 78,
                  "endLine": 253,
                  "endColumn": 110,
                  "charOffset": 8126,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8126,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8126,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0034256f-25c3-3bd3-a534-473323286eca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 4,
                  "endLine": 335,
                  "endColumn": 25,
                  "charOffset": 10513,
                  "charLength": 21,
                  "snippet": {
                    "text": "memcpy(out, &hash, 8)",
                    "rendered": {
                      "text": "memcpy(out, &hash, 8)",
                      "markdown": "`memcpy(out, &hash, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10513,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &hash,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fcd8bbb9-1aec-3aa1-9a70-af78fe33e42b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 248,
                  "startColumn": 78,
                  "endLine": 248,
                  "endColumn": 110,
                  "charOffset": 7891,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7891,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7891,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cc53f7e7-6a0e-3fdf-a425-d3cf5cf2a638",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 27,
                  "endLine": 241,
                  "endColumn": 59,
                  "charOffset": 7608,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7608,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7608,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fd02be80-d618-31f0-83d8-47275feb8d97",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 27,
                  "endLine": 238,
                  "endColumn": 59,
                  "charOffset": 7466,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7466,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7466,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "caebf481-db3b-30c5-b03c-427a63f73d9f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 4,
                  "endLine": 228,
                  "endColumn": 23,
                  "charOffset": 7222,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(hash, &h, 8)",
                    "rendered": {
                      "text": "memcpy(hash, &h, 8)",
                      "markdown": "`memcpy(hash, &h, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7222,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  &h,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "83ca735c-4206-3b43-a2cc-60a87106d1d9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 156,
                  "startColumn": 4,
                  "endLine": 156,
                  "endColumn": 28,
                  "charOffset": 5180,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(hash, state.v, 8)",
                    "rendered": {
                      "text": "memcpy(hash, state.v, 8)",
                      "markdown": "`memcpy(hash, state.v, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5180,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  state.v,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0722109d-2b1c-3d91-91af-574a7cca8c86",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 8,
                  "endLine": 94,
                  "endColumn": 59,
                  "charOffset": 3199,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(input.b, ptr, static_cast<size_t>(end - ptr)",
                    "rendered": {
                      "text": "memcpy(input.b, ptr, static_cast<size_t>(end - ptr)",
                      "markdown": "`memcpy(input.b, ptr, static_cast<size_t>(end - ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3199,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b, <size of input.b>,  ptr,  static_cast<size_t>(end - ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "072c6b54-21eb-3927-a0a0-1c00be8036f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 8,
                  "endLine": 67,
                  "endColumn": 69,
                  "charOffset": 1849,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                    "rendered": {
                      "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                      "markdown": "`memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1849,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b + (bytes % 32), <size of input.b + (bytes % 32)>,  ptr,  static_cast<size_t>(fill)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "228c1883-2d8c-3d81-bb95-b4b33fe39a13",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 40,
                  "endLine": 27,
                  "endColumn": 105,
                  "charOffset": 833,
                  "charLength": 65,
                  "snippet": {
                    "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                    "rendered": {
                      "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                      "markdown": "`\"012345678901234567890123456789012345678901234567890123456789012\"`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "12f2c581-da9c-374d-94b7-c4f5373b4157",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/testvector.h"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 25,
                  "endLine": 38,
                  "endColumn": 98,
                  "charOffset": 1148,
                  "charLength": 73,
                  "snippet": {
                    "text": "key_63 = \"012345678901234567890123456789012345678901234567890123456789012",
                    "rendered": {
                      "text": "key_63 = \"012345678901234567890123456789012345678901234567890123456789012",
                      "markdown": "`key_63 = \"012345678901234567890123456789012345678901234567890123456789012`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "a1e76268-1ade-3948-be17-bb1520e4bf60",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 4,
                  "endLine": 175,
                  "endColumn": 22,
                  "charOffset": 5745,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5745,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0cfd4175-2f0f-39c6-bc06-c3896e02e982",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 4,
                  "endLine": 99,
                  "endColumn": 22,
                  "charOffset": 3269,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3269,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bb760f13-5082-39e3-b482-c4a1f7f6e77d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1562,
                  "startColumn": 4,
                  "endLine": 1562,
                  "endColumn": 9,
                  "charOffset": 51229,
                  "charLength": 5,
                  "snippet": {
                    "text": "qsort",
                    "rendered": {
                      "text": "qsort",
                      "markdown": "`qsort`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "14547da1-a929-32d9-94a5-57fdee039bc9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1523,
                  "startColumn": 11,
                  "endLine": 1523,
                  "endColumn": 17,
                  "charOffset": 49834,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1c232ed6-4581-31d2-8376-b4c3daa5394f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1072,
                  "startColumn": 23,
                  "endLine": 1072,
                  "endColumn": 40,
                  "charOffset": 35502,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(pStrValue)",
                    "rendered": {
                      "text": "strlen(pStrValue)",
                      "markdown": "`strlen(pStrValue)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35502,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(pStrValue, <size of pStrValue>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35502,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(pStrValue, <size of pStrValue>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "66860efa-ae9c-3b89-b663-3509bc4b6663",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1389,
                  "startColumn": 8,
                  "endLine": 1389,
                  "endColumn": 14,
                  "charOffset": 46029,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fcbdea81-f4dc-3c88-9ae3-a3aed4e82733",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1337,
                  "startColumn": 21,
                  "endLine": 1337,
                  "endColumn": 29,
                  "charOffset": 44476,
                  "charLength": 8,
                  "snippet": {
                    "text": "mbstowcs",
                    "rendered": {
                      "text": "mbstowcs",
                      "markdown": "`mbstowcs`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bbd0a3bf-4e37-35b3-904c-27cc17e25837",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 967,
                  "startColumn": 29,
                  "endLine": 967,
                  "endColumn": 41,
                  "charOffset": 31544,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pDst)",
                    "rendered": {
                      "text": "strlen(pDst)",
                      "markdown": "`strlen(pDst)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31544,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pDst, <size of pDst>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31544,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pDst, <size of pDst>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f80cba1d-8748-30cc-bf6d-1d1a88aa3eb5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1043,
                  "startColumn": 60,
                  "endLine": 1043,
                  "endColumn": 64,
                  "charOffset": 34335,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ae2a2a56-1acd-3e30-8625-ecaec16dad0b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1016,
                  "startColumn": 42,
                  "endLine": 1016,
                  "endColumn": 46,
                  "charOffset": 33109,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2ef7e877-fdbb-39aa-9260-7f4516f216c6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncat)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 968,
                  "startColumn": 4,
                  "endLine": 968,
                  "endColumn": 50,
                  "charOffset": 31562,
                  "charLength": 46,
                  "snippet": {
                    "text": "strncat(pDst, pSrc, (sizeDst - dstLength - 1))",
                    "rendered": {
                      "text": "strncat(pDst, pSrc, (sizeDst - dstLength - 1))",
                      "markdown": "`strncat(pDst, pSrc, (sizeDst - dstLength - 1))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31562,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strcat_s(pDst,  (sizeDst - dstLength - 1,  pSrc)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31562,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strlcat(pDst,  pSrc,  (sizeDst - dstLength - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "af38c419-aa2e-3bb7-b241-a4971a9ee83f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 948,
                  "startColumn": 4,
                  "endLine": 948,
                  "endColumn": 11,
                  "charOffset": 30750,
                  "charLength": 7,
                  "snippet": {
                    "text": "wcsncat",
                    "rendered": {
                      "text": "wcsncat",
                      "markdown": "`wcsncat`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "16800e0e-e2ec-3bf0-9913-e16dab2cc7ee",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 933,
                  "startColumn": 4,
                  "endLine": 933,
                  "endColumn": 11,
                  "charOffset": 30377,
                  "charLength": 7,
                  "snippet": {
                    "text": "wcsncpy",
                    "rendered": {
                      "text": "wcsncpy",
                      "markdown": "`wcsncpy`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e65a9b96-e9eb-3f01-a360-56edb3b52a6c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 947,
                  "startColumn": 31,
                  "endLine": 947,
                  "endColumn": 37,
                  "charOffset": 30732,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "839e3166-f684-3e4a-9a04-e7c8d5f073a4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 910,
                  "startColumn": 14,
                  "endLine": 910,
                  "endColumn": 26,
                  "charOffset": 29664,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pSrc)",
                    "rendered": {
                      "text": "strlen(pSrc)",
                      "markdown": "`strlen(pSrc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29664,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pSrc, <size of pSrc>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29664,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pSrc, <size of pSrc>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "faad9572-9715-3ab5-aee8-aef01a41a77a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 918,
                  "startColumn": 8,
                  "endLine": 918,
                  "endColumn": 42,
                  "charOffset": 29902,
                  "charLength": 34,
                  "snippet": {
                    "text": "strncpy(pDst, pSrc, (dstSize - 1))",
                    "rendered": {
                      "text": "strncpy(pDst, pSrc, (dstSize - 1))",
                      "markdown": "`strncpy(pDst, pSrc, (dstSize - 1))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29902,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strcpy_s(pDst,  (dstSize - 1,  pSrc)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29902,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strlcpy(pDst,  pSrc,  (dstSize - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "eb1f2896-6ed5-3dc2-b53c-83adcb8e4291",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 416,
                  "startColumn": 4,
                  "endLine": 416,
                  "endColumn": 22,
                  "charOffset": 14782,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14782,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "19d646e3-6924-3361-a829-df4f1ae6e1ef",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 79,
                  "endLine": 256,
                  "endColumn": 112,
                  "charOffset": 9344,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9344,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9344,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5070b677-6126-3010-b227-c6acdfa7fe9e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 338,
                  "startColumn": 4,
                  "endLine": 338,
                  "endColumn": 22,
                  "charOffset": 12127,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12127,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2a4db397-3252-3431-86a7-cf0ca0a33135",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 251,
                  "startColumn": 79,
                  "endLine": 251,
                  "endColumn": 112,
                  "charOffset": 9105,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9105,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9105,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9339ec3a-a3fd-34da-9f8a-0bfe2e110b7d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 244,
                  "startColumn": 28,
                  "endLine": 244,
                  "endColumn": 61,
                  "charOffset": 8817,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8817,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8817,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9ce34748-88fe-3a48-9455-77615bb79aaa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 28,
                  "endLine": 241,
                  "endColumn": 61,
                  "charOffset": 8671,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8671,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8671,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c863d8cd-64be-347f-9535-7e3621370ac4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 4,
                  "endLine": 158,
                  "endColumn": 29,
                  "charOffset": 5932,
                  "charLength": 25,
                  "snippet": {
                    "text": "memcpy(hash, state.v, 16)",
                    "rendered": {
                      "text": "memcpy(hash, state.v, 16)",
                      "markdown": "`memcpy(hash, state.v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5932,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  state.v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c2a322c8-4e19-3173-831d-c30636dc795a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 231,
                  "startColumn": 4,
                  "endLine": 231,
                  "endColumn": 23,
                  "charOffset": 8423,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(hash, v, 16)",
                    "rendered": {
                      "text": "memcpy(hash, v, 16)",
                      "markdown": "`memcpy(hash, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8423,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fa72f9ea-f717-3472-8064-62799638fdb0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 8,
                  "endLine": 98,
                  "endColumn": 39,
                  "charOffset": 3656,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(input.b, ptr, end - ptr)",
                    "rendered": {
                      "text": "memcpy(input.b, ptr, end - ptr)",
                      "markdown": "`memcpy(input.b, ptr, end - ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3656,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b, <size of input.b>,  ptr,  end - ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1cf146d3-7717-3971-9812-fd377714fc37",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 8,
                  "endLine": 71,
                  "endColumn": 69,
                  "charOffset": 2327,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                    "rendered": {
                      "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                      "markdown": "`memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2327,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b + (bytes % 32), <size of input.b + (bytes % 32)>,  ptr,  static_cast<size_t>(fill)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9453c534-c64a-3f10-8e02-2109ddde6d76",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 41,
                  "endLine": 26,
                  "endColumn": 106,
                  "charOffset": 836,
                  "charLength": 65,
                  "snippet": {
                    "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                    "rendered": {
                      "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                      "markdown": "`\"012345678901234567890123456789012345678901234567890123456789012\"`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "95a20299-6136-3301-afbf-28939d492ea1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 4,
                  "endLine": 51,
                  "endColumn": 33,
                  "charOffset": 1340,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1340,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6f856f3e-c9a2-3467-a1d6-90a985afcce5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Code Debugging Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/devdriver/shared/legacy/inc/gpuopen.h"
                },
                "region": {
                  "startLine": 458,
                  "startColumn": 9,
                  "endLine": 458,
                  "endColumn": 18,
                  "charOffset": 27919,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "dbc1b88f-07a2-36b0-b778-9e4a51cea174",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 4,
                  "endLine": 44,
                  "endColumn": 33,
                  "charOffset": 1186,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1186,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dc6466cb-e6c6-3968-86f5-d2225573b658",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 4,
                  "endLine": 37,
                  "endColumn": 33,
                  "charOffset": 1055,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1055,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "46e4b884-19a6-3b2e-b3cc-7675d0df9310",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palSysUtil.h"
                },
                "region": {
                  "startLine": 283,
                  "startColumn": 89,
                  "endLine": 283,
                  "endColumn": 97,
                  "charOffset": 8407,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e3e3f85a-d40a-30ab-b258-c58df38ee735",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/loader/executable.hpp"
                },
                "region": {
                  "startLine": 320,
                  "startColumn": 33,
                  "endLine": 320,
                  "endColumn": 39,
                  "charOffset": 10965,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2207fdc7-d63f-3e87-bfef-b5c6d5005117",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 1212,
                  "startColumn": 31,
                  "endLine": 1212,
                  "endColumn": 37,
                  "charOffset": 37450,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6944fd4f-ae9f-314c-8238-22b151255a1c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 476,
                  "startColumn": 6,
                  "endLine": 476,
                  "endColumn": 59,
                  "charOffset": 15235,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(value, module_name.c_str(), module_name.size()",
                    "rendered": {
                      "text": "memcpy(value, module_name.c_str(), module_name.size()",
                      "markdown": "`memcpy(value, module_name.c_str(), module_name.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/loader/executable.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15235,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  module_name.c_str(),  module_name.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a6988277-a364-38ff-8910-1afcbd631356",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 467,
                  "startColumn": 6,
                  "endLine": 467,
                  "endColumn": 59,
                  "charOffset": 14944,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(value, symbol_name.c_str(), symbol_name.size()",
                    "rendered": {
                      "text": "memcpy(value, symbol_name.c_str(), symbol_name.size()",
                      "markdown": "`memcpy(value, symbol_name.c_str(), symbol_name.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/loader/executable.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14944,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  symbol_name.c_str(),  symbol_name.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "49f26f4a-0d12-386d-9fc2-675fd23f8c36",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palMemTrackerImpl.h"
                },
                "region": {
                  "startLine": 307,
                  "startColumn": 33,
                  "endLine": 307,
                  "endColumn": 37,
                  "charOffset": 14190,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "86cac946-bb45-354c-a07e-557143427fb8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palMemTrackerImpl.h"
                },
                "region": {
                  "startLine": 305,
                  "startColumn": 26,
                  "endLine": 305,
                  "endColumn": 32,
                  "charOffset": 14123,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "58296b49-2492-3735-8757-4286175d3286",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palStringUtil.h"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 27,
                  "endLine": 184,
                  "endColumn": 33,
                  "charOffset": 7010,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d9f554c6-0437-3455-b523-f10b6f36622f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palStringUtil.h"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 27,
                  "endLine": 158,
                  "endColumn": 42,
                  "charOffset": 6353,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(pString)",
                    "rendered": {
                      "text": "strlen(pString)",
                      "markdown": "`strlen(pString)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palStringUtil.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6353,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palStringUtil.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6353,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ffb4ac61-f8cd-3e05-94b1-7a197a03546a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 647,
                  "startColumn": 4,
                  "endLine": 647,
                  "endColumn": 55,
                  "charOffset": 25390,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)",
                    "rendered": {
                      "text": "memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)",
                      "markdown": "`memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25390,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ppNextGroup, <size of ppNextGroup>,  &pNextGroup,  sizeof(pNextGroup)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "91d1816c-047e-393f-8773-388004e6a000",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 629,
                  "startColumn": 4,
                  "endLine": 629,
                  "endColumn": 55,
                  "charOffset": 24712,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)",
                    "rendered": {
                      "text": "memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)",
                      "markdown": "`memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24712,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&pNextGroup, <size of &pNextGroup>,  ppNextGroup,  sizeof(pNextGroup)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dbfc6967-431e-39b0-adf5-e5493a76a8de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 611,
                  "startColumn": 4,
                  "endLine": 611,
                  "endColumn": 55,
                  "charOffset": 24051,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(pNumEntries, &numEntries, sizeof(numEntries)",
                    "rendered": {
                      "text": "memcpy(pNumEntries, &numEntries, sizeof(numEntries)",
                      "markdown": "`memcpy(pNumEntries, &numEntries, sizeof(numEntries)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24051,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pNumEntries, <size of pNumEntries>,  &numEntries,  sizeof(numEntries)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "27c88cea-8164-32dd-bd14-5ba4a266bd59",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 593,
                  "startColumn": 4,
                  "endLine": 593,
                  "endColumn": 55,
                  "charOffset": 23372,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(&numEntries, pNumEntries, sizeof(numEntries)",
                    "rendered": {
                      "text": "memcpy(&numEntries, pNumEntries, sizeof(numEntries)",
                      "markdown": "`memcpy(&numEntries, pNumEntries, sizeof(numEntries)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23372,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&numEntries, <size of &numEntries>,  pNumEntries,  sizeof(numEntries)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "93b00377-4f43-3238-86fc-eb501c193fe7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 33,
                  "endLine": 175,
                  "endColumn": 44,
                  "charOffset": 8328,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(key)",
                    "rendered": {
                      "text": "strlen(key)",
                      "markdown": "`strlen(key)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8328,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(key, <size of key>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8328,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(key, <size of key>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a6f69862-5bd7-3d61-b217-f8f747ff207a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palSysUtil.h"
                },
                "region": {
                  "startLine": 283,
                  "startColumn": 89,
                  "endLine": 283,
                  "endColumn": 97,
                  "charOffset": 8407,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "826a85ab-88b9-3ca8-a1a1-3b506d9f7a9a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/loader/loaders.cpp"
                },
                "region": {
                  "startLine": 213,
                  "startColumn": 4,
                  "endLine": 213,
                  "endColumn": 44,
                  "charOffset": 6729,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy((char *) dst + offset, src, size)",
                    "rendered": {
                      "text": "memcpy((char *) dst + offset, src, size)",
                      "markdown": "`memcpy((char *) dst + offset, src, size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/loader/loaders.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6729,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s((char *) dst + offset, <size of (char *) dst + offset>,  src,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d0dfcb69-bb5f-3f0e-aa1d-8c419ed98ee1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palMemTrackerImpl.h"
                },
                "region": {
                  "startLine": 307,
                  "startColumn": 33,
                  "endLine": 307,
                  "endColumn": 37,
                  "charOffset": 14190,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "884ba402-6db6-33ab-a253-b6568f737546",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palMemTrackerImpl.h"
                },
                "region": {
                  "startLine": 305,
                  "startColumn": 26,
                  "endLine": 305,
                  "endColumn": 32,
                  "charOffset": 14123,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f61a2dd6-75cd-3fc7-97e9-072c0ba77509",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 1548,
                  "startColumn": 8,
                  "endLine": 1548,
                  "endColumn": 39,
                  "charOffset": 55012,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(buf, buffer, bufferSize)",
                    "rendered": {
                      "text": "memcpy(buf, buffer, bufferSize)",
                      "markdown": "`memcpy(buf, buffer, bufferSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55012,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf, <size of buf>,  buffer,  bufferSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a264f514-f15e-34cd-874f-1ec03962384e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 1536,
                  "startColumn": 8,
                  "endLine": 1536,
                  "endColumn": 40,
                  "charOffset": 54707,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(*buf, buffer, bufferSize)",
                    "rendered": {
                      "text": "memcpy(*buf, buffer, bufferSize)",
                      "markdown": "`memcpy(*buf, buffer, bufferSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 54707,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(*buf, <size of *buf>,  buffer,  bufferSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "95fddd09-d749-38bd-a5a9-f2469bd4955a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 998,
                  "startColumn": 10,
                  "endLine": 998,
                  "endColumn": 76,
                  "charOffset": 37537,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)",
                    "rendered": {
                      "text": "memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)",
                      "markdown": "`memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37537,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  (const char*) edata->d_buf + offset - coffset,  csize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7f0f1355-009b-37e5-aabb-cf87bcee6439",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 41,
                  "endLine": 150,
                  "endColumn": 49,
                  "charOffset": 4364,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f4b8502d-4b3d-39dd-b64c-7599a6856f56",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 647,
                  "startColumn": 4,
                  "endLine": 647,
                  "endColumn": 55,
                  "charOffset": 25390,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)",
                    "rendered": {
                      "text": "memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)",
                      "markdown": "`memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25390,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ppNextGroup, <size of ppNextGroup>,  &pNextGroup,  sizeof(pNextGroup)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ce9b1b13-1620-3c2d-bb51-3978bc80a13c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 629,
                  "startColumn": 4,
                  "endLine": 629,
                  "endColumn": 55,
                  "charOffset": 24712,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)",
                    "rendered": {
                      "text": "memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)",
                      "markdown": "`memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24712,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&pNextGroup, <size of &pNextGroup>,  ppNextGroup,  sizeof(pNextGroup)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "804f55c7-32ec-34af-86b7-9a390dce73c1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 611,
                  "startColumn": 4,
                  "endLine": 611,
                  "endColumn": 55,
                  "charOffset": 24051,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(pNumEntries, &numEntries, sizeof(numEntries)",
                    "rendered": {
                      "text": "memcpy(pNumEntries, &numEntries, sizeof(numEntries)",
                      "markdown": "`memcpy(pNumEntries, &numEntries, sizeof(numEntries)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24051,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pNumEntries, <size of pNumEntries>,  &numEntries,  sizeof(numEntries)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3a3a8c6f-2e56-34a0-91f1-0e4c3672055e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 33,
                  "endLine": 175,
                  "endColumn": 44,
                  "charOffset": 8328,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(key)",
                    "rendered": {
                      "text": "strlen(key)",
                      "markdown": "`strlen(key)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8328,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(key, <size of key>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8328,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(key, <size of key>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2abcbf71-c924-349b-866e-3b8d7e5488f8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 593,
                  "startColumn": 4,
                  "endLine": 593,
                  "endColumn": 55,
                  "charOffset": 23372,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(&numEntries, pNumEntries, sizeof(numEntries)",
                    "rendered": {
                      "text": "memcpy(&numEntries, pNumEntries, sizeof(numEntries)",
                      "markdown": "`memcpy(&numEntries, pNumEntries, sizeof(numEntries)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23372,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&numEntries, <size of &numEntries>,  pNumEntries,  sizeof(numEntries)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4de44d95-f69f-3726-91da-5363aa281948",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 1442,
                  "startColumn": 45,
                  "endLine": 1442,
                  "endColumn": 51,
                  "charOffset": 56567,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "98711838-b742-3cb5-b15b-8cf8f4837a03",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 927,
                  "startColumn": 8,
                  "endLine": 927,
                  "endColumn": 46,
                  "charOffset": 37284,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(svalue, isa.c_str(), (std::min)",
                    "rendered": {
                      "text": "memcpy(svalue, isa.c_str(), (std::min)",
                      "markdown": "`memcpy(svalue, isa.c_str(), (std::min)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37284,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svalue, <size of svalue>,  isa.c_str(),  (std::min)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3c8fd508-6560-3ad9-a74f-61fb110e8346",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 917,
                  "startColumn": 8,
                  "endLine": 917,
                  "endColumn": 50,
                  "charOffset": 36853,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(svalue, version.c_str(), (std::min)",
                    "rendered": {
                      "text": "memcpy(svalue, version.c_str(), (std::min)",
                      "markdown": "`memcpy(svalue, version.c_str(), (std::min)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36853,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svalue, <size of svalue>,  version.c_str(),  (std::min)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "669110e0-0b4e-308c-bc38-bd56a128d845",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 882,
                  "startColumn": 6,
                  "endLine": 882,
                  "endColumn": 70,
                  "charOffset": 35550,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(desc->producer_options, options.c_str(), options.length()",
                    "rendered": {
                      "text": "memcpy(desc->producer_options, options.c_str(), options.length()",
                      "markdown": "`memcpy(desc->producer_options, options.c_str(), options.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35550,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->producer_options, <size of desc->producer_options>,  options.c_str(),  options.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cf27b0bd-9eb2-3064-a233-372e7a4ad5df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 863,
                  "startColumn": 6,
                  "endLine": 863,
                  "endColumn": 69,
                  "charOffset": 34685,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy(desc->producer_name, producer.c_str(), producer.length()",
                    "rendered": {
                      "text": "memcpy(desc->producer_name, producer.c_str(), producer.length()",
                      "markdown": "`memcpy(desc->producer_name, producer.c_str(), producer.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34685,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->producer_name, <size of desc->producer_name>,  producer.c_str(),  producer.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0c641e70-a4bf-39bb-8dec-8f01b17da127",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 541,
                  "startColumn": 6,
                  "endLine": 541,
                  "endColumn": 127,
                  "charOffset": 17819,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()",
                    "rendered": {
                      "text": "memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()",
                      "markdown": "`memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17819,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->vendor_and_architecture_name + desc->vendor_name_size, <size of desc->vendor_and_architecture_name + desc->vendor_name_size>,  architecture_name.c_str(),  architecture_name.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e3fd4ef2-315e-3d0d-9a71-1331a181b35b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 540,
                  "startColumn": 6,
                  "endLine": 540,
                  "endColumn": 90,
                  "charOffset": 17722,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()",
                    "rendered": {
                      "text": "memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()",
                      "markdown": "`memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17722,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->vendor_and_architecture_name, <size of desc->vendor_and_architecture_name>,  vendor_name.c_str(),  vendor_name.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "513e94e1-98a1-31ef-a20f-d8f6e0d5d190",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 10,
                  "endLine": 148,
                  "endColumn": 61,
                  "charOffset": 4717,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(value, ModuleName.c_str(), ModuleName.size()",
                    "rendered": {
                      "text": "memcpy(value, ModuleName.c_str(), ModuleName.size()",
                      "markdown": "`memcpy(value, ModuleName.c_str(), ModuleName.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4717,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  ModuleName.c_str(),  ModuleName.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7f68a7ab-d6b9-3cd8-ad24-83a26e0db8af",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 10,
                  "endLine": 138,
                  "endColumn": 61,
                  "charOffset": 4337,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(value, SymbolName.c_str(), SymbolName.size()",
                    "rendered": {
                      "text": "memcpy(value, SymbolName.c_str(), SymbolName.size()",
                      "markdown": "`memcpy(value, SymbolName.c_str(), SymbolName.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4337,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  SymbolName.c_str(),  SymbolName.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3ebb1d43-b829-373d-ad9b-1154a1c3ce71",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 412,
                  "startColumn": 4,
                  "endLine": 412,
                  "endColumn": 25,
                  "charOffset": 12773,
                  "charLength": 21,
                  "snippet": {
                    "text": "memcpy(out, &hash, 8)",
                    "rendered": {
                      "text": "memcpy(out, &hash, 8)",
                      "markdown": "`memcpy(out, &hash, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12773,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &hash,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b0f9b080-fc35-3f1d-8c0b-1e8e727d24ce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 78,
                  "endLine": 253,
                  "endColumn": 110,
                  "charOffset": 8126,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8126,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8126,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f038e4c1-7d21-361f-a76c-c69f181d2880",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 248,
                  "startColumn": 78,
                  "endLine": 248,
                  "endColumn": 110,
                  "charOffset": 7891,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7891,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7891,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9d9f91b6-4d33-382a-bdb6-a340c8b510b4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 4,
                  "endLine": 335,
                  "endColumn": 25,
                  "charOffset": 10513,
                  "charLength": 21,
                  "snippet": {
                    "text": "memcpy(out, &hash, 8)",
                    "rendered": {
                      "text": "memcpy(out, &hash, 8)",
                      "markdown": "`memcpy(out, &hash, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10513,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &hash,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2777fd82-fca7-34d2-8480-9d2a10a97620",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 27,
                  "endLine": 241,
                  "endColumn": 59,
                  "charOffset": 7608,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7608,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7608,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "503ba429-8467-3475-a2b7-cfa91147e110",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 27,
                  "endLine": 238,
                  "endColumn": 59,
                  "charOffset": 7466,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7466,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7466,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fad61585-0698-3d0d-aade-5ae1a860a21a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 156,
                  "startColumn": 4,
                  "endLine": 156,
                  "endColumn": 28,
                  "charOffset": 5180,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(hash, state.v, 8)",
                    "rendered": {
                      "text": "memcpy(hash, state.v, 8)",
                      "markdown": "`memcpy(hash, state.v, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5180,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  state.v,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "87c38d25-f23a-3d52-bc6b-dcfb80c9c8d8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 4,
                  "endLine": 228,
                  "endColumn": 23,
                  "charOffset": 7222,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(hash, &h, 8)",
                    "rendered": {
                      "text": "memcpy(hash, &h, 8)",
                      "markdown": "`memcpy(hash, &h, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7222,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  &h,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "283fc9bc-aef5-3cc4-85d3-546da3acf792",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 8,
                  "endLine": 94,
                  "endColumn": 59,
                  "charOffset": 3199,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(input.b, ptr, static_cast<size_t>(end - ptr)",
                    "rendered": {
                      "text": "memcpy(input.b, ptr, static_cast<size_t>(end - ptr)",
                      "markdown": "`memcpy(input.b, ptr, static_cast<size_t>(end - ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3199,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b, <size of input.b>,  ptr,  static_cast<size_t>(end - ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6c1b6aa6-7234-3e86-9b5e-5fea38ad585a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 8,
                  "endLine": 67,
                  "endColumn": 69,
                  "charOffset": 1849,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                    "rendered": {
                      "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                      "markdown": "`memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1849,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b + (bytes % 32), <size of input.b + (bytes % 32)>,  ptr,  static_cast<size_t>(fill)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "82ad7559-d279-38ad-bb01-f764cedcd500",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 40,
                  "endLine": 27,
                  "endColumn": 105,
                  "charOffset": 833,
                  "charLength": 65,
                  "snippet": {
                    "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                    "rendered": {
                      "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                      "markdown": "`\"012345678901234567890123456789012345678901234567890123456789012\"`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "638bcb1d-dd1c-3c9a-aa32-d992f50d9f4c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/testvector.h"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 25,
                  "endLine": 38,
                  "endColumn": 98,
                  "charOffset": 1148,
                  "charLength": 73,
                  "snippet": {
                    "text": "key_63 = \"012345678901234567890123456789012345678901234567890123456789012",
                    "rendered": {
                      "text": "key_63 = \"012345678901234567890123456789012345678901234567890123456789012",
                      "markdown": "`key_63 = \"012345678901234567890123456789012345678901234567890123456789012`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "7cfc9662-ee41-3bd7-a480-f46d73ae4816",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 4,
                  "endLine": 175,
                  "endColumn": 22,
                  "charOffset": 5745,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5745,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4c14e51b-cf48-3365-9860-832e94fd51c9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 4,
                  "endLine": 99,
                  "endColumn": 22,
                  "charOffset": 3269,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3269,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "77f04431-3fa9-3e4b-91e8-8c371a321148",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 416,
                  "startColumn": 4,
                  "endLine": 416,
                  "endColumn": 22,
                  "charOffset": 14782,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14782,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f722c8cc-6c22-3b4e-a14b-585e6e2fb16b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 338,
                  "startColumn": 4,
                  "endLine": 338,
                  "endColumn": 22,
                  "charOffset": 12127,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12127,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8acefd5f-c564-3cd6-922a-12f43216833a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 79,
                  "endLine": 256,
                  "endColumn": 112,
                  "charOffset": 9344,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9344,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9344,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "61659345-4e63-300d-937a-c34f3f911042",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 251,
                  "startColumn": 79,
                  "endLine": 251,
                  "endColumn": 112,
                  "charOffset": 9105,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9105,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9105,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6de51c45-00dc-319e-b25f-e2e59cc31394",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 244,
                  "startColumn": 28,
                  "endLine": 244,
                  "endColumn": 61,
                  "charOffset": 8817,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8817,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8817,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "983b0a42-863d-3d86-a8eb-c2c917a817ad",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 28,
                  "endLine": 241,
                  "endColumn": 61,
                  "charOffset": 8671,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8671,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8671,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b600169a-a669-3929-a470-900f4b757237",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 231,
                  "startColumn": 4,
                  "endLine": 231,
                  "endColumn": 23,
                  "charOffset": 8423,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(hash, v, 16)",
                    "rendered": {
                      "text": "memcpy(hash, v, 16)",
                      "markdown": "`memcpy(hash, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8423,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0c6722e8-62b0-3e03-b2e3-e78f21669d53",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 4,
                  "endLine": 158,
                  "endColumn": 29,
                  "charOffset": 5932,
                  "charLength": 25,
                  "snippet": {
                    "text": "memcpy(hash, state.v, 16)",
                    "rendered": {
                      "text": "memcpy(hash, state.v, 16)",
                      "markdown": "`memcpy(hash, state.v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5932,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  state.v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "39449e05-0d13-3ee1-b562-ced492de80e8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 8,
                  "endLine": 98,
                  "endColumn": 39,
                  "charOffset": 3656,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(input.b, ptr, end - ptr)",
                    "rendered": {
                      "text": "memcpy(input.b, ptr, end - ptr)",
                      "markdown": "`memcpy(input.b, ptr, end - ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3656,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b, <size of input.b>,  ptr,  end - ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d9fa0226-dcaa-31ac-baa2-5b2dc2aca1c2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 8,
                  "endLine": 71,
                  "endColumn": 69,
                  "charOffset": 2327,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                    "rendered": {
                      "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                      "markdown": "`memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2327,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b + (bytes % 32), <size of input.b + (bytes % 32)>,  ptr,  static_cast<size_t>(fill)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0e4f3c94-14a7-3b9f-8ad7-8d39a3e295a2",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 41,
                  "endLine": 26,
                  "endColumn": 106,
                  "charOffset": 836,
                  "charLength": 65,
                  "snippet": {
                    "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                    "rendered": {
                      "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                      "markdown": "`\"012345678901234567890123456789012345678901234567890123456789012\"`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "d0bf2c16-54a3-3e75-b909-a735897a3f4f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 4,
                  "endLine": 51,
                  "endColumn": 33,
                  "charOffset": 1340,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1340,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b69a0813-329b-3df7-981a-a6e8a48b4f22",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 4,
                  "endLine": 37,
                  "endColumn": 33,
                  "charOffset": 1055,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1055,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9a8c7a48-ffe5-3758-92ca-e4f8271f9624",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 4,
                  "endLine": 44,
                  "endColumn": 33,
                  "charOffset": 1186,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1186,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "89770452-c1b3-36f5-95de-ee96ad8a8118",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1538,
                  "startColumn": 4,
                  "endLine": 1538,
                  "endColumn": 9,
                  "charOffset": 50397,
                  "charLength": 5,
                  "snippet": {
                    "text": "qsort",
                    "rendered": {
                      "text": "qsort",
                      "markdown": "`qsort`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d071ede6-a615-3e28-8eec-47dde83636f8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1064,
                  "startColumn": 23,
                  "endLine": 1064,
                  "endColumn": 40,
                  "charOffset": 34892,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(pStrValue)",
                    "rendered": {
                      "text": "strlen(pStrValue)",
                      "markdown": "`strlen(pStrValue)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34892,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(pStrValue, <size of pStrValue>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34892,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(pStrValue, <size of pStrValue>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "07b663dd-4998-3dab-9d16-b5e910aaf96f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1494,
                  "startColumn": 11,
                  "endLine": 1494,
                  "endColumn": 17,
                  "charOffset": 48748,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "dbde598b-bbac-3c3a-b319-a64a2cd1359f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1357,
                  "startColumn": 8,
                  "endLine": 1357,
                  "endColumn": 14,
                  "charOffset": 44744,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d811a70a-c533-33e1-bb0c-09c461bfbf18",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1300,
                  "startColumn": 21,
                  "endLine": 1300,
                  "endColumn": 29,
                  "charOffset": 43069,
                  "charLength": 8,
                  "snippet": {
                    "text": "mbstowcs",
                    "rendered": {
                      "text": "mbstowcs",
                      "markdown": "`mbstowcs`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a2f61dc6-a5e8-30c0-976b-d42f3789f71d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1035,
                  "startColumn": 60,
                  "endLine": 1035,
                  "endColumn": 64,
                  "charOffset": 33725,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "57a7d2e3-f57d-383a-b7c1-0491cdf0613d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 959,
                  "startColumn": 29,
                  "endLine": 959,
                  "endColumn": 41,
                  "charOffset": 30916,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pDst)",
                    "rendered": {
                      "text": "strlen(pDst)",
                      "markdown": "`strlen(pDst)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30916,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pDst, <size of pDst>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30916,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pDst, <size of pDst>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8d5b0678-de8b-3679-b19a-0e801ef17dc4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1008,
                  "startColumn": 42,
                  "endLine": 1008,
                  "endColumn": 46,
                  "charOffset": 32499,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "78578e6c-08f6-306e-87f5-e42d103ae268",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncat)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 960,
                  "startColumn": 4,
                  "endLine": 960,
                  "endColumn": 50,
                  "charOffset": 30934,
                  "charLength": 46,
                  "snippet": {
                    "text": "strncat(pDst, pSrc, (sizeDst - dstLength - 1))",
                    "rendered": {
                      "text": "strncat(pDst, pSrc, (sizeDst - dstLength - 1))",
                      "markdown": "`strncat(pDst, pSrc, (sizeDst - dstLength - 1))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30934,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strcat_s(pDst,  (sizeDst - dstLength - 1,  pSrc)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30934,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strlcat(pDst,  pSrc,  (sizeDst - dstLength - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d1e70db2-6a82-3f7c-a50a-7c2f37bb1ce0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 939,
                  "startColumn": 4,
                  "endLine": 939,
                  "endColumn": 11,
                  "charOffset": 30097,
                  "charLength": 7,
                  "snippet": {
                    "text": "wcsncat",
                    "rendered": {
                      "text": "wcsncat",
                      "markdown": "`wcsncat`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "36f3ad24-c10b-3bb0-9fbd-50310b5cf432",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 920,
                  "startColumn": 4,
                  "endLine": 920,
                  "endColumn": 11,
                  "charOffset": 29618,
                  "charLength": 7,
                  "snippet": {
                    "text": "wcsncpy",
                    "rendered": {
                      "text": "wcsncpy",
                      "markdown": "`wcsncpy`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4bc2e267-6316-3f5b-9f51-f35e3eda3864",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 894,
                  "startColumn": 14,
                  "endLine": 894,
                  "endColumn": 26,
                  "charOffset": 28822,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pSrc)",
                    "rendered": {
                      "text": "strlen(pSrc)",
                      "markdown": "`strlen(pSrc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28822,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pSrc, <size of pSrc>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28822,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pSrc, <size of pSrc>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e5ba16e9-a75c-31ec-afa8-b03f70aa91c1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 902,
                  "startColumn": 8,
                  "endLine": 902,
                  "endColumn": 42,
                  "charOffset": 29060,
                  "charLength": 34,
                  "snippet": {
                    "text": "strncpy(pDst, pSrc, (dstSize - 1))",
                    "rendered": {
                      "text": "strncpy(pDst, pSrc, (dstSize - 1))",
                      "markdown": "`strncpy(pDst, pSrc, (dstSize - 1))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29060,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strcpy_s(pDst,  (dstSize - 1,  pSrc)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29060,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strlcpy(pDst,  pSrc,  (dstSize - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6205dddd-9c29-3789-b9d2-eb64d456ac07",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Code Debugging Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/devdriver/shared/legacy/inc/gpuopen.h"
                },
                "region": {
                  "startLine": 458,
                  "startColumn": 9,
                  "endLine": 458,
                  "endColumn": 18,
                  "charOffset": 27919,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "5e2b503b-b13d-3914-9311-bd5279b3bb85",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palStringUtil.h"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 74,
                  "endLine": 135,
                  "endColumn": 83,
                  "charOffset": 6240,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(s)",
                    "rendered": {
                      "text": "strlen(s)",
                      "markdown": "`strlen(s)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palStringUtil.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6240,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(s, <size of s>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palStringUtil.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6240,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(s, <size of s>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3720f95f-2b47-336c-abef-04477ffca7b9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palVector.h"
                },
                "region": {
                  "startLine": 432,
                  "startColumn": 17,
                  "endLine": 432,
                  "endColumn": 58,
                  "charOffset": 18721,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(m_pData, vector.m_pData, sizeof(T)",
                    "rendered": {
                      "text": "memcpy(m_pData, vector.m_pData, sizeof(T)",
                      "markdown": "`memcpy(m_pData, vector.m_pData, sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palVector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18721,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_pData, <size of m_pData>,  vector.m_pData,  sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5417efdf-8173-335c-95df-5bb02e36899d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palFile.h"
                },
                "region": {
                  "startLine": 68,
                  "startColumn": 16,
                  "endLine": 68,
                  "endColumn": 21,
                  "charOffset": 3057,
                  "charLength": 5,
                  "snippet": {
                    "text": "ctime",
                    "rendered": {
                      "text": "ctime",
                      "markdown": "`ctime`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9a2abc51-233d-37c6-9a2b-5d5d6a592637",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/loader/executable.hpp"
                },
                "region": {
                  "startLine": 320,
                  "startColumn": 33,
                  "endLine": 320,
                  "endColumn": 39,
                  "charOffset": 10965,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "53a5b40b-77b2-330d-beb4-77756f64962d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palSysUtil.h"
                },
                "region": {
                  "startLine": 275,
                  "startColumn": 89,
                  "endLine": 275,
                  "endColumn": 97,
                  "charOffset": 8287,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3b834eca-8160-384f-bb80-08884872c739",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 1212,
                  "startColumn": 31,
                  "endLine": 1212,
                  "endColumn": 37,
                  "charOffset": 37450,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "415e3e21-eb4f-3ed5-987a-b9cb4c286d51",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 476,
                  "startColumn": 6,
                  "endLine": 476,
                  "endColumn": 59,
                  "charOffset": 15235,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(value, module_name.c_str(), module_name.size()",
                    "rendered": {
                      "text": "memcpy(value, module_name.c_str(), module_name.size()",
                      "markdown": "`memcpy(value, module_name.c_str(), module_name.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/loader/executable.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15235,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  module_name.c_str(),  module_name.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8a626a34-3fc8-3844-8a21-257cc94f9a8e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 467,
                  "startColumn": 6,
                  "endLine": 467,
                  "endColumn": 59,
                  "charOffset": 14944,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(value, symbol_name.c_str(), symbol_name.size()",
                    "rendered": {
                      "text": "memcpy(value, symbol_name.c_str(), symbol_name.size()",
                      "markdown": "`memcpy(value, symbol_name.c_str(), symbol_name.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/loader/executable.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14944,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  symbol_name.c_str(),  symbol_name.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "98540b50-ddeb-3234-8601-8a049571dad4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palMemTrackerImpl.h"
                },
                "region": {
                  "startLine": 307,
                  "startColumn": 33,
                  "endLine": 307,
                  "endColumn": 37,
                  "charOffset": 14190,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "78de8fc0-482e-3019-a083-3cf155e027d4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palMemTrackerImpl.h"
                },
                "region": {
                  "startLine": 305,
                  "startColumn": 26,
                  "endLine": 305,
                  "endColumn": 32,
                  "charOffset": 14123,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0827c851-92e2-3585-be90-ba1d0815b2f9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 644,
                  "startColumn": 4,
                  "endLine": 644,
                  "endColumn": 55,
                  "charOffset": 25092,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)",
                    "rendered": {
                      "text": "memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)",
                      "markdown": "`memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25092,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ppNextGroup, <size of ppNextGroup>,  &pNextGroup,  sizeof(pNextGroup)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d4c2e4ec-a343-37ac-b5be-38caa9691c14",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 626,
                  "startColumn": 4,
                  "endLine": 626,
                  "endColumn": 55,
                  "charOffset": 24414,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)",
                    "rendered": {
                      "text": "memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)",
                      "markdown": "`memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24414,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&pNextGroup, <size of &pNextGroup>,  ppNextGroup,  sizeof(pNextGroup)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d777d5c2-2b54-36f5-8125-65921fec5294",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 33,
                  "endLine": 175,
                  "endColumn": 44,
                  "charOffset": 8328,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(key)",
                    "rendered": {
                      "text": "strlen(key)",
                      "markdown": "`strlen(key)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8328,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(key, <size of key>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8328,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(key, <size of key>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "457717a0-d8f0-300f-941d-0990630f6342",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 608,
                  "startColumn": 4,
                  "endLine": 608,
                  "endColumn": 55,
                  "charOffset": 23753,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(pNumEntries, &numEntries, sizeof(numEntries)",
                    "rendered": {
                      "text": "memcpy(pNumEntries, &numEntries, sizeof(numEntries)",
                      "markdown": "`memcpy(pNumEntries, &numEntries, sizeof(numEntries)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23753,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pNumEntries, <size of pNumEntries>,  &numEntries,  sizeof(numEntries)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3fbb662f-bb26-39a1-af2a-00dbaf583edd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/loader/loaders.cpp"
                },
                "region": {
                  "startLine": 213,
                  "startColumn": 4,
                  "endLine": 213,
                  "endColumn": 44,
                  "charOffset": 6729,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy((char *) dst + offset, src, size)",
                    "rendered": {
                      "text": "memcpy((char *) dst + offset, src, size)",
                      "markdown": "`memcpy((char *) dst + offset, src, size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/loader/loaders.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6729,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s((char *) dst + offset, <size of (char *) dst + offset>,  src,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f9a8d0c3-0e78-3a1c-80a2-6299d04e1a50",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 590,
                  "startColumn": 4,
                  "endLine": 590,
                  "endColumn": 55,
                  "charOffset": 23074,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(&numEntries, pNumEntries, sizeof(numEntries)",
                    "rendered": {
                      "text": "memcpy(&numEntries, pNumEntries, sizeof(numEntries)",
                      "markdown": "`memcpy(&numEntries, pNumEntries, sizeof(numEntries)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23074,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&numEntries, <size of &numEntries>,  pNumEntries,  sizeof(numEntries)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "60bd9445-4d35-34f9-983f-0650fdc68395",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 1548,
                  "startColumn": 8,
                  "endLine": 1548,
                  "endColumn": 39,
                  "charOffset": 55012,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(buf, buffer, bufferSize)",
                    "rendered": {
                      "text": "memcpy(buf, buffer, bufferSize)",
                      "markdown": "`memcpy(buf, buffer, bufferSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55012,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf, <size of buf>,  buffer,  bufferSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bad00dd9-8165-349f-a2ba-9c60ae765844",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palVector.h"
                },
                "region": {
                  "startLine": 432,
                  "startColumn": 17,
                  "endLine": 432,
                  "endColumn": 58,
                  "charOffset": 18721,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(m_pData, vector.m_pData, sizeof(T)",
                    "rendered": {
                      "text": "memcpy(m_pData, vector.m_pData, sizeof(T)",
                      "markdown": "`memcpy(m_pData, vector.m_pData, sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palVector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18721,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_pData, <size of m_pData>,  vector.m_pData,  sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9d912c9a-bc96-3f86-bfef-409b9d4d4c5e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 1536,
                  "startColumn": 8,
                  "endLine": 1536,
                  "endColumn": 40,
                  "charOffset": 54707,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(*buf, buffer, bufferSize)",
                    "rendered": {
                      "text": "memcpy(*buf, buffer, bufferSize)",
                      "markdown": "`memcpy(*buf, buffer, bufferSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 54707,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(*buf, <size of *buf>,  buffer,  bufferSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cb5c51d4-2a8a-3001-b676-bc94d8b5bcc4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 998,
                  "startColumn": 10,
                  "endLine": 998,
                  "endColumn": 76,
                  "charOffset": 37537,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)",
                    "rendered": {
                      "text": "memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)",
                      "markdown": "`memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37537,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  (const char*) edata->d_buf + offset - coffset,  csize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7b67ec79-58aa-393f-9b1d-9004735862fb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 41,
                  "endLine": 150,
                  "endColumn": 49,
                  "charOffset": 4364,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "22f480ac-e07f-3381-af0c-929a9f303569",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palFile.h"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 46,
                  "endLine": 101,
                  "endColumn": 51,
                  "charOffset": 4300,
                  "charLength": 5,
                  "snippet": {
                    "text": "ctime",
                    "rendered": {
                      "text": "ctime",
                      "markdown": "`ctime`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b6266cdf-388a-32b1-a24e-cede5da62cb2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palFile.h"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 46,
                  "endLine": 97,
                  "endColumn": 51,
                  "charOffset": 3986,
                  "charLength": 5,
                  "snippet": {
                    "text": "ctime",
                    "rendered": {
                      "text": "ctime",
                      "markdown": "`ctime`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}
{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "7f0f1355-009b-37e5-aabb-cf87bcee6439",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` or `strerror_s()`. Also, consider using exception handling for error reporting instead of directly writing error messages to the output.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nchar buf[1024];\nif(strerror_r(errno, buf, sizeof(buf)) == 0) {\n    out << \"Error: \" << msg << \": \" << buf << std::endl;\n} else {\n    out << \"Error: \" << msg << std::endl;\n}\n```\n\n## Library Dependencies\n\n- `<string.h>`: This header file contains declaration of various string handling functions including `strerror_r()`.\n- `<errno.h>`: This header file defines macros for reporting error conditions.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "46e4b884-19a6-3b2e-b3cc-7675d0df9310",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f61a2dd6-75cd-3fc7-97e9-072c0ba77509",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable program behavior, data corruption, or crashes. The verdict is supported by the high-confidence classification and the explicit marking of the call as genuine. There are no indications that the source or destination pointers are null at this point, and no explicit bounds or overlap guards are present. The use of a generic pointer type for the destination and the absence of capacity or length checks further increase the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping memory safely.\n\n```cpp\nmemmove(buf, buffer, bufferSize);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a264f514-f15e-34cd-874f-1ec03962384e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable program behavior, data corruption, or crashes. There are no explicit checks or guards in the code to prevent this overlap, and the function used (`memcpy`) does not handle overlapping memory safely. The source and destination are both confirmed to be non-null, but the overlap risk remains unmitigated. This type of issue is a well-known source of subtle and dangerous bugs in C/C++ code.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(*buf, buffer, bufferSize);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination memory regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "95fddd09-d749-38bd-a5a9-f2469bd4955a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the size of the destination buffer is not known or enforced. The use of a generic pointer type for the destination further increases the risk, as it is not possible to verify buffer boundaries. These factors make this a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the `memcpy` call with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation will not corrupt data if the regions overlap.\n\n```cpp\nmemmove(dest, (const char*) edata->d_buf + offset - coffset, csize);\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly and consider adding runtime assertions to enforce it:\n\n```cpp\nassert((char*)dest + csize <= (const char*)edata->d_buf + offset - coffset ||\n       (const char*)edata->d_buf + offset - coffset + csize <= (char*)dest);\nmemcpy(dest, (const char*) edata->d_buf + offset - coffset, csize);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ffb4ac61-f8cd-3e05-94b1-7a197a03546a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the pointer `pNextGroup` is being copied into `ppNextGroup`, which could potentially lead to a buffer overflow if the size of `ppNextGroup` is less than the size of `pNextGroup`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(ppNextGroup) >= sizeof(pNextGroup)) {\n    memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "93b00377-4f43-3238-86fc-eb501c193fe7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the first null character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum number of characters to read.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(key);\n```\n\nConsider using:\n\n```cpp\nstrnlen(key, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string. This will prevent `strnlen()` from reading beyond the end of the string if it is not null-terminated.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "bb760f13-5082-39e3-b482-c4a1f7f6e77d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. The `qsort` function is one such function that can lead to this vulnerability. It is a standard library function in C that performs a quicksort on an array. However, it can be misused in a way that leads to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `qsort` function. In C++, the `std::sort` function from the `<algorithm>` library is a safer and more efficient alternative. It is type-safe and does not require a comparison function as a parameter, reducing the risk of misuse.\n\n## Source Code Fix Recommendation\n\nReplace the `qsort` function with the `std::sort` function. Here is an example of how to do this:\n\n```cpp\n#include <algorithm>\n#include <vector>\n\n// Old code using qsort\n// int compare(const void* a, const void* b);\n// qsort(array, size, sizeof(int), compare);\n\n// New code using std::sort\nstd::vector<int> vec = { /* your data */ };\nstd::sort(vec.begin(), vec.end());\n```\n\n## Library Dependencies\n\nThe `std::sort` function requires the `<algorithm>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "91d1816c-047e-393f-8773-388004e6a000",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the pointer `pNextGroup` is being used as the size of the destination buffer, which may not be the correct size.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you should replace `sizeof(pNextGroup)` with the actual size of the destination buffer. If `pNextGroup` is a pointer to a buffer of a certain type, you can use `sizeof(*pNextGroup)` to get the size of the buffer. Here is a corrected version of the code:\n\n```cpp\nmemcpy(&pNextGroup, ppNextGroup, sizeof(*pNextGroup));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `cstring` header file in your code:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "14547da1-a929-32d9-94a5-57fdee039bc9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "66860efa-ae9c-3b89-b663-3509bc4b6663",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "dbfc6967-431e-39b0-adf5-e5493a76a8de",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying the value of `numEntries` into `pNumEntries`. If the size of `numEntries` is larger than the size of `pNumEntries`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(pNumEntries) >= sizeof(numEntries)) {\n    memcpy(pNumEntries, &numEntries, sizeof(numEntries));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `pNumEntries` is larger or equal to the size of `numEntries`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "27c88cea-8164-32dd-bd14-5ba4a266bd59",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `pNumEntries` is larger than the size of `numEntries`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(*pNumEntries) <= sizeof(numEntries)) {\n    memcpy(&numEntries, pNumEntries, sizeof(numEntries));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed version, we first check if the size of the data pointed to by `pNumEntries` is less than or equal to the size of `numEntries`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in some way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fcbdea81-f4dc-3c88-9ae3-a3aed4e82733",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `mbstowcs` function in C++ is used to convert a multibyte string to a wide character string. However, it can lead to vulnerabilities if not used properly. The function does not perform any bounds checking on the destination buffer, which can lead to buffer overflow if the source string is longer than the destination buffer. This can lead to arbitrary code execution or denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the converted string, including the null terminator. You should also consider using safer alternatives that perform bounds checking, such as `mbstowcs_s` or `mbsrtowcs`.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use `mbstowcs_s` to safely convert a multibyte string to a wide character string:\n\n```cpp\n#include <locale.h>\n#include <wchar.h>\n#include <stdlib.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.utf8\");\n    const char* mbstr = \"multibyte string\";\n    size_t len = mbstowcs(NULL, mbstr, 0) + 1;\n    wchar_t* wcstr = new wchar_t[len];\n    size_t converted;\n    mbstowcs_s(&converted, wcstr, len, mbstr, _TRUNCATE);\n    // use wcstr\n    delete[] wcstr;\n    return 0;\n}\n```\n\nIn this example, `mbstowcs` is first used to calculate the length of the converted string, then `mbstowcs_s` is used to perform the conversion. The `_TRUNCATE` option ensures that the conversion is safely truncated if the source string is too long.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- locale.h\n- wchar.h\n- stdlib.h\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f80cba1d-8748-30cc-bf6d-1d1a88aa3eb5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function in question is `atof`.\n\nThe `atof` function converts a string to a double. It does not check for overflow or underflow, and it does not report any errors. This can lead to unexpected behavior if the string cannot be represented as a double.\n\n## Mitigation Advice\n\nAvoid using the `atof` function. Instead, use safer alternatives such as `strtod` or `sscanf`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atof` function with `strtod` or `sscanf`. Here is an example of how to use `strtod`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char* str = \"123.45\";\nchar* endptr;\nerrno = 0; // To distinguish success/failure after call\ndouble val = strtod(str, &endptr);\n\n// Check for various possible errors\nif ((errno == ERANGE && (val == HUGE_VALF || val == HUGE_VALL)) || (errno != 0 && val == 0)) {\n    perror(\"strtod\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == str) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\n// If we got here, strtod() successfully parsed a number\nprintf(\"strtod() returned %f\\n\", val);\n\nif (*endptr != '\\0') // Not necessarily an error...\n    printf(\"Further characters after number: %s\\n\", endptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- cerrno\n- cstdio\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ae2a2a56-1acd-3e30-8625-ecaec16dad0b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1c232ed6-4581-31d2-8376-b4c3daa5394f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nIf `pStrValue` is a pointer to a string, ensure it is null-terminated before passing it to `strlen()`. If the length of the string is known at compile time, consider using `strnlen()` instead.\n\n```cpp\n// Ensure pStrValue is null-terminated\nif (pStrValue != nullptr) {\n    size_t len = strnlen(pStrValue, MAX_LENGTH);\n}\n```\n\nIn this example, `MAX_LENGTH` should be replaced with the maximum expected length of the string. If the string is longer than `MAX_LENGTH`, `strnlen()` will return `MAX_LENGTH`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "e65a9b96-e9eb-3f01-a360-56edb3b52a6c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bbd0a3bf-4e37-35b3-904c-27cc17e25837",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It returns the number of characters in a string up to but not including the first null character. The vulnerability arises when the string does not have a null character, causing `strlen()` to read beyond the intended memory, leading to a buffer overflow. This can result in crashes, incorrect behavior, or allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that are not guaranteed to be null-terminated. Instead, use safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(pDst)` with `strnlen(pDst, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of the string.\n\n```cpp\n#include <string.h>\n\n#define MAX_LENGTH 100\n\n// ...\n\nsize_t length = strnlen(pDst, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strnlen()` function is part of the `<string.h>` library in C++.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "af38c419-aa2e-3bb7-b241-a4971a9ee83f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. One such function is `wcsncat`.\n\nThe `wcsncat` function is a wide-character string function that appends not more than `n` wide-characters from a source string to the end of a destination string. The vulnerability arises when the size of the destination buffer is not properly managed, leading to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `wcsncat` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that include bounds checking such as `wcsncat_s` (in the case of Microsoft's implementation of C++), or use C++ strings (`std::wstring`) which are safer and easier to use.\n\n## Source Code Fix Recommendation\n\nInstead of using `wcsncat`, use `std::wstring`:\n\n```cpp\n#include <string>\n\nint main() {\n    std::wstring str1 = L\"Hello, \";\n    std::wstring str2 = L\"World!\";\n    str1 += str2; // This is safe\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2ef7e877-fdbb-39aa-9260-7f4516f216c6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncat` function in C++ is considered unsafe because it can lead to buffer overflow vulnerabilities. This function appends the source string to the destination string up to n characters. If the size of the destination buffer is not properly managed, it can lead to buffer overflow, which can cause the program to crash or lead to code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that are available in C++. For example, you can use the `strlcat` function which is designed to be safer, or you can use the string class in C++ which automatically manages the memory.\n\n## Source Code Fix Recommendation\n\nReplace the `strncat` function with `strlcat` function or use C++ string class.\n\n```cpp\n// Using strlcat\nsize_t sizeDst = sizeof(pDst);\nsize_t dstLength = strnlen(pDst, sizeDst);\nif (dstLength == sizeDst) {\n    // Handle error: pDst was not null-terminated.\n} else if (strlcat(pDst, pSrc, sizeDst) >= sizeDst) {\n    // Handle error: pDst is not large enough.\n}\n\n// Using C++ string class\nstd::string dst(pDst);\nstd::string src(pSrc);\ndst += src;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstring` or `string.h` for `strncat` and `strlcat` functions.\n- `string` for C++ string class.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "16800e0e-e2ec-3bf0-9913-e16dab2cc7ee",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcsncpy` function is one of these prohibited functions. It is used to copy a certain number of characters from one wide string to another. However, if the source string length is less than the number of characters to be copied, `wcsncpy` does not null-terminate the destination string, which can lead to buffer overflows.\n\n## Mitigation Advice\n\nAvoid using `wcsncpy` and other prohibited C functions. Instead, use safer alternatives that do not have these vulnerabilities. For example, consider using `wcsncpy_s` or `wmemcpy_s` which are safer as they null-terminate the destination string.\n\n## Source Code Fix Recommendation\n\nReplace `wcsncpy` with `wcsncpy_s` or `wmemcpy_s`. Here is an example:\n\n```cpp\n// Old vulnerable code\nwchar_t dest[100];\nwcsncpy(dest, src, 100);\n\n// Fixed code using wcsncpy_s\nwchar_t dest[100];\nwcsncpy_s(dest, 100, src, _TRUNCATE);\n\n// Or using wmemcpy_s\nwchar_t dest[100];\nwmemcpy_s(dest, 100, src, wcsnlen(src, 100));\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <wchar.h>\n```\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "839e3166-f684-3e4a-9a04-e7c8d5f073a4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It takes a string as an argument and returns its length. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be read.\n\n## Source Code Fix Recommendation\n\nIf `pSrc` is the string being passed to `strlen()`, ensure it is null-terminated:\n\n```cpp\nchar pSrc[] = \"Hello, World!\";\nsize_t len = strlen(pSrc);\n```\n\nOr use `strnlen()` instead:\n\n```cpp\nchar pSrc[] = \"Hello, World!\";\nsize_t len = strnlen(pSrc, sizeof(pSrc));\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "4de44d95-f69f-3726-91da-5363aa281948",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. In this case, the function `alloca()` is used, which is considered unsafe. The `alloca()` function dynamically allocates memory on the stack, which can lead to buffer overflow vulnerabilities if not properly managed. This is because the allocated memory is not initialized and can contain sensitive information. Additionally, the function does not provide any mechanism for error handling if the stack overflows.\n\n## Mitigation Advice\n\nAvoid using the `alloca()` function. Instead, use safer alternatives such as `malloc()`, `calloc()`, or `new` for dynamic memory allocation. These functions allocate memory on the heap, not the stack, and provide error handling mechanisms. Always ensure to properly manage and free dynamically allocated memory to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with a safer alternative. Here's how you can do it with `new`:\n\n```cpp\ntry {\n    sdata = new unsigned char[section->size()];\n} catch (std::bad_alloc& ba) {\n    std::cerr << \"bad_alloc caught: \" << ba.what() << '\\n';\n}\n```\n\nRemember to free the allocated memory when you're done with it:\n\n```cpp\ndelete[] sdata;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<new>`: This is required for the `new` operator and `std::bad_alloc` exception.\n- `<iostream>`: This is required for `std::cerr`.\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "faad9572-9715-3ab5-aee8-aef01a41a77a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflows. This function copies a string from one location to another, but it does not automatically append a null character at the end of the string. If the source string is longer than the destination buffer, this can lead to buffer overflow, which can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source string and the null character. You should also consider using safer string handling functions that automatically handle null termination, such as `strlcpy` or `strncpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `strncpy_s`:\n\n```cpp\n// Using strlcpy\nstrlcpy(pDst, pSrc, dstSize);\n\n// Using strncpy_s\nstrncpy_s(pDst, dstSize, pSrc, _TRUNCATE);\n```\n\nNote: `strlcpy` and `strncpy_s` are not standard C++ functions and may not be available on all platforms. If they are not available, you can manually ensure null termination:\n\n```cpp\nstrncpy(pDst, pSrc, dstSize - 1);\npDst[dstSize - 1] = '\\0';\n```\n\n## Library Dependencies\n\nThe `strncpy`, `strlcpy`, and `strncpy_s` functions are part of the C standard library, so you need to include the `cstring` or `string.h` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "669110e0-0b4e-308c-bc38-bd56a128d845",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the automated verdict confirms this. The code copies data from a string object's internal buffer to a destination pointer, but there is no evidence of a check to ensure the destination pointer is not null. The source is a C++ string's c_str(), which is generally safe, but the destination pointer could be null, leading to a crash or undefined behavior. The absence of a guard or capacity check for the destination increases the risk. The probability of this being a false positive is very low, as the analysis did not detect any safeguards or capacity validation for the destination pointer.\n\n## In Context Remediation\nBefore copying data to the destination buffer, ensure that the destination pointer is not null and that it has enough capacity to hold the source data plus the null terminator. Add explicit checks for the destination pointer and, if possible, validate the buffer size to prevent buffer overflows and undefined behavior. For example:\n\n```cpp\nif (desc->producer_options != nullptr && options.length() + 1 <= PRODUCER_OPTIONS_CAPACITY) {\n    memcpy(desc->producer_options, options.c_str(), options.length() + 1);\n} else {\n    // Handle error: null pointer or insufficient buffer size\n}\n```\n\nReplace `PRODUCER_OPTIONS_CAPACITY` with the actual size of the destination buffer. Always check for null pointers and ensure the buffer is large enough before performing memory operations.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "cf27b0bd-9eb2-3064-a233-372e7a4ad5df",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict is marked as genuine. The code copies data from a C++ string's internal buffer to a destination buffer using a memory copy function, but there is no evidence of a check to ensure that the destination pointer is not null. The source is a C++ string's internal buffer, which is generally safe, but the destination pointer may be null, as there is no guard or validation present. This could lead to a crash or other undefined behavior if the destination pointer is ever null at runtime. The probability of this being a false positive is very low, as the analysis specifically notes the lack of null checks for the destination pointer.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that the destination pointer is not null. This can be done by adding a check before the call:\n\n```cpp\nif (desc && desc->producer_name) {\n    memcpy(desc->producer_name, producer.c_str(), producer.length() + 1);\n}\n// Optionally, handle the error case if desc or desc->producer_name is null\n```\nThis prevents undefined behavior by ensuring that the destination buffer is valid before copying data. If the destination pointer can be null due to logic elsewhere, consider logging an error or returning early to avoid a crash.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "98711838-b742-3cb5-b15b-8cf8f4837a03",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `snprintf`.\n\nAdditionally, consider using higher level abstractions provided by C++ such as `std::string` or `std::vector` that manage memory automatically and are less prone to such vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative like `strncpy`. Here's how you can do it:\n\n```cpp\nstrncpy(svalue, isa.c_str(), std::min(sizeof(svalue), isa.size()));\n```\n\nIn this case, `sizeof(svalue)` ensures that we do not exceed the size of the destination buffer.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` and `strncpy` functions.\n- `<algorithm>`: This library provides the `std::min` function.\n- `<string>`: This library provides the `std::string` class.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3c8fd508-6560-3ad9-a74f-61fb110e8346",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before the `memcpy` function is called. \n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <cstring>\n#include <algorithm>\n#include <string>\n\nvoid safe_memcpy(char* svalue, const std::string& version, size_t max_size) {\n    size_t copy_size = std::min(version.size(), max_size - 1);\n    memcpy(svalue, version.c_str(), copy_size);\n    svalue[copy_size] = '\\0'; // Ensure null termination\n}\n```\n\nIn this code, `std::min` is used to ensure that the size of the data being copied does not exceed the size of the destination buffer. The `- 1` is to leave space for the null terminator.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<algorithm>`: This library provides the `std::min` function.\n- `<string>`: This library provides the `std::string` class.\n\n## OWASP and CWE Links\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a later date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7f68a7ab-d6b9-3cd8-ad24-83a26e0db8af",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is not known or proven to be sufficient for the number of bytes being copied. The operation copies the contents of a string (using its size) into a destination pointer, but there is no evidence that the destination buffer is large enough to hold the data. The risk is further increased because there is no explicit guard or check to ensure the destination buffer is large enough, and the destination type is a generic pointer, which provides no size information. Although the source is a string and not null, and there is no risk of overlapping memory regions, the lack of bounds checking or capacity validation makes this a high-risk buffer overflow scenario.\n\n## In Context Remediation\nBefore copying data from the string to the destination buffer, ensure that the destination buffer is large enough to hold the data. If the size of the destination buffer is not known, you must pass the buffer size as an additional argument or use a safer function that limits the number of bytes copied to the buffer's capacity. For example, if you know the size of the destination buffer (let's say `value_size`), you can use:\n\n```cpp\nsize_t copy_size = std::min(value_size, SymbolName.size());\nmemcpy(value, SymbolName.c_str(), copy_size);\n```\n\nIf the destination buffer is not large enough, consider allocating a buffer of the required size or returning an error. Always validate buffer sizes before performing memory copy operations to prevent buffer overflows.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "22f480ac-e07f-3381-af0c-929a9f303569",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, which can lead to arbitrary code execution, denial of service, or information disclosure. \n\nIn this case, the `ctime` function is considered insecure. The `ctime` function converts a time_t value into a string, but it does not check for buffer overflows. If an attacker can control the input to the `ctime` function, they can potentially cause a buffer overflow.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking. In the case of `ctime`, a safer alternative is `ctime_r`, which is a reentrant version that takes an additional argument for the result.\n\n## Source Code Fix Recommendation\n\nReplace the `ctime` function with `ctime_r`. Here is an example:\n\n```cpp\n#include <ctime>\n\nvoid print_time(time_t time) {\n    char buffer[26];\n    if (ctime_r(&time, buffer) == NULL) {\n        // Handle error\n    } else {\n        printf(\"%s\\n\", buffer);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<ctime>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0c641e70-a4bf-39bb-8dec-8f01b17da127",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the automated verdict also marks it as genuine. The code copies data from a C-style string into a buffer, but there is no evidence of checks to ensure that the destination pointer is not null before the operation. The source is a C-style string, which is generally safe, but the destination pointer may be null, as there are no visible guards or checks in the code. This could lead to a crash or other undefined behavior if the destination pointer is ever null at runtime. The probability of this being a false positive is very low, as the absence of null checks for the destination pointer is a clear risk.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer is not null. Add a check to verify that `desc` and `desc->vendor_and_architecture_name` are valid pointers before using them. This prevents undefined behavior due to null pointer dereference.\n\n```cpp\nif (desc && desc->vendor_and_architecture_name) {\n    memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length() + 1);\n}\n```\n\nAlternatively, handle the error case explicitly if the pointer is null:\n\n```cpp\nif (!desc || !desc->vendor_and_architecture_name) {\n    // Handle error: invalid destination pointer\n    return ERROR_INVALID_POINTER;\n}\nmemcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length() + 1);\n```\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e3fd4ef2-315e-3d0d-9a71-1331a181b35b",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that either the source or destination pointer may be null. The code copies data from a string object's internal buffer to a destination buffer using a memory copy operation, but there are no visible checks to ensure that the destination pointer is valid (not null) before the operation. If the destination pointer is null, this will result in a crash or undefined behavior. The source pointer is less likely to be null since it is derived from a string object, but the destination pointer is a structure member and may not be initialized. The absence of a guard or check for the destination pointer's validity increases the risk. The probability of this being a false positive is very low, as the analysis shows a real risk of dereferencing a null pointer.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that the destination pointer is not null. Add an explicit check to verify that the destination structure and its buffer member are valid. For example:\n\n```cpp\nif (desc && desc->vendor_and_architecture_name) {\n    memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length() + 1);\n} else {\n    // Handle error: destination is null\n}\n```\nThis prevents undefined behavior by ensuring the destination is valid before copying. If the destination can never be null by design, document this assumption clearly in the code and consider using assertions to enforce it during development.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b6266cdf-388a-32b1-a24e-cede5da62cb2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, which can lead to arbitrary code execution, denial of service, or information disclosure. \n\nIn this case, the `ctime` function is considered insecure. The `ctime` function converts a time_t value into a string, but it does not check for buffer overflows. If an attacker can control the input to the `ctime` function, they can potentially cause a buffer overflow.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking. In the case of `ctime`, a safer alternative is `ctime_r`, which is a reentrant version that takes an additional argument for the result.\n\n## Source Code Fix Recommendation\n\nReplace the `ctime` function with `ctime_r`. Here is an example:\n\n```cpp\n#include <ctime>\n\nvoid print_time(time_t time) {\n    char buffer[26];\n    if (ctime_r(&time, buffer) == NULL) {\n        // Handle error\n    } else {\n        printf(\"%s\\n\", buffer);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<ctime>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "513e94e1-98a1-31ef-a20f-d8f6e0d5d190",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a high risk due to the destination buffer's capacity being unknown and the copy length not being proven safe. The destination buffer is a generic pointer, and there is no evidence that its size is sufficient to hold the data being copied. The source is a C++ string's internal character array, and the length argument is the string's size, but there is no check to ensure the destination is large enough. There are no explicit guards or null-termination after the copy, and the analysis did not detect any overlap or null pointer risks. However, the lack of capacity information for the destination and the absence of safety checks make this a likely buffer overflow risk.\n\n## In Context Remediation\nBefore copying data from the string to the destination buffer, ensure that the destination buffer is large enough to hold the data. If the size of the destination buffer is not known, pass the buffer size as an additional argument and use it to limit the number of bytes copied. For example:\n\n```cpp\n// Assume 'value' is a pointer to a buffer and 'value_capacity' is its size in bytes\nsize_t copy_len = ModuleName.size();\nif (copy_len > value_capacity) {\n    // Handle error: buffer too small\n    // e.g., truncate, allocate larger buffer, or return error\n    copy_len = value_capacity;\n}\nmemcpy(value, ModuleName.c_str(), copy_len);\n```\n\nAlways validate that the destination buffer is large enough to avoid buffer overflows. If possible, use safer alternatives such as `std::copy` with iterators or `strncpy` (with care for null-termination) when working with character data.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "da7820f5-9613-3c86-ba36-a6aa5d6f7d94",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured Web Link Vulnerability in C++ is not a direct vulnerability in the language itself, but rather a potential security risk that can occur when a C++ application interacts with web resources. This vulnerability arises when a C++ application uses an unsecured (non-HTTPS) link to access web resources. This can expose the application to various attacks such as Man-in-the-Middle (MitM) attacks, where an attacker can intercept and potentially alter the data being transmitted.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use secure HTTPS links when your application needs to access web resources. HTTPS encrypts the data being transmitted, making it much more difficult for an attacker to intercept or alter it.\n\n## Source Code Fix Recommendation\n\nIf you're using a library like libcurl to handle HTTP requests, you can simply replace the unsecured \"http://\" prefix with \"https://\". For example, if the vulnerable code is:\n\n```cpp\nCURL *curl = curl_easy_init();\nif(curl) {\n  CURLcode res;\n  curl_easy_setopt(curl, CURLOPT_URL, \"http://www.apache.org\");\n  /* Perform the request, res will get the return code */ \n  res = curl_easy_perform(curl);\n  /* Check for errors */ \n  if(res != CURLE_OK)\n    fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n            curl_easy_strerror(res));\n  /* always cleanup */ \n  curl_easy_cleanup(curl);\n}\n```\n\nYou can fix the vulnerability by changing the URL to use HTTPS:\n\n```cpp\nCURL *curl = curl_easy_init();\nif(curl) {\n  CURLcode res;\n  curl_easy_setopt(curl, CURLOPT_URL, \"https://www.apache.org\");\n  /* Perform the request, res will get the return code */ \n  res = curl_easy_perform(curl);\n  /* Check for errors */ \n  if(res != CURLE_OK)\n    fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n            curl_easy_strerror(res));\n  /* always cleanup */ \n  curl_easy_cleanup(curl);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the libcurl library.\n\n## OWASP and CWE Links\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "7cfc9662-ee41-3bd7-a480-f46d73ae4816",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no evidence of a guard or check to ensure that the source and destination do not overlap, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The destination pointer is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy operation.\n\nExample remediation:\n\n```cpp\nif (out != nullptr && v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\nThis change ensures that the copy is safe even if the memory regions overlap and avoids dereferencing a null pointer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "eb1f2896-6ed5-3dc2-b53c-83adcb8e4291",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The destination is not likely to be null, but the source may be. The use of a fixed length (16 bytes) does not mitigate the risk of undefined behavior if the regions overlap. This type of issue can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the regions overlap.\n\n```cpp\nmemmove(out, v, 16);\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly and consider adding an assertion to enforce it at runtime:\n\n```cpp\nassert(out + 16 <= v || v + 16 <= out); // Ensure no overlap\nmemcpy(out, v, 16);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy:\n\n```cpp\nif (v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4c14e51b-cf48-3365-9860-832e94fd51c9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The destination pointer is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue. The use of a fixed length (16 bytes) does not mitigate the risk of overlap or null dereference.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid a potential crash.\n\n```cpp\nif (v != nullptr && out != v) {\n    memmove(out, v, 16);\n}\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly and consider adding assertions to enforce it during development:\n\n```cpp\nassert(out != v); // Ensure no overlap\nif (v != nullptr) {\n    memcpy(out, v, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "19d646e3-6924-3361-a829-df4f1ae6e1ef",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, which can lead to buffer over-read, and in some cases, can cause a segmentation fault or other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, you can use safer string handling functions that include length parameters, such as `strnlen`, which takes an additional parameter specifying the maximum number of bytes to read.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you can replace `strlen` with `strnlen` and add a maximum length parameter. Here's how you can do it:\n\n```cpp\nconst size_t max_length = 128; // Define a maximum length according to your needs\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash128::test_string), strnlen(MetroHash128::test_string, max_length))\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the MetroHash library, which provides the `MetroHash128` class and the `Update` method. The `strlen` function is part of the standard C library, which is typically included with any C++ compiler.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "2a4db397-3252-3431-86a7-cf0ca0a33135",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, which can lead to buffer over-read, and in some cases, can cause a segmentation fault or other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, you can use safer string handling functions that include length parameters, such as `strnlen`, which takes an additional parameter specifying the maximum number of bytes to read.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you can replace `strlen` with `strnlen` and add a maximum length parameter. Here's how you can do it:\n\n```cpp\nconst size_t max_length = 128; // Define a maximum length according to your needs\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash128::test_string), strnlen(MetroHash128::test_string, max_length))\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the MetroHash library, which provides the `MetroHash128` class and the `Update` method. The `strlen` function is part of the standard C library, which is typically included with any C++ compiler.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "9339ec3a-a3fd-34da-9f8a-0bfe2e110b7d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `strlen` function is used to determine the length of `MetroHash128::test_string`. To fix the vulnerability, you should ensure that `MetroHash128::test_string` is null-terminated. This can be done by adding a null character to the end of the string when it is initialized.\n\n```cpp\n// Ensure that MetroHash128::test_string is null-terminated\nchar MetroHash128::test_string[] = \"test string\\0\";\n\n// Now it's safe to use strlen\nMetroHash128::Hash(key, strlen(MetroHash128::test_string), hash, 1);\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to depend on the MetroHash library, which provides the `MetroHash128` class and its associated `Hash` function. The `strlen` function is part of the standard C library, which is included by default in most C++ environments.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the provided links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "9ce34748-88fe-3a48-9455-77615bb79aaa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated, which can lead to buffer overflows, memory corruption, and other unexpected behavior. This is because `strlen` counts characters until it encounters a null character, and if there is no null character, it will continue reading memory beyond the intended boundary.\n\nIn the provided code snippet, the `strlen` function is used to determine the length of `MetroHash128::test_string`. If `MetroHash128::test_string` is not null-terminated, this could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\nAdditionally, consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read beyond this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t length = strlen(MetroHash128::test_string);\nif (length > MAX_LENGTH) {\n    length = MAX_LENGTH;\n}\nMetroHash128::Hash(key, length, hash, 0);\n```\n\nIn this fix, `strnlen` is used instead of `strlen`, and a maximum length (`MAX_LENGTH`) is specified to prevent buffer overflows.\n\n## Library Dependencies\n\nThe provided code snippet appears to be using the MetroHash library. Therefore, the MetroHash library would be a required dependency for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "c2a322c8-4e19-3173-831d-c30636dc795a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The classification specifically highlights undefined behavior due to overlapping memory, which is a well-known issue with functions like memcpy. The verdict is marked as genuine, and the risk is further supported by the absence of capacity checks or explicit null-termination. Developers should address this to prevent unpredictable program behavior or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(hash, v, 16);\n```\n\nAdditionally, ensure that both `hash` and `v` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (hash != nullptr && v != nullptr) {\n    memmove(hash, v, 16);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5070b677-6126-3010-b227-c6acdfa7fe9e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The destination is unlikely to be null, but the source may be. The use of a fixed length (16 bytes) does not mitigate the risk of undefined behavior if the regions overlap. This type of issue can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(out, v, 16);\n```\n\nAdditionally, ensure that both `out` and `v` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (out != nullptr && v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c863d8cd-64be-347f-9535-7e3621370ac4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The destination is not likely to be null, but the source may be. The use of a fixed length (16 bytes) does not mitigate the risk of undefined behavior if the regions overlap. This type of issue can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that is safe for overlapping memory, such as `memmove` instead of `memcpy`. Replace the original call with `memmove(hash, state.v, 16);`. This ensures correct behavior even if the source and destination regions overlap.\n\n```cpp\nmemmove(hash, state.v, 16);\n```\n\nAdditionally, ensure that both `hash` and `state.v` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (hash != nullptr && state.v != nullptr) {\n    memmove(hash, state.v, 16);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fa72f9ea-f717-3472-8064-62799638fdb0",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence that the destination pointer is always valid, which increases the risk of a null pointer dereference. The source pointer is guarded to be non-null, but the destination is not. The use of a variable length (end - ptr) without explicit bounds checking further increases the risk. These factors together indicate a real risk of undefined behavior and potential security issues.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, validate that the destination pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (input.b != nullptr && ptr != nullptr && input.b != ptr) {\n    memmove(input.b, ptr, end - ptr);\n}\n```\n\nIf you know that overlap is not possible by design, document this assumption clearly and add assertions to enforce it at runtime:\n\n```cpp\nassert(input.b != ptr); // Ensure no overlap\nmemcpy(input.b, ptr, end - ptr);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "216f6fbd-5dce-3256-84f2-3f8f2f62559f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "75052834-d594-3977-acc4-c7a39cda9407",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured Web Link Vulnerability in C++ is not a direct vulnerability in the language itself, but rather a potential security risk that can occur when a C++ application interacts with web resources. This vulnerability arises when a C++ application uses an unsecured (non-HTTPS) link to access web resources. This can expose the application to various attacks such as Man-in-the-Middle (MitM) attacks, where an attacker can intercept and potentially alter the data being transmitted.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use secure HTTPS links when your application needs to access web resources. HTTPS encrypts the data being transmitted, making it much more difficult for an attacker to intercept or alter it.\n\n## Source Code Fix Recommendation\n\nIf you're using a library like libcurl to handle HTTP requests, you can simply replace the unsecured \"http://\" prefix with \"https://\". For example, if the vulnerable code is:\n\n```cpp\nCURL *curl = curl_easy_init();\nif(curl) {\n  CURLcode res;\n  curl_easy_setopt(curl, CURLOPT_URL, \"http://www.apache.org\");\n  /* Perform the request, res will get the return code */ \n  res = curl_easy_perform(curl);\n  /* Check for errors */ \n  if(res != CURLE_OK)\n    fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n            curl_easy_strerror(res));\n  /* always cleanup */ \n  curl_easy_cleanup(curl);\n}\n```\n\nYou can fix the vulnerability by changing the URL to use HTTPS:\n\n```cpp\nCURL *curl = curl_easy_init();\nif(curl) {\n  CURLcode res;\n  curl_easy_setopt(curl, CURLOPT_URL, \"https://www.apache.org\");\n  /* Perform the request, res will get the return code */ \n  res = curl_easy_perform(curl);\n  /* Check for errors */ \n  if(res != CURLE_OK)\n    fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n            curl_easy_strerror(res));\n  /* always cleanup */ \n  curl_easy_cleanup(curl);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the libcurl library.\n\n## OWASP and CWE Links\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "1cf146d3-7717-3971-9812-fd377714fc37",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that either the source or destination pointers are non-null, increasing the risk of null pointer dereference. The absence of explicit bounds checks or guards further increases the likelihood of a real issue. The verdict is supported by the classification indicating undefined behavior risk and the automated assessment marking this as a genuine finding.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation. For example:\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    memmove(input.b + (bytes % 32), ptr, static_cast<size_t>(fill));\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds null pointer checks to prevent undefined behavior and potential crashes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9453c534-c64a-3f10-8e02-2109ddde6d76",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Avoid Storing Tokens or Keys in Source Code Vulnerability\" is a common security vulnerability in C++ programming language where sensitive data such as tokens, keys, or passwords are hard-coded directly into the source code. This is a bad practice as it exposes sensitive data to anyone who has access to the source code. If the source code is ever compromised, the attacker would have direct access to these sensitive data, which could lead to serious security breaches.\n\n## Mitigation Advice\n\nThe best way to mitigate this vulnerability is to avoid hard-coding sensitive data directly into the source code. Instead, these data should be stored in a secure location such as environment variables, secure server, or using secure APIs provided by the operating system. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the test string directly into the source code, you can store it in an environment variable and then access it from your code. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* test_string = std::getenv(\"TEST_STRING\");\nif (!test_string) {\n    // handle error\n}\nMetroHash128::test_string = test_string;\n```\n\nIn this code, `std::getenv` is used to get the value of the environment variable `TEST_STRING`. If the environment variable is not set, `std::getenv` returns a null pointer.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This is a standard library in C++ for general purpose functions, including environment variables handling.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS173237"
                ]
              }
            },
            {
              "id": "64965a36-9aa3-3a47-8307-22726c8897f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null byte.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null byte at the end, or by manually adding a null byte after the last character of the string.\n\n## Source Code Fix Recommendation\n\nIf `pString` is a character array, you can ensure it is null-terminated by initializing it with a null byte:\n\n```cpp\nchar pString[] = \"Hello, world!\";\n```\n\nIf `pString` is a pointer to a string, you can add a null byte at the end:\n\n```cpp\nchar* pString = new char[14];\nstrcpy(pString, \"Hello, world!\");\npString[13] = '\\0';\n```\n\nIn both cases, `strlen(pString)` will now correctly return 13.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "12f2c581-da9c-374d-94b7-c4f5373b4157",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Storing Tokens or Keys in Source Code Vulnerability\" is a security flaw that occurs when sensitive data such as API keys, tokens, or passwords are hard-coded into the source code. This is a bad practice because if the source code is ever exposed, the sensitive data will also be exposed. This could lead to unauthorized access or other security breaches.\n\nIn the given code snippet, the key `test_key_63` is hard-coded into the source code, which is a security vulnerability.\n\n```cpp\ntest_key_63 = \"012345678901234567890123456789012345678901234567890123456789012\";\n```\n\n## Mitigation Advice\n\nAvoid hard-coding sensitive data into your source code. Instead, use secure methods to store and retrieve these data, such as environment variables, secure server, or encrypted database. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the key into the source code, you can store it in an environment variable and retrieve it when needed. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for getenv\n\nconst char* test_key_63 = std::getenv(\"TEST_KEY_63\");\nif (!test_key_63) {\n    // handle error: environment variable TEST_KEY_63 is not defined\n}\n```\n\nIn this code, `std::getenv` is a function from the `cstdlib` library that retrieves the value of the environment variable. If the environment variable is not defined, it returns a null pointer.\n\n## Library Dependencies\n\nThe `cstdlib` library is required by the code example to execute properly.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS117838"
                ]
              }
            },
            {
              "id": "bad00dd9-8165-349f-a2ba-9c60ae765844",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m_pData, vector.m_pData, sizeof(T))`, there is no check to ensure that the size of `vector.m_pData` is not larger than `m_pData`. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(vector.m_pData) <= sizeof(m_pData)) {\n    memcpy(m_pData, vector.m_pData, sizeof(T));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `vector.m_pData` is less than or equal to the size of `m_pData`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "039db223-e427-388a-9524-2bd71bc1d070",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination is a pointer to an 8-bit unsigned integer, and the source is the address of a hash variable. The analysis determined, through data flow, that the destination and source may overlap, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, the analysis could not rule out the possibility that the source pointer may be null, which would also cause undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function call is not protected by any length or capacity checks. Therefore, this is a high-confidence, actionable issue that should be addressed to ensure program correctness and security.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For the code in question, replace the memory copy operation with `memmove`:\n\n```cpp\nmemmove(out, &hash, 8);\n```\n\nAdditionally, if there is any chance that the source pointer could be null, add a check before the copy:\n\n```cpp\nif (out != nullptr && &hash != nullptr) {\n    memmove(out, &hash, 8);\n}\n```\n\nThis ensures that the operation is safe and avoids undefined behavior due to null pointers or overlapping memory regions.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fcd8bbb9-1aec-3aa1-9a70-af78fe33e42b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to calculate the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue to read memory until it encounters a null character, which can lead to buffer over-read, causing undefined behavior, crashes, or potential information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, use safer string handling functions that include length checks, such as `strnlen`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` function:\n\n```cpp\nsize_t length = strnlen(MetroHash64::test_string, MAX_LENGTH);\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash64::test_string), length);\n```\n\nIn the above code, `MAX_LENGTH` should be the maximum length of `MetroHash64::test_string` that you expect. This will prevent `strnlen` from reading beyond the expected length of the string.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `MetroHash`: A library for non-cryptographic hash functions.\n- `cstring`: A standard C++ library for string handling functions.\n\n## References\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "a2a55aa4-63a3-3581-a057-3b37db7cc643",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to calculate the length of a string, but it does not check if the string is null-terminated. If the string is not null-terminated, `strlen` will continue to read memory until it encounters a null character, which can lead to buffer over-read, causing undefined behavior, crashes, or potential information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Alternatively, use safer string handling functions that include length checks, such as `strnlen`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` function:\n\n```cpp\nsize_t length = strnlen(MetroHash64::test_string, MAX_LENGTH);\nmetro.Update(reinterpret_cast<const uint8_t *>(MetroHash64::test_string), length);\n```\n\nIn the above code, `MAX_LENGTH` should be the maximum length of `MetroHash64::test_string` that you expect. This will prevent `strnlen` from reading beyond the expected length of the string.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `MetroHash`: A library for non-cryptographic hash functions.\n- `cstring`: A standard C++ library for string handling functions.\n\n## References\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "0034256f-25c3-3bd3-a534-473323286eca",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination is a pointer, and the source is an address of a variable, with dataflow analysis indicating that the destination may alias the source. Additionally, the analysis could not rule out the possibility that the source pointer is null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. This type of problem can lead to unpredictable program behavior, crashes, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior caused by overlapping memory regions in the memory copy operation, ensure that the source and destination do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, validate that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (out != nullptr && out != reinterpret_cast<uint8_t*>(&hash)) {\n    memcpy(out, &hash, 8);\n} else if (out != nullptr) {\n    // If overlap is possible, use memmove instead\n    memmove(out, &hash, 8);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "cc53f7e7-6a0e-3fdf-a425-d3cf5cf2a638",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. `strlen` is a function that returns the length of a string. The vulnerability arises when the string passed to `strlen` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before calling `strlen`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the `strlen` function is used on `MetroHash64::test_string`. To fix the vulnerability, you should ensure that `test_string` is null-terminated. Here is a possible fix:\n\n```cpp\nconst char* test_string = \"your_string_here\";\nsize_t length = strlen(test_string);\nif (test_string[length] != '\\0') {\n    test_string[length] = '\\0';\n}\nMetroHash64::Hash(key, strlen(MetroHash64::test_string), hash, 1);\n```\n\n## Library Dependencies\n\nThe code snippet provided seems to be using the MetroHash library. Therefore, the MetroHash library is a dependency for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "fd02be80-d618-31f0-83d8-47275feb8d97",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. This is because `strlen` does not check for null termination and will continue reading memory until it encounters a null byte. If the string is not null-terminated, `strlen` can read past the end of the buffer, leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` such as `strnlen` which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the vulnerability can be fixed by ensuring that `MetroHash64::test_string` is null-terminated before passing it to `strlen`. If `MetroHash64::test_string` is a `std::string`, you can use its `length` or `size` member function instead of `strlen`.\n\n```cpp\nMetroHash64::Hash(key, MetroHash64::test_string.length(), hash, 0)\n```\n\n## Library Dependencies\n\nThe code snippet appears to depend on the MetroHash library. Ensure that this library is properly installed and included in your project.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "caebf481-db3b-30c5-b03c-427a63f73d9f",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source may overlap based on data flow, which can cause undefined behavior with functions like memcpy. Additionally, the source may be null at this call site, further increasing the risk. There are no explicit guards or checks to prevent these issues, and the destination is a pointer type with no known capacity, making it difficult to guarantee safety. These factors collectively indicate a real risk that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping regions safely. Replace the original call with:\n\n```cpp\nmemmove(hash, &h, 8);\n```\n\nThis change ensures that even if `hash` and `&h` overlap, the memory copy will be performed correctly without causing undefined behavior. Additionally, ensure that both `hash` and `&h` are valid pointers and that the destination buffer is large enough to hold 8 bytes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "83ca735c-4206-3b43-a2cc-60a87106d1d9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard ensuring that the source is non-null, which increases the risk of a null pointer dereference. The destination is a pointer type with no known capacity, and the copy length is a fixed value (8 bytes), but the main concern is the potential for overlapping memory regions, which can cause undefined behavior in standard memory copy functions. These factors make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use a memory move function that is safe for overlapping regions. Replace the memory copy operation with a function such as `memmove`, which is designed to handle overlapping memory safely. For example:\n\n```cpp\nmemmove(hash, state.v, 8);\n```\n\nThis change ensures that the operation is well-defined even if the source and destination overlap. Additionally, consider adding explicit checks to ensure that neither pointer is null before performing the operation, to avoid null pointer dereference vulnerabilities.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0722109d-2b1c-3d91-91af-574a7cca8c86",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence that the destination pointer is guaranteed to be non-null before the call, which increases the risk of a crash or further undefined behavior. The source pointer is guarded to be non-null, but the destination is not. The copy length is calculated dynamically and is not directly tied to the capacity of the destination buffer, which further increases the risk. These factors together indicate a high-confidence, actionable issue that should be remediated.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(input.b, ptr, static_cast<size_t>(end - ptr));\n```\n\nAdditionally, ensure that both the source (`ptr`) and destination (`input.b`) pointers are valid and non-null before performing the copy. If the destination pointer can be null, add a check before the call:\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    memmove(input.b, ptr, static_cast<size_t>(end - ptr));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "072c6b54-21eb-3927-a0a0-1c00be8036f2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination are non-null, increasing the risk of null pointer dereference. The absence of explicit bounds checks or guards further increases the likelihood of a real issue. The classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace `memcpy` with `memmove`, which is designed to handle overlapping memory safely. Additionally, ensure that both the source and destination pointers are not null before performing the operation. For example:\n\n```cpp\nif (input.b != nullptr && ptr != nullptr) {\n    memmove(input.b + (bytes % 32), ptr, static_cast<size_t>(fill));\n}\n```\nThis change ensures that the copy operation is safe even if the source and destination regions overlap, and it guards against null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "67b60382-5460-338a-a7a6-8e72bf1c5bce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured Web Link Vulnerability in C++ is not a direct vulnerability in the language itself, but rather a potential security risk that can occur when a C++ application interacts with web resources. This vulnerability arises when a C++ application uses an unsecured (non-HTTPS) link to access web resources. This can expose the application to various attacks such as Man-in-the-Middle (MitM) attacks, where an attacker can intercept and potentially alter the data being transmitted.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use secure HTTPS links when your application needs to access web resources. HTTPS encrypts the data being transmitted, making it much more difficult for an attacker to intercept or alter it.\n\n## Source Code Fix Recommendation\n\nIf you're using a library like libcurl to handle HTTP requests, you can simply replace the unsecured \"http://\" prefix with \"https://\". For example, if the vulnerable code is:\n\n```cpp\nCURL *curl = curl_easy_init();\nif(curl) {\n  CURLcode res;\n  curl_easy_setopt(curl, CURLOPT_URL, \"http://www.apache.org\");\n  /* Perform the request, res will get the return code */ \n  res = curl_easy_perform(curl);\n  /* Check for errors */ \n  if(res != CURLE_OK)\n    fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n            curl_easy_strerror(res));\n  /* always cleanup */ \n  curl_easy_cleanup(curl);\n}\n```\n\nYou can fix the vulnerability by changing the URL to use HTTPS:\n\n```cpp\nCURL *curl = curl_easy_init();\nif(curl) {\n  CURLcode res;\n  curl_easy_setopt(curl, CURLOPT_URL, \"https://www.apache.org\");\n  /* Perform the request, res will get the return code */ \n  res = curl_easy_perform(curl);\n  /* Check for errors */ \n  if(res != CURLE_OK)\n    fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n            curl_easy_strerror(res));\n  /* always cleanup */ \n  curl_easy_cleanup(curl);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the libcurl library.\n\n## OWASP and CWE Links\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "dbc1b88f-07a2-36b0-b778-9e4a51cea174",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null, since there is no prior check ensuring it is valid. These factors make the issue actionable and not a false positive. The classification and verdict both indicate a high-confidence, real problem that could lead to unpredictable program behavior or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use a function that safely handles overlapping regions, such as `memmove` instead of `memcpy`. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```c\nif (ptr != NULL && &val != ptr) {\n    memcpy(&val, ptr, sizeof(val));\n}\n```\n\nIf overlap cannot be ruled out, replace `memcpy` with `memmove`:\n\n```c\nif (ptr != NULL) {\n    memmove(&val, ptr, sizeof(val));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "228c1883-2d8c-3d81-bb95-b4b33fe39a13",
              "help": {
                "text": "",
                "markdown": "## Description\n\nStoring sensitive information such as tokens, keys, or passwords in source code is a security vulnerability. This is because the source code can be easily accessed by unauthorized users, who can then use this sensitive information for malicious purposes. In C++ programming, this vulnerability can occur when developers hard-code sensitive information directly into their source code.\n\nIn the provided code snippet, a string is being stored directly in the source code. If this string was a sensitive token or key, it would be exposed to anyone who has access to the source code.\n\n## Mitigation Advice\n\nAvoid storing sensitive information directly in the source code. Instead, use secure methods to store and retrieve this information, such as environment variables, secure server, or encrypted database. \n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the string directly in the source code, you could store it in an environment variable and then retrieve it in your code. Here's how you could do it:\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* value = std::getenv(\"TEST_STRING\");\nif (value != nullptr) {\n    MetroHash64::test_string = value;\n}\n```\n\nIn this code, `std::getenv` is used to retrieve the value of an environment variable named `TEST_STRING`. This value is then assigned to `MetroHash64::test_string`.\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library to use the `std::getenv` function.\n\n## References\n\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "tags": [
                  "DS173237"
                ]
              }
            },
            {
              "id": "5e09879f-fb86-3c28-a1c9-c777246a5d04",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured Web Link Vulnerability in C++ is not a direct vulnerability in the language itself, but rather a potential security risk that can occur when a C++ application interacts with web resources. This vulnerability arises when a C++ application uses an unsecured (non-HTTPS) link to access web resources. This can expose the application to various attacks such as Man-in-the-Middle (MitM) attacks, where an attacker can intercept and potentially alter the data being transmitted.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use secure HTTPS links when your application needs to access web resources. HTTPS encrypts the data being transmitted, making it much more difficult for an attacker to intercept or alter it.\n\n## Source Code Fix Recommendation\n\nIf you're using a library like libcurl to handle HTTP requests, you can simply replace the unsecured \"http://\" prefix with \"https://\". For example, if the vulnerable code is:\n\n```cpp\nCURL *curl = curl_easy_init();\nif(curl) {\n  CURLcode res;\n  curl_easy_setopt(curl, CURLOPT_URL, \"http://www.apache.org\");\n  /* Perform the request, res will get the return code */ \n  res = curl_easy_perform(curl);\n  /* Check for errors */ \n  if(res != CURLE_OK)\n    fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n            curl_easy_strerror(res));\n  /* always cleanup */ \n  curl_easy_cleanup(curl);\n}\n```\n\nYou can fix the vulnerability by changing the URL to use HTTPS:\n\n```cpp\nCURL *curl = curl_easy_init();\nif(curl) {\n  CURLcode res;\n  curl_easy_setopt(curl, CURLOPT_URL, \"https://www.apache.org\");\n  /* Perform the request, res will get the return code */ \n  res = curl_easy_perform(curl);\n  /* Check for errors */ \n  if(res != CURLE_OK)\n    fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n            curl_easy_strerror(res));\n  /* always cleanup */ \n  curl_easy_cleanup(curl);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the libcurl library.\n\n## OWASP and CWE Links\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "dc6466cb-e6c6-3968-86f5-d2225573b658",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard ensuring the source pointer is non-null, which increases the risk of a null pointer dereference. The destination is not likely to be null, but the source may be. The use of a memory copy function without explicit checks for overlap or null pointers can result in unpredictable program behavior, data corruption, or crashes. These factors make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n**Remediation Example:**\n\n```c\nif (ptr != NULL && &val != ptr) {\n    memcpy(&val, ptr, sizeof(val));\n} else if (ptr != NULL) {\n    // If overlap is possible, use memmove\n    memmove(&val, ptr, sizeof(val));\n}\n```\n\nThis approach first checks for null pointers and then uses `memmove` if there is a possibility of overlap. Always ensure that the size argument does not exceed the actual size of the source and destination objects.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a1e76268-1ade-3948-be17-bb1520e4bf60",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard or check to prevent this overlap. The source pointer may also be null, which further increases the risk of undefined behavior. These factors indicate a real risk of memory corruption or program crashes if the overlap or null pointer dereference occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory regions safely. Replace the original call with:\n\n```cpp\nmemmove(out, v, 16);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "95a20299-6136-3301-afbf-28939d492ea1",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null, as there is no prior check ensuring it is non-null. The destination is not at risk of being null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue. The use of a memory copy function without explicit overlap handling or null checks can lead to unpredictable program behavior, crashes, or security vulnerabilities.\n\n## In Context Remediation\nTo remediate the risk of undefined behavior from overlapping memory regions, replace the memory copy function with one that safely handles overlap, such as `memmove`. Additionally, ensure that the source pointer is checked for null before performing the copy to prevent null pointer dereference. For example:\n\n```c\nif (ptr != NULL) {\n    memmove(&val, ptr, sizeof(val));\n} else {\n    // Handle error: source pointer is null\n}\n```\n\nThis approach ensures that the copy is safe even if the source and destination overlap, and prevents undefined behavior if the source pointer is null.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dae61870-8590-398d-8e46-c133bce55307",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured Web Link Vulnerability in C++ is not a direct vulnerability in the language itself, but rather a potential security risk that can occur when a C++ application interacts with web resources. This vulnerability arises when a C++ application uses an unsecured (non-HTTPS) link to access web resources. This can expose the application to various attacks such as Man-in-the-Middle (MitM) attacks, where an attacker can intercept and potentially alter the data being transmitted.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use secure HTTPS links when your application needs to access web resources. HTTPS encrypts the data being transmitted, making it much more difficult for an attacker to intercept or alter it.\n\n## Source Code Fix Recommendation\n\nIf you're using a library like libcurl to handle HTTP requests, you can simply replace the unsecured \"http://\" prefix with \"https://\". For example, if the vulnerable code is:\n\n```cpp\nCURL *curl = curl_easy_init();\nif(curl) {\n  CURLcode res;\n  curl_easy_setopt(curl, CURLOPT_URL, \"http://www.apache.org\");\n  /* Perform the request, res will get the return code */ \n  res = curl_easy_perform(curl);\n  /* Check for errors */ \n  if(res != CURLE_OK)\n    fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n            curl_easy_strerror(res));\n  /* always cleanup */ \n  curl_easy_cleanup(curl);\n}\n```\n\nYou can fix the vulnerability by changing the URL to use HTTPS:\n\n```cpp\nCURL *curl = curl_easy_init();\nif(curl) {\n  CURLcode res;\n  curl_easy_setopt(curl, CURLOPT_URL, \"https://www.apache.org\");\n  /* Perform the request, res will get the return code */ \n  res = curl_easy_perform(curl);\n  /* Check for errors */ \n  if(res != CURLE_OK)\n    fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",\n            curl_easy_strerror(res));\n  /* always cleanup */ \n  curl_easy_cleanup(curl);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the libcurl library.\n\n## OWASP and CWE Links\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "2207fdc7-d63f-3e87-bfef-b5c6d5005117",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or unauthorized code execution if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking and do not suffer from the same vulnerabilities. In the case of `getenv()`, consider using a method that does not expose sensitive information through environment variables.\n\n## Source Code Fix Recommendation\n\nThe code fix would depend on the specific requirements of your program. If you need to use an environment variable, ensure that it is not controlled by an attacker and that it does not contain sensitive information. If possible, consider using a configuration file or command line arguments instead of environment variables.\n\n```cpp\n// Instead of using getenv(), consider using a configuration file or command line arguments\nchar* options_append = read_config(\"LOADER_OPTIONS_APPEND\");\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library for the `getenv()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6944fd4f-ae9f-314c-8238-22b151255a1c",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is not known or checked before copying data into it. The code copies the contents of a string into a destination buffer using the size of the string as the number of bytes to copy, but there is no evidence that the destination buffer is large enough to hold this data. The destination is a generic pointer, and there are no checks or guards to ensure it is sufficiently sized. The source is a C-style string, which does not reduce the risk. There is no explicit null-termination after the copy, and no overlap or null pointer issues are detected. The lack of capacity checks and the use of a potentially unsafe copy operation make this a high-risk buffer overflow scenario.\n\n## In Context Remediation\nBefore copying data, always ensure that the destination buffer is large enough to hold the source data. If the size of the destination buffer is not known, pass the buffer size as an additional argument and use it to limit the number of bytes copied. For example, if you know the size of the destination buffer (let's call it `value_capacity`), you can use:\n\n```cpp\nsize_t copy_len = std::min(module_name.size(), value_capacity);\nmemcpy(value, module_name.c_str(), copy_len);\n```\n\nThis ensures that you never write more data than the destination can hold, preventing buffer overflows. If possible, also ensure the buffer is null-terminated if it is used as a string.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "efd34705-397d-3edb-a540-a263b04c6e50",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. The `qsort` function is one such function that can lead to this vulnerability. It is a standard library function in C that performs a quicksort on an array. However, it can be misused in a way that leads to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `qsort` function. In C++, the `std::sort` function from the `<algorithm>` library is a safer and more efficient alternative. It is type-safe and does not require a comparison function as a parameter, reducing the risk of misuse.\n\n## Source Code Fix Recommendation\n\nReplace the `qsort` function with the `std::sort` function. Here is an example of how to do this:\n\n```cpp\n#include <algorithm>\n#include <vector>\n\n// Old code using qsort\n// int compare(const void* a, const void* b);\n// qsort(array, size, sizeof(int), compare);\n\n// New code using std::sort\nstd::vector<int> vec = { /* your data */ };\nstd::sort(vec.begin(), vec.end());\n```\n\n## Library Dependencies\n\nThe `std::sort` function requires the `<algorithm>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3f28809a-59d9-3416-af4f-45d3bbc8c282",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0cfd4175-2f0f-39c6-bc06-c3896e02e982",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that the destination may alias the source, which can cause undefined behavior with functions like memcpy. Additionally, there is no evidence of a guard to prevent null pointers for the source, further increasing the risk. The destination is not likely to be null, but the source may be, and there is no explicit check for this. The copy size is a fixed value (16 bytes), but without guarantees about the relationship between the source and destination, this does not mitigate the risk. Therefore, this is a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(out, v, 16);\n```\n\nAdditionally, ensure that both `out` and `v` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (out != nullptr && v != nullptr) {\n    memmove(out, v, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dcc69853-8cd0-3e6a-86b1-1a1d27eba18d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bd2497c8-124c-3e6a-8b8e-13f08d345f78",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `mbstowcs` function in C++ is used to convert a multibyte string to a wide character string. However, it can lead to vulnerabilities if not used properly. The function does not perform any bounds checking on the destination buffer, which can lead to buffer overflow if the source string is longer than the destination buffer. This can lead to arbitrary code execution or denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the converted string, including the null terminator. You should also consider using safer alternatives that perform bounds checking, such as `mbstowcs_s` or `mbsrtowcs`.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use `mbstowcs_s` to safely convert a multibyte string to a wide character string:\n\n```cpp\n#include <locale.h>\n#include <wchar.h>\n#include <stdlib.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.utf8\");\n    const char* mbstr = \"multibyte string\";\n    size_t len = mbstowcs(NULL, mbstr, 0) + 1;\n    wchar_t* wcstr = new wchar_t[len];\n    size_t converted;\n    mbstowcs_s(&converted, wcstr, len, mbstr, _TRUNCATE);\n    // use wcstr\n    delete[] wcstr;\n    return 0;\n}\n```\n\nIn this example, `mbstowcs` is first used to calculate the length of the converted string, then `mbstowcs_s` is used to perform the conversion. The `_TRUNCATE` option ensures that the conversion is safely truncated if the source string is too long.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- locale.h\n- wchar.h\n- stdlib.h\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cfcb1335-dd49-35c3-84e0-94d60d82a839",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0dc0d5d1-db82-34b6-85c7-94baee06983c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nIf `pStrValue` is a pointer to a string, ensure it is null-terminated before passing it to `strlen()`. If the length of the string is known at compile time, consider using `strnlen()` instead.\n\n```cpp\n// Ensure pStrValue is null-terminated\nif (pStrValue != nullptr) {\n    size_t len = strnlen(pStrValue, MAX_LENGTH);\n}\n```\n\nIn this example, `MAX_LENGTH` should be replaced with the maximum expected length of the string. If the string is longer than `MAX_LENGTH`, `strnlen()` will return `MAX_LENGTH`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "18b7a1ef-9e54-3560-8965-a7c274267012",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function in question is `atof`.\n\nThe `atof` function converts a string to a double. It does not check for overflow or underflow, and it does not report any errors. This can lead to unexpected behavior if the string cannot be represented as a double.\n\n## Mitigation Advice\n\nAvoid using the `atof` function. Instead, use safer alternatives such as `strtod` or `sscanf`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atof` function with `strtod` or `sscanf`. Here is an example of how to use `strtod`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char* str = \"123.45\";\nchar* endptr;\nerrno = 0; // To distinguish success/failure after call\ndouble val = strtod(str, &endptr);\n\n// Check for various possible errors\nif ((errno == ERANGE && (val == HUGE_VALF || val == HUGE_VALL)) || (errno != 0 && val == 0)) {\n    perror(\"strtod\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == str) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\n// If we got here, strtod() successfully parsed a number\nprintf(\"strtod() returned %f\\n\", val);\n\nif (*endptr != '\\0') // Not necessarily an error...\n    printf(\"Further characters after number: %s\\n\", endptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- cstdlib\n- cerrno\n- cstdio\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5cb85615-ab6a-31d9-8e2c-757b29c46957",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It returns the number of characters in a string up to but not including the first null character. The vulnerability arises when the string does not have a null character, causing `strlen()` to read beyond the intended memory, leading to a buffer overflow. This can result in crashes, incorrect behavior, or allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that are not guaranteed to be null-terminated. Instead, use safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(pDst)` with `strnlen(pDst, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of the string.\n\n```cpp\n#include <string.h>\n\n#define MAX_LENGTH 100\n\n// ...\n\nsize_t length = strnlen(pDst, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strnlen()` function is part of the `<string.h>` library in C++.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "46e2d68e-426a-3048-b85e-f01421e9076d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncat` function in C++ is considered unsafe because it can lead to buffer overflow vulnerabilities. This function appends the source string to the destination string up to n characters. If the size of the destination buffer is not properly managed, it can lead to buffer overflow, which can cause the program to crash or lead to code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that are available in C++. For example, you can use the `strlcat` function which is designed to be safer, or you can use the string class in C++ which automatically manages the memory.\n\n## Source Code Fix Recommendation\n\nReplace the `strncat` function with `strlcat` function or use C++ string class.\n\n```cpp\n// Using strlcat\nsize_t sizeDst = sizeof(pDst);\nsize_t dstLength = strnlen(pDst, sizeDst);\nif (dstLength == sizeDst) {\n    // Handle error: pDst was not null-terminated.\n} else if (strlcat(pDst, pSrc, sizeDst) >= sizeDst) {\n    // Handle error: pDst is not large enough.\n}\n\n// Using C++ string class\nstd::string dst(pDst);\nstd::string src(pSrc);\ndst += src;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstring` or `string.h` for `strncat` and `strlcat` functions.\n- `string` for C++ string class.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "a6988277-a364-38ff-8910-1afcbd631356",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a high risk: the destination buffer's capacity is unknown, and the number of bytes being copied is not proven to be within the bounds of the destination. The code copies the contents of a string (using its size) into a destination pointer without verifying that the destination is large enough to hold the data. There are no checks or guards present to ensure the destination buffer is sufficiently sized, and there is no evidence that the length argument is derived from the destination's capacity. The source is a C-style string, which is generally safe, but this does not mitigate the risk of overflowing the destination buffer. The destination pointer type and lack of explicit capacity information further increase the risk of a buffer overflow.\n\n## In Context Remediation\nBefore copying data from the string to the destination buffer, ensure that the destination buffer is large enough to hold the data. If the size of the destination buffer is not known, you must either pass the buffer size as an additional argument or use a safer alternative. For example, if you know the size of the destination buffer (let's say `value_size`), you can add a check and limit the number of bytes copied:\n\n```cpp\nsize_t copy_len = std::min(symbol_name.size(), value_size);\nmemcpy(value, symbol_name.c_str(), copy_len);\n```\n\nIf you do not know the size of the destination buffer, refactor the code to ensure this information is available at the call site. Never copy more bytes than the destination can hold.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d479c29b-2771-3785-86f1-1eafd827d1ed",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. One such function is `wcsncat`.\n\nThe `wcsncat` function is a wide-character string function that appends not more than `n` wide-characters from a source string to the end of a destination string. The vulnerability arises when the size of the destination buffer is not properly managed, leading to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `wcsncat` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that include bounds checking such as `wcsncat_s` (in the case of Microsoft's implementation of C++), or use C++ strings (`std::wstring`) which are safer and easier to use.\n\n## Source Code Fix Recommendation\n\nInstead of using `wcsncat`, use `std::wstring`:\n\n```cpp\n#include <string>\n\nint main() {\n    std::wstring str1 = L\"Hello, \";\n    std::wstring str2 = L\"World!\";\n    str1 += str2; // This is safe\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b3b94754-8355-30fa-ae1f-1cfdf721771d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcslen` function is one of these prohibited functions. It is used to calculate the length of a wide string, but it does not check for null termination and can therefore cause a buffer overflow if the string is not properly terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `wcslen` and other prohibited C functions. Instead, use safer alternatives that include bounds checking or null termination checking. In the case of `wcslen`, you can use `std::wstring::length` or `std::wstring::size` as safer alternatives.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cwchar>\n\n// ...\n\nwchar_t wide_string[] = L\"Hello, World!\";\nsize_t length = wcslen(wide_string);\n```\n\nUse:\n\n```cpp\n#include <string>\n\n// ...\n\nstd::wstring wide_string = L\"Hello, World!\";\nsize_t length = wide_string.length();\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4517ca83-ccfb-3f9d-9aa7-02b562597bfd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `wcsncpy` function is one of these prohibited functions. It is used to copy a certain number of characters from one wide string to another. However, if the source string length is less than the number of characters to be copied, `wcsncpy` does not null-terminate the destination string, which can lead to buffer overflows.\n\n## Mitigation Advice\n\nAvoid using `wcsncpy` and other prohibited C functions. Instead, use safer alternatives that do not have these vulnerabilities. For example, consider using `wcsncpy_s` or `wmemcpy_s` which are safer as they null-terminate the destination string.\n\n## Source Code Fix Recommendation\n\nReplace `wcsncpy` with `wcsncpy_s` or `wmemcpy_s`. Here is an example:\n\n```cpp\n// Old vulnerable code\nwchar_t dest[100];\nwcsncpy(dest, src, 100);\n\n// Fixed code using wcsncpy_s\nwchar_t dest[100];\nwcsncpy_s(dest, 100, src, _TRUNCATE);\n\n// Or using wmemcpy_s\nwchar_t dest[100];\nwmemcpy_s(dest, 100, src, wcsnlen(src, 100));\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <wchar.h>\n```\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7e61ac96-db2d-3e4d-aedd-fd3edffa3fcb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. It takes a string as an argument and returns its length. The vulnerability arises when the string passed to `strlen()` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen()` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be read.\n\n## Source Code Fix Recommendation\n\nIf `pSrc` is the string being passed to `strlen()`, ensure it is null-terminated:\n\n```cpp\nchar pSrc[] = \"Hello, World!\";\nsize_t len = strlen(pSrc);\n```\n\nOr use `strnlen()` instead:\n\n```cpp\nchar pSrc[] = \"Hello, World!\";\nsize_t len = strnlen(pSrc, sizeof(pSrc));\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "49f26f4a-0d12-386d-9fc2-675fd23f8c36",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. \n\nOne such function is `atoi()`, which converts a string to an integer. The `atoi()` function does not perform any error checking, so if the string cannot be converted into an integer, it will return zero, which can lead to unexpected behavior if not handled properly.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. In the case of `atoi()`, a safer alternative is `strtol()`, which allows you to check if the entire string was successfully converted to an integer.\n\n## Source Code Fix Recommendation\n\nReplace `atoi()` with `strtol()`. Here is an example:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char *str = \"123\";\nchar *end;\nlong num = strtol(str, &end, 10);\n\nif (end == str || *end != '\\0' || errno == ERANGE) {\n    // str was not a valid integer\n} else {\n    // num is the converted integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- cerrno\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a07e0391-1fc1-3da9-bbdb-bc6c30f91d8c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflows. This function copies a string from one location to another, but it does not automatically append a null character at the end of the string. If the source string is longer than the destination buffer, this can lead to buffer overflow, which can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source string and the null character. You should also consider using safer string handling functions that automatically handle null termination, such as `strlcpy` or `strncpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `strncpy_s`:\n\n```cpp\n// Using strlcpy\nstrlcpy(pDst, pSrc, dstSize);\n\n// Using strncpy_s\nstrncpy_s(pDst, dstSize, pSrc, _TRUNCATE);\n```\n\nNote: `strlcpy` and `strncpy_s` are not standard C++ functions and may not be available on all platforms. If they are not available, you can manually ensure null termination:\n\n```cpp\nstrncpy(pDst, pSrc, dstSize - 1);\npDst[dstSize - 1] = '\\0';\n```\n\n## Library Dependencies\n\nThe `strncpy`, `strlcpy`, and `strncpy_s` functions are part of the C standard library, so you need to include the `cstring` or `string.h` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "3c199c27-0ee1-38f1-8fbe-93c048fec2c4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable program behavior, data corruption, or crashes. The verdict is supported by the classification and the explicit 'GENUINE' verdict. There are no guards ensuring non-overlap, and the types and expressions involved do not provide evidence of safety. Both the source and destination are confirmed to be non-null, but the overlap risk remains the primary concern.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely.\n\n```cpp\nmemmove(buf, buffer, bufferSize);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "acf2911c-0eb8-3ceb-96df-be78cb82d49c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, the source pointer may be null, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly defined, increasing the risk. Developers should address both the potential for overlapping memory regions and the possibility of null pointers to ensure safe and predictable behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy. For example:\n\n```cpp\nif (dest != nullptr && edata->d_buf != nullptr) {\n    memmove(dest, (const char*) edata->d_buf + offset - coffset, csize);\n}\n```\nThis change ensures that the copy operation is safe even if the memory regions overlap and avoids dereferencing null pointers.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "86cac946-bb45-354c-a07e-557143427fb8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other security problems. The `getenv` function is one such function. It returns a pointer to a string that is associated with the matched environment variable name. This can lead to security vulnerabilities if the returned string is modified, or if the program does not handle the possibility that `getenv` could return a null pointer if the specified environment variable does not exist.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `getenv` function. Instead, consider using safer alternatives that are less prone to security issues. Always validate and sanitize input, and handle the possibility of null pointers. \n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, you can use a safer alternative like `getenv_s`. Here is an example of how to use it:\n\n```cpp\n#include <stdlib.h>\n\nchar* value;\nsize_t requiredSize;\n\ngetenv_s(&requiredSize, NULL, 0, \"ENV_VAR\");\nif (requiredSize == 0)\n{\n    printf(\"The environment variable does not exist.\\n\");\n}\nelse\n{\n    value = (char*) malloc(requiredSize * sizeof(char));\n    if (value != NULL)\n    {\n        getenv_s(&requiredSize, value, requiredSize, \"ENV_VAR\");\n        printf(\"The value of the environment variable is: %s\\n\", value);\n    }\n    free(value);\n}\n```\n\nIn this code, `getenv_s` is used to safely get the value of an environment variable. It checks if the environment variable exists and handles the possibility of a null pointer.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e3e3f85a-d40a-30ab-b258-c58df38ee735",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or code execution vulnerabilities if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, consider using a method that does not involve environment variables to enable logging. If you must use environment variables, ensure that they are properly sanitized and validated before use.\n\n## Source Code Fix Recommendation\n\n```cpp\n// Instead of using getenv(), consider using a configuration file or command line argument to enable logging.\n// If you must use an environment variable, ensure it is properly sanitized and validated.\n\nconst char* env_var = getenv(\"LOADER_ENABLE_LOGGING\");\nif(env_var != NULL) {\n    std::string logging_env(env_var);\n    // Perform sanitization and validation on logging_env before use\n    enable_logging = logging_env;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::string`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bd5d3a33-72bb-3290-b3ab-c7943d24f9ff",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. In this case, the function `alloca()` is used, which is considered unsafe. The `alloca()` function dynamically allocates memory on the stack, which can lead to buffer overflow vulnerabilities if not properly managed. This is because the allocated memory is not initialized and can contain sensitive information. Additionally, the function does not provide any mechanism for error handling if the stack overflows.\n\n## Mitigation Advice\n\nAvoid using the `alloca()` function. Instead, use safer alternatives such as `malloc()`, `calloc()`, or `new` for dynamic memory allocation. These functions allocate memory on the heap, not the stack, and provide error handling mechanisms. Always ensure to properly manage and free dynamically allocated memory to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with a safer alternative. Here's how you can do it with `new`:\n\n```cpp\ntry {\n    sdata = new unsigned char[section->size()];\n} catch (std::bad_alloc& ba) {\n    std::cerr << \"bad_alloc caught: \" << ba.what() << '\\n';\n}\n```\n\nRemember to free the allocated memory when you're done with it:\n\n```cpp\ndelete[] sdata;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<new>`: This is required for the `new` operator and `std::bad_alloc` exception.\n- `<iostream>`: This is required for `std::cerr`.\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "826a85ab-88b9-3ca8-a1a1-3b506d9f7a9a",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior when using memory copy operations like memcpy. There are no explicit checks or guards in the code to prevent this overlap, and the function does not ensure that the source and destination are distinct. The source and destination are both identified as variables, and the offset calculation on the destination further increases the risk. The source and destination are also confirmed to be non-null, so the main concern is the overlap, not null pointer dereference.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove((char *) dst + offset, src, size);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a8b62123-502e-32e3-8557-585aa866e46b",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable program behavior or data corruption. The verdict is supported by the classification and the high-confidence 'GENUINE' label. There are no explicit checks or guards to prevent this overlap, and neither the source nor the destination is null at the call site, which means the operation will proceed and may trigger undefined behavior if overlap occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(*buf, buffer, bufferSize);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination memory regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3feca8a5-d11f-3fc2-822b-b243311c1ca8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `snprintf`.\n\nAdditionally, consider using higher level abstractions provided by C++ such as `std::string` or `std::vector` that manage memory automatically and are less prone to such vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative like `strncpy`. Here's how you can do it:\n\n```cpp\nstrncpy(svalue, isa.c_str(), std::min(sizeof(svalue), isa.size()));\n```\n\nIn this case, `sizeof(svalue)` ensures that we do not exceed the size of the destination buffer.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` and `strncpy` functions.\n- `<algorithm>`: This library provides the `std::min` function.\n- `<string>`: This library provides the `std::string` class.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f02ecc06-d5b0-30ac-b862-b3b3f272cb81",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` or `strerror_s()`. Also, consider using exception handling for error reporting instead of directly writing error messages to the output.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nchar buf[1024];\nif(strerror_r(errno, buf, sizeof(buf)) == 0) {\n    out << \"Error: \" << msg << \": \" << buf << std::endl;\n} else {\n    out << \"Error: \" << msg << std::endl;\n}\n```\n\n## Library Dependencies\n\n- `<string.h>`: This header file contains declaration of various string handling functions including `strerror_r()`.\n- `<errno.h>`: This header file defines macros for reporting error conditions.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bd306526-e36b-3f8b-81d2-224c6f1b0ee8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before the `memcpy` function is called. \n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <cstring>\n#include <algorithm>\n#include <string>\n\nvoid safe_memcpy(char* svalue, const std::string& version, size_t max_size) {\n    size_t copy_size = std::min(version.size(), max_size - 1);\n    memcpy(svalue, version.c_str(), copy_size);\n    svalue[copy_size] = '\\0'; // Ensure null termination\n}\n```\n\nIn this code, `std::min` is used to ensure that the size of the data being copied does not exceed the size of the destination buffer. The `- 1` is to leave space for the null terminator.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<algorithm>`: This library provides the `std::min` function.\n- `<string>`: This library provides the `std::string` class.\n\n## OWASP and CWE Links\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a later date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bb2bf0fb-3cb1-3433-bebf-3237240042f6",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that either the source or destination pointer may be null. The code copies data from a string object's internal buffer to a destination pointer, but there is no evidence of a check to ensure that the destination pointer is valid (not null) before the copy occurs. The source is a string's internal buffer, which is generally safe, but the destination pointer could be null, leading to a crash or undefined behavior. The absence of a guard or validation for the destination pointer increases the risk. The probability of this being a false positive is very low, as the analysis specifically points out the lack of null checks for the destination pointer.\n\n## In Context Remediation\nBefore copying data to the destination buffer, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the pointer is invalid. For example:\n\n```cpp\nif (desc->producer_options != nullptr) {\n    memcpy(desc->producer_options, options.c_str(), options.length() + 1);\n} else {\n    // Handle error: destination buffer is null\n}\n```\nThis prevents undefined behavior by ensuring the destination pointer is valid before performing the memory copy. Always validate pointers before use to avoid crashes or security vulnerabilities.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e97a9f54-b3fd-3837-8d76-9c24aa2f005e",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that either the source or destination pointer may be null, and there are no obvious null pointer checks before the memory copy operation. The verdict for this call site is also marked as 'GENUINE', confirming the high confidence in the issue. The source is a C++ string's c_str(), which is generally safe, but the destination pointer may be null, as there is no evidence of a guard or check to ensure it is valid before use. This can lead to a crash or other undefined behavior if the destination is null. The probability of this being a false positive is very low, as the analysis found no mitigating factors such as pointer validation or bounds checks.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer is not null. Add an explicit check to prevent undefined behavior if the destination is invalid. For example:\n\n```cpp\nif (desc && desc->vendor_and_architecture_name) {\n    memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length() + 1);\n} else {\n    // Handle error: destination is null\n}\n```\n\nThis check ensures that the destination pointer is valid before attempting to copy memory, preventing a potential crash or undefined behavior.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f023fa97-adeb-35a3-a647-670a919f583c",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict is marked as genuine. The code copies data from a C++ string's internal buffer to a destination buffer using a memory copy operation. There is no evidence of a check to ensure that the destination pointer is not null before the copy occurs. The analysis also notes that the destination pointer may be null, which could lead to a crash or undefined behavior if the function is called with an uninitialized or invalid pointer. The source is a C++ string's c_str(), which is generally safe, but the lack of a null check on the destination is a significant risk. No guard or explicit null check is present, and the destination's capacity is not verified, increasing the risk of a security issue.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer is not null. Add a check to verify that the destination buffer is valid. If the pointer can be null, handle the error appropriately (e.g., return an error code, throw an exception, or log the issue).\n\n```cpp\nif (desc && desc->producer_name) {\n    memcpy(desc->producer_name, producer.c_str(), producer.length() + 1);\n} else {\n    // Handle error: destination is null\n}\n```\n\nAdditionally, consider verifying that the destination buffer is large enough to hold the source string plus the null terminator to prevent buffer overflows.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bffdaaa1-76ab-3e95-8a13-940540c1e318",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible null pointer dereference, and the verdict is marked as genuine. The code copies data from a C-style string into a destination buffer, but there is no evidence of checks to ensure that the destination pointer is not null. The analysis also notes that the destination pointer may be null, which could lead to a crash or other undefined behavior if the function is called with an invalid pointer. The source is a C-style string, which is generally safe, but the lack of null checks on the destination is a significant risk. There are no guards or capacity checks present, and the length is not derived from the buffer's capacity, increasing the risk of error. Developers should ensure that the destination pointer is valid before performing the copy operation.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the destination pointer is not null. Add an explicit check to validate the destination buffer. If the pointer is null, handle the error appropriately (e.g., return an error code, throw an exception, or log the error).\n\n```cpp\nif (desc && desc->vendor_and_architecture_name) {\n    memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length() + 1);\n} else {\n    // Handle error: destination buffer is null\n}\n```\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "7f0f1355-009b-37e5-aabb-cf87bcee6439",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 41,
                  "endLine": 150,
                  "endColumn": 49,
                  "charOffset": 4364,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "46e4b884-19a6-3b2e-b3cc-7675d0df9310",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palSysUtil.h"
                },
                "region": {
                  "startLine": 283,
                  "startColumn": 89,
                  "endLine": 283,
                  "endColumn": 97,
                  "charOffset": 8407,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f61a2dd6-75cd-3fc7-97e9-072c0ba77509",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 1548,
                  "startColumn": 8,
                  "endLine": 1548,
                  "endColumn": 39,
                  "charOffset": 55012,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(buf, buffer, bufferSize)",
                    "rendered": {
                      "text": "memcpy(buf, buffer, bufferSize)",
                      "markdown": "`memcpy(buf, buffer, bufferSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55012,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf, <size of buf>,  buffer,  bufferSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a264f514-f15e-34cd-874f-1ec03962384e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 1536,
                  "startColumn": 8,
                  "endLine": 1536,
                  "endColumn": 40,
                  "charOffset": 54707,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(*buf, buffer, bufferSize)",
                    "rendered": {
                      "text": "memcpy(*buf, buffer, bufferSize)",
                      "markdown": "`memcpy(*buf, buffer, bufferSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 54707,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(*buf, <size of *buf>,  buffer,  bufferSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "95fddd09-d749-38bd-a5a9-f2469bd4955a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 998,
                  "startColumn": 10,
                  "endLine": 998,
                  "endColumn": 76,
                  "charOffset": 37537,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)",
                    "rendered": {
                      "text": "memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)",
                      "markdown": "`memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37537,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  (const char*) edata->d_buf + offset - coffset,  csize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ffb4ac61-f8cd-3e05-94b1-7a197a03546a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 647,
                  "startColumn": 4,
                  "endLine": 647,
                  "endColumn": 55,
                  "charOffset": 25390,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)",
                    "rendered": {
                      "text": "memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)",
                      "markdown": "`memcpy(ppNextGroup, &pNextGroup, sizeof(pNextGroup)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25390,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ppNextGroup, <size of ppNextGroup>,  &pNextGroup,  sizeof(pNextGroup)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "93b00377-4f43-3238-86fc-eb501c193fe7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 33,
                  "endLine": 175,
                  "endColumn": 44,
                  "charOffset": 8328,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(key)",
                    "rendered": {
                      "text": "strlen(key)",
                      "markdown": "`strlen(key)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8328,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(key, <size of key>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8328,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(key, <size of key>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bb760f13-5082-39e3-b482-c4a1f7f6e77d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1562,
                  "startColumn": 4,
                  "endLine": 1562,
                  "endColumn": 9,
                  "charOffset": 51229,
                  "charLength": 5,
                  "snippet": {
                    "text": "qsort",
                    "rendered": {
                      "text": "qsort",
                      "markdown": "`qsort`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "91d1816c-047e-393f-8773-388004e6a000",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 629,
                  "startColumn": 4,
                  "endLine": 629,
                  "endColumn": 55,
                  "charOffset": 24712,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)",
                    "rendered": {
                      "text": "memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)",
                      "markdown": "`memcpy(&pNextGroup, ppNextGroup, sizeof(pNextGroup)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24712,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&pNextGroup, <size of &pNextGroup>,  ppNextGroup,  sizeof(pNextGroup)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "14547da1-a929-32d9-94a5-57fdee039bc9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1523,
                  "startColumn": 11,
                  "endLine": 1523,
                  "endColumn": 17,
                  "charOffset": 49834,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "66860efa-ae9c-3b89-b663-3509bc4b6663",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1389,
                  "startColumn": 8,
                  "endLine": 1389,
                  "endColumn": 14,
                  "charOffset": 46029,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "dbfc6967-431e-39b0-adf5-e5493a76a8de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 611,
                  "startColumn": 4,
                  "endLine": 611,
                  "endColumn": 55,
                  "charOffset": 24051,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(pNumEntries, &numEntries, sizeof(numEntries)",
                    "rendered": {
                      "text": "memcpy(pNumEntries, &numEntries, sizeof(numEntries)",
                      "markdown": "`memcpy(pNumEntries, &numEntries, sizeof(numEntries)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24051,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pNumEntries, <size of pNumEntries>,  &numEntries,  sizeof(numEntries)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "27c88cea-8164-32dd-bd14-5ba4a266bd59",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                },
                "region": {
                  "startLine": 593,
                  "startColumn": 4,
                  "endLine": 593,
                  "endColumn": 55,
                  "charOffset": 23372,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(&numEntries, pNumEntries, sizeof(numEntries)",
                    "rendered": {
                      "text": "memcpy(&numEntries, pNumEntries, sizeof(numEntries)",
                      "markdown": "`memcpy(&numEntries, pNumEntries, sizeof(numEntries)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palHashBaseImpl.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23372,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&numEntries, <size of &numEntries>,  pNumEntries,  sizeof(numEntries)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fcbdea81-f4dc-3c88-9ae3-a3aed4e82733",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1337,
                  "startColumn": 21,
                  "endLine": 1337,
                  "endColumn": 29,
                  "charOffset": 44476,
                  "charLength": 8,
                  "snippet": {
                    "text": "mbstowcs",
                    "rendered": {
                      "text": "mbstowcs",
                      "markdown": "`mbstowcs`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f80cba1d-8748-30cc-bf6d-1d1a88aa3eb5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1043,
                  "startColumn": 60,
                  "endLine": 1043,
                  "endColumn": 64,
                  "charOffset": 34335,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ae2a2a56-1acd-3e30-8625-ecaec16dad0b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1016,
                  "startColumn": 42,
                  "endLine": 1016,
                  "endColumn": 46,
                  "charOffset": 33109,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1c232ed6-4581-31d2-8376-b4c3daa5394f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1072,
                  "startColumn": 23,
                  "endLine": 1072,
                  "endColumn": 40,
                  "charOffset": 35502,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(pStrValue)",
                    "rendered": {
                      "text": "strlen(pStrValue)",
                      "markdown": "`strlen(pStrValue)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35502,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(pStrValue, <size of pStrValue>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35502,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(pStrValue, <size of pStrValue>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e65a9b96-e9eb-3f01-a360-56edb3b52a6c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 947,
                  "startColumn": 31,
                  "endLine": 947,
                  "endColumn": 37,
                  "charOffset": 30732,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bbd0a3bf-4e37-35b3-904c-27cc17e25837",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 967,
                  "startColumn": 29,
                  "endLine": 967,
                  "endColumn": 41,
                  "charOffset": 31544,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pDst)",
                    "rendered": {
                      "text": "strlen(pDst)",
                      "markdown": "`strlen(pDst)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31544,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pDst, <size of pDst>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31544,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pDst, <size of pDst>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "af38c419-aa2e-3bb7-b241-a4971a9ee83f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 948,
                  "startColumn": 4,
                  "endLine": 948,
                  "endColumn": 11,
                  "charOffset": 30750,
                  "charLength": 7,
                  "snippet": {
                    "text": "wcsncat",
                    "rendered": {
                      "text": "wcsncat",
                      "markdown": "`wcsncat`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2ef7e877-fdbb-39aa-9260-7f4516f216c6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncat)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 968,
                  "startColumn": 4,
                  "endLine": 968,
                  "endColumn": 50,
                  "charOffset": 31562,
                  "charLength": 46,
                  "snippet": {
                    "text": "strncat(pDst, pSrc, (sizeDst - dstLength - 1))",
                    "rendered": {
                      "text": "strncat(pDst, pSrc, (sizeDst - dstLength - 1))",
                      "markdown": "`strncat(pDst, pSrc, (sizeDst - dstLength - 1))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31562,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strcat_s(pDst,  (sizeDst - dstLength - 1,  pSrc)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31562,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strlcat(pDst,  pSrc,  (sizeDst - dstLength - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "16800e0e-e2ec-3bf0-9913-e16dab2cc7ee",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 933,
                  "startColumn": 4,
                  "endLine": 933,
                  "endColumn": 11,
                  "charOffset": 30377,
                  "charLength": 7,
                  "snippet": {
                    "text": "wcsncpy",
                    "rendered": {
                      "text": "wcsncpy",
                      "markdown": "`wcsncpy`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "839e3166-f684-3e4a-9a04-e7c8d5f073a4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 910,
                  "startColumn": 14,
                  "endLine": 910,
                  "endColumn": 26,
                  "charOffset": 29664,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pSrc)",
                    "rendered": {
                      "text": "strlen(pSrc)",
                      "markdown": "`strlen(pSrc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29664,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pSrc, <size of pSrc>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29664,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pSrc, <size of pSrc>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4de44d95-f69f-3726-91da-5363aa281948",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 1442,
                  "startColumn": 45,
                  "endLine": 1442,
                  "endColumn": 51,
                  "charOffset": 56567,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "faad9572-9715-3ab5-aee8-aef01a41a77a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 918,
                  "startColumn": 8,
                  "endLine": 918,
                  "endColumn": 42,
                  "charOffset": 29902,
                  "charLength": 34,
                  "snippet": {
                    "text": "strncpy(pDst, pSrc, (dstSize - 1))",
                    "rendered": {
                      "text": "strncpy(pDst, pSrc, (dstSize - 1))",
                      "markdown": "`strncpy(pDst, pSrc, (dstSize - 1))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29902,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strcpy_s(pDst,  (dstSize - 1,  pSrc)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29902,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strlcpy(pDst,  pSrc,  (dstSize - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "669110e0-0b4e-308c-bc38-bd56a128d845",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 882,
                  "startColumn": 6,
                  "endLine": 882,
                  "endColumn": 70,
                  "charOffset": 35550,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(desc->producer_options, options.c_str(), options.length()",
                    "rendered": {
                      "text": "memcpy(desc->producer_options, options.c_str(), options.length()",
                      "markdown": "`memcpy(desc->producer_options, options.c_str(), options.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35550,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->producer_options, <size of desc->producer_options>,  options.c_str(),  options.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cf27b0bd-9eb2-3064-a233-372e7a4ad5df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 863,
                  "startColumn": 6,
                  "endLine": 863,
                  "endColumn": 69,
                  "charOffset": 34685,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy(desc->producer_name, producer.c_str(), producer.length()",
                    "rendered": {
                      "text": "memcpy(desc->producer_name, producer.c_str(), producer.length()",
                      "markdown": "`memcpy(desc->producer_name, producer.c_str(), producer.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34685,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->producer_name, <size of desc->producer_name>,  producer.c_str(),  producer.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "98711838-b742-3cb5-b15b-8cf8f4837a03",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 927,
                  "startColumn": 8,
                  "endLine": 927,
                  "endColumn": 46,
                  "charOffset": 37284,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(svalue, isa.c_str(), (std::min)",
                    "rendered": {
                      "text": "memcpy(svalue, isa.c_str(), (std::min)",
                      "markdown": "`memcpy(svalue, isa.c_str(), (std::min)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37284,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svalue, <size of svalue>,  isa.c_str(),  (std::min)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3c8fd508-6560-3ad9-a74f-61fb110e8346",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 917,
                  "startColumn": 8,
                  "endLine": 917,
                  "endColumn": 50,
                  "charOffset": 36853,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(svalue, version.c_str(), (std::min)",
                    "rendered": {
                      "text": "memcpy(svalue, version.c_str(), (std::min)",
                      "markdown": "`memcpy(svalue, version.c_str(), (std::min)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36853,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svalue, <size of svalue>,  version.c_str(),  (std::min)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7f68a7ab-d6b9-3cd8-ad24-83a26e0db8af",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 10,
                  "endLine": 138,
                  "endColumn": 61,
                  "charOffset": 4337,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(value, SymbolName.c_str(), SymbolName.size()",
                    "rendered": {
                      "text": "memcpy(value, SymbolName.c_str(), SymbolName.size()",
                      "markdown": "`memcpy(value, SymbolName.c_str(), SymbolName.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4337,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  SymbolName.c_str(),  SymbolName.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "22f480ac-e07f-3381-af0c-929a9f303569",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palFile.h"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 46,
                  "endLine": 101,
                  "endColumn": 51,
                  "charOffset": 4300,
                  "charLength": 5,
                  "snippet": {
                    "text": "ctime",
                    "rendered": {
                      "text": "ctime",
                      "markdown": "`ctime`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0c641e70-a4bf-39bb-8dec-8f01b17da127",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 541,
                  "startColumn": 6,
                  "endLine": 541,
                  "endColumn": 127,
                  "charOffset": 17819,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()",
                    "rendered": {
                      "text": "memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()",
                      "markdown": "`memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17819,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->vendor_and_architecture_name + desc->vendor_name_size, <size of desc->vendor_and_architecture_name + desc->vendor_name_size>,  architecture_name.c_str(),  architecture_name.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e3fd4ef2-315e-3d0d-9a71-1331a181b35b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 540,
                  "startColumn": 6,
                  "endLine": 540,
                  "endColumn": 90,
                  "charOffset": 17722,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()",
                    "rendered": {
                      "text": "memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()",
                      "markdown": "`memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17722,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->vendor_and_architecture_name, <size of desc->vendor_and_architecture_name>,  vendor_name.c_str(),  vendor_name.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b6266cdf-388a-32b1-a24e-cede5da62cb2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palFile.h"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 46,
                  "endLine": 97,
                  "endColumn": 51,
                  "charOffset": 3986,
                  "charLength": 5,
                  "snippet": {
                    "text": "ctime",
                    "rendered": {
                      "text": "ctime",
                      "markdown": "`ctime`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "513e94e1-98a1-31ef-a20f-d8f6e0d5d190",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 10,
                  "endLine": 148,
                  "endColumn": 61,
                  "charOffset": 4717,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(value, ModuleName.c_str(), ModuleName.size()",
                    "rendered": {
                      "text": "memcpy(value, ModuleName.c_str(), ModuleName.size()",
                      "markdown": "`memcpy(value, ModuleName.c_str(), ModuleName.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4717,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  ModuleName.c_str(),  ModuleName.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "da7820f5-9613-3c86-ba36-a6aa5d6f7d94",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Link Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 7,
                  "endLine": 9,
                  "endColumn": 28,
                  "charOffset": 257,
                  "charLength": 21,
                  "snippet": {
                    "text": "http://www.apache.org",
                    "rendered": {
                      "text": "http://www.apache.org",
                      "markdown": "`http://www.apache.org`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 257,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "https://www.apache.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "7cfc9662-ee41-3bd7-a480-f46d73ae4816",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 4,
                  "endLine": 175,
                  "endColumn": 22,
                  "charOffset": 5745,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5745,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "eb1f2896-6ed5-3dc2-b53c-83adcb8e4291",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 416,
                  "startColumn": 4,
                  "endLine": 416,
                  "endColumn": 22,
                  "charOffset": 14782,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14782,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4c14e51b-cf48-3365-9860-832e94fd51c9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 4,
                  "endLine": 99,
                  "endColumn": 22,
                  "charOffset": 3269,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3269,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "19d646e3-6924-3361-a829-df4f1ae6e1ef",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 79,
                  "endLine": 256,
                  "endColumn": 112,
                  "charOffset": 9344,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9344,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9344,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2a4db397-3252-3431-86a7-cf0ca0a33135",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 251,
                  "startColumn": 79,
                  "endLine": 251,
                  "endColumn": 112,
                  "charOffset": 9105,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9105,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9105,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9339ec3a-a3fd-34da-9f8a-0bfe2e110b7d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 244,
                  "startColumn": 28,
                  "endLine": 244,
                  "endColumn": 61,
                  "charOffset": 8817,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8817,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8817,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9ce34748-88fe-3a48-9455-77615bb79aaa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 28,
                  "endLine": 241,
                  "endColumn": 61,
                  "charOffset": 8671,
                  "charLength": 33,
                  "snippet": {
                    "text": "strlen(MetroHash128::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash128::test_string)",
                      "markdown": "`strlen(MetroHash128::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8671,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8671,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash128::test_string, <size of MetroHash128::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c2a322c8-4e19-3173-831d-c30636dc795a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 231,
                  "startColumn": 4,
                  "endLine": 231,
                  "endColumn": 23,
                  "charOffset": 8423,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(hash, v, 16)",
                    "rendered": {
                      "text": "memcpy(hash, v, 16)",
                      "markdown": "`memcpy(hash, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8423,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5070b677-6126-3010-b227-c6acdfa7fe9e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 338,
                  "startColumn": 4,
                  "endLine": 338,
                  "endColumn": 22,
                  "charOffset": 12127,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12127,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c863d8cd-64be-347f-9535-7e3621370ac4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 4,
                  "endLine": 158,
                  "endColumn": 29,
                  "charOffset": 5932,
                  "charLength": 25,
                  "snippet": {
                    "text": "memcpy(hash, state.v, 16)",
                    "rendered": {
                      "text": "memcpy(hash, state.v, 16)",
                      "markdown": "`memcpy(hash, state.v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5932,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  state.v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fa72f9ea-f717-3472-8064-62799638fdb0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 8,
                  "endLine": 98,
                  "endColumn": 39,
                  "charOffset": 3656,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(input.b, ptr, end - ptr)",
                    "rendered": {
                      "text": "memcpy(input.b, ptr, end - ptr)",
                      "markdown": "`memcpy(input.b, ptr, end - ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3656,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b, <size of input.b>,  ptr,  end - ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "216f6fbd-5dce-3256-84f2-3f8f2f62559f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palStringUtil.h"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 27,
                  "endLine": 184,
                  "endColumn": 33,
                  "charOffset": 7010,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "75052834-d594-3977-acc4-c7a39cda9407",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Link Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 7,
                  "endLine": 9,
                  "endColumn": 28,
                  "charOffset": 254,
                  "charLength": 21,
                  "snippet": {
                    "text": "http://www.apache.org",
                    "rendered": {
                      "text": "http://www.apache.org",
                      "markdown": "`http://www.apache.org`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 254,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "https://www.apache.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "1cf146d3-7717-3971-9812-fd377714fc37",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 8,
                  "endLine": 71,
                  "endColumn": 69,
                  "charOffset": 2327,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                    "rendered": {
                      "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                      "markdown": "`memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2327,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b + (bytes % 32), <size of input.b + (bytes % 32)>,  ptr,  static_cast<size_t>(fill)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9453c534-c64a-3f10-8e02-2109ddde6d76",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128.cpp"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 41,
                  "endLine": 26,
                  "endColumn": 106,
                  "charOffset": 836,
                  "charLength": 65,
                  "snippet": {
                    "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                    "rendered": {
                      "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                      "markdown": "`\"012345678901234567890123456789012345678901234567890123456789012\"`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "64965a36-9aa3-3a47-8307-22726c8897f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palStringUtil.h"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 27,
                  "endLine": 158,
                  "endColumn": 42,
                  "charOffset": 6353,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(pString)",
                    "rendered": {
                      "text": "strlen(pString)",
                      "markdown": "`strlen(pString)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palStringUtil.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6353,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palStringUtil.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6353,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(pString, <size of pString>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "12f2c581-da9c-374d-94b7-c4f5373b4157",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/testvector.h"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 25,
                  "endLine": 38,
                  "endColumn": 98,
                  "charOffset": 1148,
                  "charLength": 73,
                  "snippet": {
                    "text": "key_63 = \"012345678901234567890123456789012345678901234567890123456789012",
                    "rendered": {
                      "text": "key_63 = \"012345678901234567890123456789012345678901234567890123456789012",
                      "markdown": "`key_63 = \"012345678901234567890123456789012345678901234567890123456789012`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "bad00dd9-8165-349f-a2ba-9c60ae765844",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palVector.h"
                },
                "region": {
                  "startLine": 432,
                  "startColumn": 17,
                  "endLine": 432,
                  "endColumn": 58,
                  "charOffset": 18721,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(m_pData, vector.m_pData, sizeof(T)",
                    "rendered": {
                      "text": "memcpy(m_pData, vector.m_pData, sizeof(T)",
                      "markdown": "`memcpy(m_pData, vector.m_pData, sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palVector.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18721,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_pData, <size of m_pData>,  vector.m_pData,  sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "039db223-e427-388a-9524-2bd71bc1d070",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 412,
                  "startColumn": 4,
                  "endLine": 412,
                  "endColumn": 25,
                  "charOffset": 12773,
                  "charLength": 21,
                  "snippet": {
                    "text": "memcpy(out, &hash, 8)",
                    "rendered": {
                      "text": "memcpy(out, &hash, 8)",
                      "markdown": "`memcpy(out, &hash, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12773,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &hash,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fcd8bbb9-1aec-3aa1-9a70-af78fe33e42b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 248,
                  "startColumn": 78,
                  "endLine": 248,
                  "endColumn": 110,
                  "charOffset": 7891,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7891,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7891,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a2a55aa4-63a3-3581-a057-3b37db7cc643",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 78,
                  "endLine": 253,
                  "endColumn": 110,
                  "charOffset": 8126,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8126,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8126,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0034256f-25c3-3bd3-a534-473323286eca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 4,
                  "endLine": 335,
                  "endColumn": 25,
                  "charOffset": 10513,
                  "charLength": 21,
                  "snippet": {
                    "text": "memcpy(out, &hash, 8)",
                    "rendered": {
                      "text": "memcpy(out, &hash, 8)",
                      "markdown": "`memcpy(out, &hash, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10513,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &hash,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cc53f7e7-6a0e-3fdf-a425-d3cf5cf2a638",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 27,
                  "endLine": 241,
                  "endColumn": 59,
                  "charOffset": 7608,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7608,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7608,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fd02be80-d618-31f0-83d8-47275feb8d97",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 27,
                  "endLine": 238,
                  "endColumn": 59,
                  "charOffset": 7466,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(MetroHash64::test_string)",
                    "rendered": {
                      "text": "strlen(MetroHash64::test_string)",
                      "markdown": "`strlen(MetroHash64::test_string)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7466,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7466,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(MetroHash64::test_string, <size of MetroHash64::test_string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "caebf481-db3b-30c5-b03c-427a63f73d9f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 4,
                  "endLine": 228,
                  "endColumn": 23,
                  "charOffset": 7222,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(hash, &h, 8)",
                    "rendered": {
                      "text": "memcpy(hash, &h, 8)",
                      "markdown": "`memcpy(hash, &h, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7222,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  &h,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "83ca735c-4206-3b43-a2cc-60a87106d1d9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 156,
                  "startColumn": 4,
                  "endLine": 156,
                  "endColumn": 28,
                  "charOffset": 5180,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(hash, state.v, 8)",
                    "rendered": {
                      "text": "memcpy(hash, state.v, 8)",
                      "markdown": "`memcpy(hash, state.v, 8)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5180,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hash, <size of hash>,  state.v,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0722109d-2b1c-3d91-91af-574a7cca8c86",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 8,
                  "endLine": 94,
                  "endColumn": 59,
                  "charOffset": 3199,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(input.b, ptr, static_cast<size_t>(end - ptr)",
                    "rendered": {
                      "text": "memcpy(input.b, ptr, static_cast<size_t>(end - ptr)",
                      "markdown": "`memcpy(input.b, ptr, static_cast<size_t>(end - ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3199,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b, <size of input.b>,  ptr,  static_cast<size_t>(end - ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "072c6b54-21eb-3927-a0a0-1c00be8036f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 8,
                  "endLine": 67,
                  "endColumn": 69,
                  "charOffset": 1849,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                    "rendered": {
                      "text": "memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)",
                      "markdown": "`memcpy(input.b + (bytes % 32), ptr, static_cast<size_t>(fill)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1849,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input.b + (bytes % 32), <size of input.b + (bytes % 32)>,  ptr,  static_cast<size_t>(fill)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "67b60382-5460-338a-a7a6-8e72bf1c5bce",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Link Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 7,
                  "endLine": 9,
                  "endColumn": 28,
                  "charOffset": 253,
                  "charLength": 21,
                  "snippet": {
                    "text": "http://www.apache.org",
                    "rendered": {
                      "text": "http://www.apache.org",
                      "markdown": "`http://www.apache.org`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 253,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "https://www.apache.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "dbc1b88f-07a2-36b0-b778-9e4a51cea174",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 4,
                  "endLine": 44,
                  "endColumn": 33,
                  "charOffset": 1186,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1186,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "228c1883-2d8c-3d81-bb95-b4b33fe39a13",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Storing Tokens or Keys in Source Code Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash64.cpp"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 40,
                  "endLine": 27,
                  "endColumn": 105,
                  "charOffset": 833,
                  "charLength": 65,
                  "snippet": {
                    "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                    "rendered": {
                      "text": "\"012345678901234567890123456789012345678901234567890123456789012\"",
                      "markdown": "`\"012345678901234567890123456789012345678901234567890123456789012\"`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Implementation.Privacy.Token"
            ]
          }
        },
        {
          "ruleId": "5e09879f-fb86-3c28-a1c9-c777246a5d04",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Link Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 7,
                  "endLine": 9,
                  "endColumn": 28,
                  "charOffset": 248,
                  "charLength": 21,
                  "snippet": {
                    "text": "http://www.apache.org",
                    "rendered": {
                      "text": "http://www.apache.org",
                      "markdown": "`http://www.apache.org`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 248,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "https://www.apache.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "dc6466cb-e6c6-3968-86f5-d2225573b658",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 4,
                  "endLine": 37,
                  "endColumn": 33,
                  "charOffset": 1055,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1055,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a1e76268-1ade-3948-be17-bb1520e4bf60",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 4,
                  "endLine": 175,
                  "endColumn": 22,
                  "charOffset": 5745,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5745,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "95a20299-6136-3301-afbf-28939d492ea1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 4,
                  "endLine": 51,
                  "endColumn": 33,
                  "charOffset": 1340,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&val, ptr, sizeof(val)",
                    "rendered": {
                      "text": "memcpy(&val, ptr, sizeof(val)",
                      "markdown": "`memcpy(&val, ptr, sizeof(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/platform.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1340,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&val, <size of &val>,  ptr,  sizeof(val)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dae61870-8590-398d-8e46-c133bce55307",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Link Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 7,
                  "endLine": 9,
                  "endColumn": 28,
                  "charOffset": 257,
                  "charLength": 21,
                  "snippet": {
                    "text": "http://www.apache.org",
                    "rendered": {
                      "text": "http://www.apache.org",
                      "markdown": "`http://www.apache.org`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 257,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "https://www.apache.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "2207fdc7-d63f-3e87-bfef-b5c6d5005117",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 1212,
                  "startColumn": 31,
                  "endLine": 1212,
                  "endColumn": 37,
                  "charOffset": 37450,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6944fd4f-ae9f-314c-8238-22b151255a1c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 476,
                  "startColumn": 6,
                  "endLine": 476,
                  "endColumn": 59,
                  "charOffset": 15235,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(value, module_name.c_str(), module_name.size()",
                    "rendered": {
                      "text": "memcpy(value, module_name.c_str(), module_name.size()",
                      "markdown": "`memcpy(value, module_name.c_str(), module_name.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/loader/executable.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15235,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  module_name.c_str(),  module_name.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "efd34705-397d-3edb-a540-a263b04c6e50",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1562,
                  "startColumn": 4,
                  "endLine": 1562,
                  "endColumn": 9,
                  "charOffset": 51265,
                  "charLength": 5,
                  "snippet": {
                    "text": "qsort",
                    "rendered": {
                      "text": "qsort",
                      "markdown": "`qsort`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3f28809a-59d9-3416-af4f-45d3bbc8c282",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1523,
                  "startColumn": 11,
                  "endLine": 1523,
                  "endColumn": 17,
                  "charOffset": 49870,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0cfd4175-2f0f-39c6-bc06-c3896e02e982",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/pal/shared/metrohash/src/metrohash128crc.cpp"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 4,
                  "endLine": 99,
                  "endColumn": 22,
                  "charOffset": 3269,
                  "charLength": 18,
                  "snippet": {
                    "text": "memcpy(out, v, 16)",
                    "rendered": {
                      "text": "memcpy(out, v, 16)",
                      "markdown": "`memcpy(out, v, 16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/pal/shared/metrohash/src/metrohash128crc.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3269,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  v,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dcc69853-8cd0-3e6a-86b1-1a1d27eba18d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1389,
                  "startColumn": 8,
                  "endLine": 1389,
                  "endColumn": 14,
                  "charOffset": 46065,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bd2497c8-124c-3e6a-8b8e-13f08d345f78",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1337,
                  "startColumn": 21,
                  "endLine": 1337,
                  "endColumn": 29,
                  "charOffset": 44512,
                  "charLength": 8,
                  "snippet": {
                    "text": "mbstowcs",
                    "rendered": {
                      "text": "mbstowcs",
                      "markdown": "`mbstowcs`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cfcb1335-dd49-35c3-84e0-94d60d82a839",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1016,
                  "startColumn": 42,
                  "endLine": 1016,
                  "endColumn": 46,
                  "charOffset": 33145,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0dc0d5d1-db82-34b6-85c7-94baee06983c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1072,
                  "startColumn": 23,
                  "endLine": 1072,
                  "endColumn": 40,
                  "charOffset": 35538,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(pStrValue)",
                    "rendered": {
                      "text": "strlen(pStrValue)",
                      "markdown": "`strlen(pStrValue)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35538,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(pStrValue, <size of pStrValue>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35538,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(pStrValue, <size of pStrValue>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "18b7a1ef-9e54-3560-8965-a7c274267012",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 1043,
                  "startColumn": 60,
                  "endLine": 1043,
                  "endColumn": 64,
                  "charOffset": 34371,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5cb85615-ab6a-31d9-8e2c-757b29c46957",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 967,
                  "startColumn": 29,
                  "endLine": 967,
                  "endColumn": 41,
                  "charOffset": 31562,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pDst)",
                    "rendered": {
                      "text": "strlen(pDst)",
                      "markdown": "`strlen(pDst)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31562,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pDst, <size of pDst>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31562,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pDst, <size of pDst>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "46e2d68e-426a-3048-b85e-f01421e9076d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncat)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 968,
                  "startColumn": 4,
                  "endLine": 968,
                  "endColumn": 50,
                  "charOffset": 31580,
                  "charLength": 46,
                  "snippet": {
                    "text": "strncat(pDst, pSrc, (sizeDst - dstLength - 1))",
                    "rendered": {
                      "text": "strncat(pDst, pSrc, (sizeDst - dstLength - 1))",
                      "markdown": "`strncat(pDst, pSrc, (sizeDst - dstLength - 1))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31580,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strcat_s(pDst,  (sizeDst - dstLength - 1,  pSrc)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31580,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strlcat(pDst,  pSrc,  (sizeDst - dstLength - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a6988277-a364-38ff-8910-1afcbd631356",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/loader/executable.cpp"
                },
                "region": {
                  "startLine": 467,
                  "startColumn": 6,
                  "endLine": 467,
                  "endColumn": 59,
                  "charOffset": 14944,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(value, symbol_name.c_str(), symbol_name.size()",
                    "rendered": {
                      "text": "memcpy(value, symbol_name.c_str(), symbol_name.size()",
                      "markdown": "`memcpy(value, symbol_name.c_str(), symbol_name.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/loader/executable.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14944,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  symbol_name.c_str(),  symbol_name.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d479c29b-2771-3785-86f1-1eafd827d1ed",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 948,
                  "startColumn": 4,
                  "endLine": 948,
                  "endColumn": 11,
                  "charOffset": 30750,
                  "charLength": 7,
                  "snippet": {
                    "text": "wcsncat",
                    "rendered": {
                      "text": "wcsncat",
                      "markdown": "`wcsncat`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b3b94754-8355-30fa-ae1f-1cfdf721771d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 947,
                  "startColumn": 31,
                  "endLine": 947,
                  "endColumn": 37,
                  "charOffset": 30732,
                  "charLength": 6,
                  "snippet": {
                    "text": "wcslen",
                    "rendered": {
                      "text": "wcslen",
                      "markdown": "`wcslen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4517ca83-ccfb-3f9d-9aa7-02b562597bfd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 933,
                  "startColumn": 4,
                  "endLine": 933,
                  "endColumn": 11,
                  "charOffset": 30377,
                  "charLength": 7,
                  "snippet": {
                    "text": "wcsncpy",
                    "rendered": {
                      "text": "wcsncpy",
                      "markdown": "`wcsncpy`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7e61ac96-db2d-3e4d-aedd-fd3edffa3fcb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 910,
                  "startColumn": 14,
                  "endLine": 910,
                  "endColumn": 26,
                  "charOffset": 29664,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(pSrc)",
                    "rendered": {
                      "text": "strlen(pSrc)",
                      "markdown": "`strlen(pSrc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29664,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(pSrc, <size of pSrc>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29664,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(pSrc, <size of pSrc>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "49f26f4a-0d12-386d-9fc2-675fd23f8c36",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palMemTrackerImpl.h"
                },
                "region": {
                  "startLine": 307,
                  "startColumn": 33,
                  "endLine": 307,
                  "endColumn": 37,
                  "charOffset": 14190,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a07e0391-1fc1-3da9-bbdb-bc6c30f91d8c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                },
                "region": {
                  "startLine": 918,
                  "startColumn": 8,
                  "endLine": 918,
                  "endColumn": 42,
                  "charOffset": 29902,
                  "charLength": 34,
                  "snippet": {
                    "text": "strncpy(pDst, pSrc, (dstSize - 1))",
                    "rendered": {
                      "text": "strncpy(pDst, pSrc, (dstSize - 1))",
                      "markdown": "`strncpy(pDst, pSrc, (dstSize - 1))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29902,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strcpy_s(pDst,  (dstSize - 1,  pSrc)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250515a/pal/inc/util/palInlineFuncs.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29902,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strlcpy(pDst,  pSrc,  (dstSize - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3c199c27-0ee1-38f1-8fbe-93c048fec2c4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 1548,
                  "startColumn": 8,
                  "endLine": 1548,
                  "endColumn": 39,
                  "charOffset": 55012,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(buf, buffer, bufferSize)",
                    "rendered": {
                      "text": "memcpy(buf, buffer, bufferSize)",
                      "markdown": "`memcpy(buf, buffer, bufferSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55012,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf, <size of buf>,  buffer,  bufferSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "acf2911c-0eb8-3ceb-96df-be78cb82d49c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 998,
                  "startColumn": 10,
                  "endLine": 998,
                  "endColumn": 76,
                  "charOffset": 37537,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)",
                    "rendered": {
                      "text": "memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)",
                      "markdown": "`memcpy(dest, (const char*) edata->d_buf + offset - coffset, csize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37537,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  (const char*) edata->d_buf + offset - coffset,  csize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "86cac946-bb45-354c-a07e-557143427fb8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250515a/pal/inc/util/palMemTrackerImpl.h"
                },
                "region": {
                  "startLine": 305,
                  "startColumn": 26,
                  "endLine": 305,
                  "endColumn": 32,
                  "charOffset": 14123,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e3e3f85a-d40a-30ab-b258-c58df38ee735",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/loader/executable.hpp"
                },
                "region": {
                  "startLine": 320,
                  "startColumn": 33,
                  "endLine": 320,
                  "endColumn": 39,
                  "charOffset": 10965,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bd5d3a33-72bb-3290-b3ab-c7943d24f9ff",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 1442,
                  "startColumn": 45,
                  "endLine": 1442,
                  "endColumn": 51,
                  "charOffset": 56567,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "826a85ab-88b9-3ca8-a1a1-3b506d9f7a9a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250722a/sc/HSAIL/ext/loader/loaders.cpp"
                },
                "region": {
                  "startLine": 213,
                  "startColumn": 4,
                  "endLine": 213,
                  "endColumn": 44,
                  "charOffset": 6729,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy((char *) dst + offset, src, size)",
                    "rendered": {
                      "text": "memcpy((char *) dst + offset, src, size)",
                      "markdown": "`memcpy((char *) dst + offset, src, size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250722a/sc/HSAIL/ext/loader/loaders.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6729,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s((char *) dst + offset, <size of (char *) dst + offset>,  src,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a8b62123-502e-32e3-8557-585aa866e46b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 1536,
                  "startColumn": 8,
                  "endLine": 1536,
                  "endColumn": 40,
                  "charOffset": 54707,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(*buf, buffer, bufferSize)",
                    "rendered": {
                      "text": "memcpy(*buf, buffer, bufferSize)",
                      "markdown": "`memcpy(*buf, buffer, bufferSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 54707,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(*buf, <size of *buf>,  buffer,  bufferSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3feca8a5-d11f-3fc2-822b-b243311c1ca8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 927,
                  "startColumn": 8,
                  "endLine": 927,
                  "endColumn": 46,
                  "charOffset": 37284,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(svalue, isa.c_str(), (std::min)",
                    "rendered": {
                      "text": "memcpy(svalue, isa.c_str(), (std::min)",
                      "markdown": "`memcpy(svalue, isa.c_str(), (std::min)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37284,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svalue, <size of svalue>,  isa.c_str(),  (std::min)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f02ecc06-d5b0-30ac-b862-b3b3f272cb81",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_elf_image.cpp"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 41,
                  "endLine": 150,
                  "endColumn": 49,
                  "charOffset": 4364,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bd306526-e36b-3f8b-81d2-224c6f1b0ee8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 917,
                  "startColumn": 8,
                  "endLine": 917,
                  "endColumn": 50,
                  "charOffset": 36853,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(svalue, version.c_str(), (std::min)",
                    "rendered": {
                      "text": "memcpy(svalue, version.c_str(), (std::min)",
                      "markdown": "`memcpy(svalue, version.c_str(), (std::min)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36853,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svalue, <size of svalue>,  version.c_str(),  (std::min)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bb2bf0fb-3cb1-3433-bebf-3237240042f6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 882,
                  "startColumn": 6,
                  "endLine": 882,
                  "endColumn": 70,
                  "charOffset": 35550,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(desc->producer_options, options.c_str(), options.length()",
                    "rendered": {
                      "text": "memcpy(desc->producer_options, options.c_str(), options.length()",
                      "markdown": "`memcpy(desc->producer_options, options.c_str(), options.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35550,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->producer_options, <size of desc->producer_options>,  options.c_str(),  options.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e97a9f54-b3fd-3837-8d76-9c24aa2f005e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 540,
                  "startColumn": 6,
                  "endLine": 540,
                  "endColumn": 90,
                  "charOffset": 17722,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()",
                    "rendered": {
                      "text": "memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()",
                      "markdown": "`memcpy(desc->vendor_and_architecture_name, vendor_name.c_str(), vendor_name.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17722,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->vendor_and_architecture_name, <size of desc->vendor_and_architecture_name>,  vendor_name.c_str(),  vendor_name.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f023fa97-adeb-35a3-a647-670a919f583c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 863,
                  "startColumn": 6,
                  "endLine": 863,
                  "endColumn": 69,
                  "charOffset": 34685,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy(desc->producer_name, producer.c_str(), producer.length()",
                    "rendered": {
                      "text": "memcpy(desc->producer_name, producer.c_str(), producer.length()",
                      "markdown": "`memcpy(desc->producer_name, producer.c_str(), producer.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34685,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->producer_name, <size of desc->producer_name>,  producer.c_str(),  producer.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bffdaaa1-76ab-3e95-8a13-940540c1e318",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                },
                "region": {
                  "startLine": 541,
                  "startColumn": 6,
                  "endLine": 541,
                  "endColumn": 127,
                  "charOffset": 17819,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()",
                    "rendered": {
                      "text": "memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()",
                      "markdown": "`memcpy(desc->vendor_and_architecture_name + desc->vendor_name_size, architecture_name.c_str(), architecture_name.length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "20250414a/sc/HSAIL/ext/libamdhsacode/amd_hsa_code.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17819,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(desc->vendor_and_architecture_name + desc->vendor_name_size, <size of desc->vendor_and_architecture_name + desc->vendor_name_size>,  architecture_name.c_str(),  architecture_name.length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}